<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大鼓达人 - 演奏模式</title>
    <style>
        /* CSS Variables for Vaporwave + Mondrian Colors */
        :root {
            /* Vaporwave color palette */
            --vaporwave-pink: #FF006E;
            --vaporwave-purple: #8338EC;
            --vaporwave-blue: #3A86FF;
            --vaporwave-cyan: #06FFA5;
            --vaporwave-yellow: #FFBE0B;
            --vaporwave-white: #FFFFFF;
            --vaporwave-black: #000000;
            
            /* Main theme colors for don/ka */
            --primary-red: var(--vaporwave-pink);
            --primary-blue: var(--vaporwave-purple);
            --don-color: var(--vaporwave-pink);
            --ka-color: var(--vaporwave-purple);
            --don-accent: #FF6B9D;
            --ka-accent: #B366EC;
            --bg-gradient: linear-gradient(135deg, #FF006E, #8338EC, #3A86FF, #06FFA5, #FFBE0B);
            --text-white: #FFFFFF;
            --text-dark: #000000;
            --score-bg: rgba(255, 255, 255, 0.95);
            --drum-shadow: rgba(0, 0, 0, 0.4);
            --hit-effect: rgba(255, 0, 110, 0.9);
            --ka-hit-effect: rgba(131, 56, 236, 0.9);
            
            /* Dynamic category colors - will be updated by JavaScript */
            --category-primary: #FF006E;
            --category-secondary: #8338EC;
            --category-accent: #3A86FF;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #FF006E, #8338EC, #3A86FF, #06FFA5, #FFBE0B);
            background-size: 400% 400%;
            animation: vaporwave-gradient 8s ease infinite;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        @keyframes vaporwave-gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Game Container */
        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Mondrian Grid Background */
        .mondrian-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.2;
        }
        
        /* Chinese Elements Background */
        .chinese-elements {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            opacity: 0.6;
        }

        /* Legacy background support - hidden */
        .game-background {
            display: none;
        }

        /* Top Banner - Tiling pattern from top to above character */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: calc(55vh - 230px); /* Set to 55vh - 230px as requested */
            background-repeat: repeat;
            background-size: auto;
            background-position: 0 0;
            z-index: 3; /* Below character but above background */
            opacity: 0;
            transition: opacity 0.5s ease;
            animation: bannerScroll 20s linear infinite; /* Smooth continuous movement */
            display: none; /* Hidden by default */
        }

        .top-banner.loaded {
            opacity: 1;
        }

        /* Banner scrolling animation - Particle-like movement using sin/cos */
        @keyframes bannerScroll {
            0% {
                background-position: 0px 0px;
            }
            12.5% {
                background-position: 35px 15px; /* sin(π/4) ≈ 0.7, cos(π/4) ≈ 0.7 */
            }
            25% {
                background-position: 50px 50px; /* sin(π/2) = 1, cos(π/2) = 0 */
            }
            37.5% {
                background-position: 35px 85px; /* sin(3π/4) ≈ 0.7, cos(3π/4) ≈ -0.7 */
            }
            50% {
                background-position: 0px 100px; /* sin(π) = 0, cos(π) = -1 */
            }
            62.5% {
                background-position: -35px 85px; /* sin(5π/4) ≈ -0.7, cos(5π/4) ≈ -0.7 */
            }
            75% {
                background-position: -50px 50px; /* sin(3π/2) = -1, cos(3π/2) = 0 */
            }
            87.5% {
                background-position: -35px 15px; /* sin(7π/4) ≈ -0.7, cos(7π/4) ≈ 0.7 */
            }
            100% {
                background-position: 0px 0px; /* sin(2π) = 0, cos(2π) = 1 */
            }
        }

        /* Character Display (Above don-display) */
        .character-display {
            position: absolute;
            left: -20px; /* Character center aligns with don center (60px - 80px) */
            top: calc(30% - 210px); /* Down 15px from previous position */
            width: 160px; /* Character size */
            height: 160px; /* Character size */
            z-index: 15; /* Above banner and other elements */
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .character-display.loaded {
            opacity: 1;
        }

        .character-display img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 0;
            display: block;
        }

        /* Hide character when no image loaded */
        .character-display img[src=""], .character-display img:not([src]) {
            display: none;
        }

        /* Game Track Container */
        .game-track-container {
            position: absolute;
            top: 30%;
            left: 0;
            right: 0;
            height: 130px; /* Increased by 10px */
            transform: translateY(-50%);
            z-index: 5;
        }

        /* Don Character Display (Left of beat track like Taiko) */
        .don-display {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .don-face {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--vaporwave-white), #E0E0E0);
            border: 4px solid var(--vaporwave-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #8B4513;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        /* 外圈 - Ka区域 */
        .don-face::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: inherit;
            transition: all 0.2s ease;
            z-index: 1;
        }

        /* 内圈 - Don区域 */
        .don-face::after {
            content: '';
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: inherit;
            border: 2px solid #FFF8E1;
            transition: all 0.2s ease;
            z-index: 2;
        }

        /* Ka击打效果 - 外圈蒸汽波紫 */
        .don-face.hit-ka::before {
            background: linear-gradient(45deg, var(--ka-color), var(--ka-accent));
            box-shadow: 0 0 15px rgba(131, 56, 236, 0.8);
        }

        /* Don击打效果 - 内圈蒸汽波粉 */
        .don-face.hit-don::after {
            background: linear-gradient(45deg, var(--don-color), var(--don-accent));
            box-shadow: 0 0 15px rgba(255, 0, 110, 0.8);
        }

        .don-combo {
            font-size: 20px;
            font-weight: 900;
            color: #8B4513;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
        }

        /* Score Display - Above Game Track Container Bottom Border */
        .score-bar {
            position: absolute;
            left: 60px; /* Center relative to don face (20px + 40px center) */
            top: calc(30% + 62px); /* Just above the bottom border of game track container (130px/2 - 3px) */
            transform: translateX(-50%) translateY(-100%); /* Position above the line */
            background: transparent;
            padding: 3px 8px;
            font-size: 10px; /* Very small font */
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 15;
            text-align: center;
            min-width: 60px;
        }

        /* Spirit System Display - Vaporwave + Mondrian Style */
        .spirit-system {
            position: absolute;
            right: 0px;
            top: calc(30% - 85px);
            width: 50vw;
            max-width: 400px;
            height: 40px;
            z-index: 15;
            background: linear-gradient(90deg, 
                rgba(0, 0, 0, 0.8) 0%,
                rgba(255, 0, 110, 0.1) 30%,
                rgba(131, 56, 236, 0.1) 70%,
                rgba(0, 0, 0, 0.8) 100%
            );
            border: 4px solid #FFFFFF;
            border-radius: 0; /* 蒙德里安风格：无圆角 */
            overflow: hidden;
            box-shadow: 
                0 0 20px rgba(255, 0, 110, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.3),
                inset 0 -2px 0 rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(8px);
            animation: mondrianGlow 4s ease-in-out infinite;
            /* 蒙德里安几何分割线 */
            position: relative;
        }
        
        /* 蒙德里安分割线效果 */
        .spirit-system::before {
            content: '';
            position: absolute;
            top: 0;
            left: 30%;
            width: 2px;
            height: 100%;
            background: #FFFFFF;
            opacity: 0.6;
        }
        
        .spirit-system::after {
            content: '';
            position: absolute;
            top: 0;
            left: 70%;
            width: 2px;
            height: 100%;
            background: #FFFFFF;
            opacity: 0.6;
        }
        
        @keyframes mondrianGlow {
            0%, 100% {
                box-shadow: 
                    0 0 15px rgba(255, 0, 110, 0.3),
                    inset 0 2px 0 rgba(255, 255, 255, 0.3),
                    inset 0 -2px 0 rgba(255, 255, 255, 0.3);
                border-color: #FFFFFF;
            }
            25% {
                box-shadow: 
                    0 0 25px rgba(255, 0, 110, 0.6),
                    inset 0 2px 0 rgba(255, 0, 110, 0.5),
                    inset 0 -2px 0 rgba(255, 0, 110, 0.5);
                border-color: #FF006E;
            }
            50% {
                box-shadow: 
                    0 0 30px rgba(58, 134, 255, 0.6),
                    inset 0 2px 0 rgba(58, 134, 255, 0.5),
                    inset 0 -2px 0 rgba(58, 134, 255, 0.5);
                border-color: #3A86FF;
            }
            75% {
                box-shadow: 
                    0 0 25px rgba(131, 56, 236, 0.6),
                    inset 0 2px 0 rgba(131, 56, 236, 0.5),
                    inset 0 -2px 0 rgba(131, 56, 236, 0.5);
                border-color: #8338EC;
            }
        }

        /* Mondrian-style spirit progress container */
        .spirit-lines {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg, 
                transparent 0%,
                rgba(255, 0, 110, 0.1) 30%,
                rgba(131, 56, 236, 0.1) 70%,
                transparent 100%
            );
        }

        /* Mondrian geometric spirit segments */
        .spirit-line {
            width: 2px;
            height: 28px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 0; /* 蒙德里安风格：无圆角 */
            transition: all 0.4s ease;
            position: relative;
        }

        /* Vaporwave progression stages */
        .spirit-line.active-yellow {
            background: linear-gradient(180deg, #FFBE0B 0%, #FFD700 100%);
            width: 3px;
            height: 32px;
            box-shadow: 0 0 8px rgba(255, 190, 11, 0.6);
        }

        .spirit-line.active-orange {
            background: linear-gradient(180deg, #FF006E 0%, #FF6B9D 100%);
            width: 4px;
            height: 32px;
            box-shadow: 0 0 12px rgba(255, 0, 110, 0.8);
        }

        /* Chinese-inspired high energy state (85%+) */
        .spirit-line.active-rainbow {
            width: 6px;
            height: 36px;
            background: linear-gradient(180deg, #FF006E 0%, #8338EC 50%, #3A86FF 100%);
            animation: chineseDragonPulse 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 0, 110, 0.9);
        }

        /* Chinese dragon-inspired energy pulse */
        @keyframes chineseDragonPulse {
            0%, 100% { 
                background: linear-gradient(180deg, #FF006E 0%, #8338EC 50%, #3A86FF 100%);
                box-shadow: 0 0 15px rgba(255, 0, 110, 0.9);
            }
            33% { 
                background: linear-gradient(180deg, #8338EC 0%, #3A86FF 50%, #06FFA5 100%);
                box-shadow: 0 0 20px rgba(131, 56, 236, 0.9);
            }
            66% { 
                background: linear-gradient(180deg, #3A86FF 0%, #06FFA5 50%, #FFBE0B 100%);
                box-shadow: 0 0 18px rgba(58, 134, 255, 0.9);
            }
        }

        /* Chinese-inspired high energy container effect */
        .spirit-system.rainbow-mode {
            animation: dragonGlow 3s ease-in-out infinite;
            background: linear-gradient(90deg, 
                rgba(0, 0, 0, 0.8) 0%,
                rgba(255, 0, 110, 0.2) 20%,
                rgba(131, 56, 236, 0.2) 40%,
                rgba(58, 134, 255, 0.2) 60%,
                rgba(6, 255, 165, 0.2) 80%,
                rgba(0, 0, 0, 0.8) 100%
            );
        }

        @keyframes dragonGlow {
            0%, 100% {
                box-shadow: 
                    0 0 25px rgba(255, 0, 110, 0.4),
                    inset 0 2px 0 rgba(255, 0, 110, 0.5),
                    inset 0 -2px 0 rgba(255, 0, 110, 0.5);
                border-color: #FF006E;
            }
            25% {
                box-shadow: 
                    0 0 30px rgba(131, 56, 236, 0.6),
                    inset 0 2px 0 rgba(131, 56, 236, 0.6),
                    inset 0 -2px 0 rgba(131, 56, 236, 0.6);
                border-color: #8338EC;
            }
            50% {
                box-shadow: 
                    0 0 35px rgba(58, 134, 255, 0.6),
                    inset 0 2px 0 rgba(58, 134, 255, 0.6),
                    inset 0 -2px 0 rgba(58, 134, 255, 0.6);
                border-color: #3A86FF;
            }
            75% {
                box-shadow: 
                    0 0 30px rgba(6, 255, 165, 0.6),
                    inset 0 2px 0 rgba(6, 255, 165, 0.6),
                    inset 0 -2px 0 rgba(6, 255, 165, 0.6);
                border-color: #06FFA5;
            }
        }

        .spirit-label {
            position: absolute;
            right: calc(50vw + 20px);
            top: calc(30% - 85px + 20px);
            transform: translateY(-50%);
            font-size: 14px;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 
                0 0 8px rgba(255, 0, 110, 0.8),
                2px 2px 4px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
            padding: 8px 16px;
            background: linear-gradient(45deg, 
                rgba(0, 0, 0, 0.9) 0%,
                rgba(255, 0, 110, 0.1) 50%,
                rgba(0, 0, 0, 0.9) 100%
            );
            border: 2px solid #FFFFFF;
            border-radius: 0;
            backdrop-filter: blur(5px);
            animation: labelGlow 4s ease-in-out infinite;
            /* 中国风小装饰 */
            position: relative;
        }

        /* 标签左侧小装饰 */
        .spirit-label::before {
            content: '◆';
            position: absolute;
            left: -12px;
            top: 50%;
            transform: translateY(-50%);
            color: #FF006E;
            font-size: 8px;
            text-shadow: 0 0 6px rgba(255, 0, 110, 0.9);
            animation: sparkle 2s ease-in-out infinite alternate;
        }

        @keyframes labelGlow {
            0%, 100% {
                border-color: #FFFFFF;
                text-shadow: 
                    0 0 8px rgba(255, 255, 255, 0.6),
                    2px 2px 4px rgba(0, 0, 0, 0.9);
            }
            25% {
                border-color: #FF006E;
                text-shadow: 
                    0 0 10px rgba(255, 0, 110, 0.8),
                    2px 2px 4px rgba(0, 0, 0, 0.9);
            }
            50% {
                border-color: #8338EC;
                text-shadow: 
                    0 0 10px rgba(131, 56, 236, 0.8),
                    2px 2px 4px rgba(0, 0, 0, 0.9);
            }
            75% {
                border-color: #3A86FF;
                text-shadow: 
                    0 0 10px rgba(58, 134, 255, 0.8),
                    2px 2px 4px rgba(0, 0, 0, 0.9);
            }
        }

        @keyframes sparkle {
            0% {
                color: #FF006E;
                text-shadow: 0 0 6px rgba(255, 0, 110, 0.9);
            }
            100% {
                color: #06FFA5;
                text-shadow: 0 0 8px rgba(6, 255, 165, 0.9);
            }
        }

        /* Song Name Display - Top Right Corner */
        .song-name {
            position: absolute;
            top: 20px;
            right: 20px;
            max-width: 40vw; /* Prevent overflow on narrow screens */
            font-size: 18px;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 20; /* Above all other elements */
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            backdrop-filter: blur(5px);
        }

        /* Song Selection Screen - Full screen overlay */
        .song-selection-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #FF006E, #8338EC, #3A86FF, #06FFA5, #FFBE0B);
            background-size: 400% 400%;
            animation: vaporwave-gradient 8s ease infinite;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Hide overflow for background animation */
        }

        /* Multiple lines of scrolling text - Line 1 */
        .song-selection-screen::before {
            content: '演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式';
            position: absolute;
            top: -30vh;
            left: -60vw;
            width: 220vw;
            height: 160vh;
            font-size: 2.5rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.2);
            white-space: nowrap;
            transform: rotate(-15deg);
            animation: diagonalScroll 25s linear infinite;
            pointer-events: none;
            z-index: -1;
            letter-spacing: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Create multiple parallel lines using text-shadow */
            text-shadow: 
                0 8rem rgba(255, 255, 255, 0.2),
                0 16rem rgba(255, 255, 255, 0.18),
                0 24rem rgba(255, 255, 255, 0.16),
                0 32rem rgba(255, 255, 255, 0.14),
                0 40rem rgba(255, 255, 255, 0.12),
                0 48rem rgba(255, 255, 255, 0.1),
                0 -8rem rgba(255, 255, 255, 0.2),
                0 -16rem rgba(255, 255, 255, 0.18),
                0 -24rem rgba(255, 255, 255, 0.16),
                0 -32rem rgba(255, 255, 255, 0.14),
                0 -40rem rgba(255, 255, 255, 0.12),
                0 -48rem rgba(255, 255, 255, 0.1);
        }

        /* Multiple lines of scrolling text - Line 2 */
        .song-selection-screen::after {
            content: '演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式 演奏模式';
            position: absolute;
            top: -25vh;
            left: -55vw;
            width: 220vw;
            height: 160vh;
            font-size: 2.5rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.15);
            white-space: nowrap;
            transform: rotate(-15deg);
            animation: diagonalScroll 30s linear infinite reverse;
            pointer-events: none;
            z-index: -2;
            letter-spacing: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Create multiple parallel lines using text-shadow - offset pattern */
            text-shadow: 
                0 4rem rgba(255, 255, 255, 0.15),
                0 12rem rgba(255, 255, 255, 0.13),
                0 20rem rgba(255, 255, 255, 0.11),
                0 28rem rgba(255, 255, 255, 0.09),
                0 36rem rgba(255, 255, 255, 0.07),
                0 44rem rgba(255, 255, 255, 0.05),
                0 -4rem rgba(255, 255, 255, 0.15),
                0 -12rem rgba(255, 255, 255, 0.13),
                0 -20rem rgba(255, 255, 255, 0.11),
                0 -28rem rgba(255, 255, 255, 0.09),
                0 -36rem rgba(255, 255, 255, 0.07),
                0 -44rem rgba(255, 255, 255, 0.05);
        }

        /* Diagonal scrolling animation */
        @keyframes diagonalScroll {
            0% {
                transform: rotate(-15deg) translateX(-100%);
            }
            100% {
                transform: rotate(-15deg) translateX(100%);
            }
        }


        /* Main content area - Mobile: character and song info share first column, stats in second */
        .selection-main {
            display: grid;
            grid-template-columns: 2fr 1fr;
            grid-template-rows: 2fr 3fr; /* 2:3 ratio for the left column panels */
            grid-template-areas: 
                "character stats"
                "song-info stats";
            padding: 1rem;
            gap: 0.5rem;
            /* Remove max-width to match song-list width */
            margin: 0;
            align-items: stretch; /* Changed from start to stretch to fill height */
            height: 55vh; /* Exactly 55% of viewport height */
            flex-shrink: 0;
        }

        /* Desktop mode - Three column layout with flexible height */
        @media (min-width: 1024px) {
            .selection-main {
                grid-template-columns: 1fr 2fr 1fr;
                grid-template-rows: 1fr; /* Reset to single row for desktop */
                grid-template-areas: "character song-info stats";
                padding: 1rem;
                gap: 1rem;
                align-items: start; /* Reset to start alignment for desktop */
                height: auto; /* Allow flexible height on desktop */
                min-height: 40vh; /* Minimum height to ensure space */
                max-height: 55vh; /* Maximum height to leave space for song list */
                /* Keep same margin as mobile - no centering constraint */
                margin: 0;
            }

            /* Adjust song list container position for desktop */
            .song-list-container {
                height: 40vh; /* Smaller on desktop to give more space to main content */
            }
        }

        /* Character Panel - Independent grid item */
        .character-panel {
            grid-area: character;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border: 3px solid #8B4513;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            height: 100%; /* Fill the grid area height */
        }

        /* Desktop character panel styling */
        @media (min-width: 1024px) {
            .character-panel {
                flex-direction: column;
                align-items: center;
                text-align: center;
                padding: 1rem;
                height: auto; /* Reset height for desktop */
            }

            .character-avatar {
                margin-bottom: 1rem;
            }

            .character-avatar img {
                width: 100px;
                height: 100px;
            }

            .difficulty-label {
                padding: 0.5rem 1rem;
                font-size: 0.875rem;
                width: 100%;
                box-sizing: border-box;
            }
        }

        .character-avatar {
            flex-shrink: 0;
        }

        .character-avatar img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
        }

        .difficulty-info {
            flex: 1;
        }

        .difficulty-label {
            background: #FF8C00;
            color: white;
            padding: 0.25rem 0.5rem;
            font-weight: bold;
            font-size: 0.75rem;
            display: inline-block;
        }

        /* Song Info Panel - Independent grid item */
        .song-info-panel {
            grid-area: song-info;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%; /* Fill the grid area height */
        }

        /* Desktop song info panel styling */
        @media (min-width: 1024px) {
            .song-info-panel {
                height: auto; /* Reset height for desktop */
            }
            
            .song-info-frame {
                padding: 2.5rem;
            }

            .selected-song-name {
                font-size: 1.75rem;
            }
        }

        .song-info-frame {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border: 4px solid #8B4513;
            padding: 2rem;
            padding-bottom: 3.5rem; /* Add extra padding at bottom for button space */
            text-align: center;
            width: 100%;
            max-width: 500px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 120px; /* Set minimum height to prevent size changes */
        }

        .song-info-frame:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .song-info-frame.expanded {
            /* Remove scale transformation, keep same size */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        /* No need to adjust title position since button is absolutely positioned */

        /* Floating Start Performance Button */
        .start-performance-btn {
            position: absolute;
            top: calc(50% + 50px); /* Move down by 50% of button height (approx) */
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #FF4500, #FF6347);
            color: white;
            border: none;
            border-radius: 0; /* Remove rounded corners */
            width: 120px; /* Fixed width */
            height: 50px; /* Fixed height */
            font-size: 16px; /* Fixed font size */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            z-index: 9999; /* Highest z-index - above everything */
            opacity: 0;
            visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Show button when a real song is selected */
        .start-performance-btn.visible {
            opacity: 1;
            visibility: visible;
        }

        .start-performance-btn:hover {
            background: linear-gradient(45deg, #FF6347, #FF8C00);
        }

        .start-performance-btn:active {
            background: linear-gradient(45deg, #CC3300, #FF4500);
        }

        .song-icon {
            position: absolute;
            top: -20px;
            left: 20px;
            background: #FF4500;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #8B4513;
        }

        .song-symbol {
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
        }

        .selected-song-name {
            font-size: clamp(1.25rem, 4vw, 2rem);
            font-weight: bold;
            color: #8B4513;
            margin: 1rem 0;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
            word-break: break-word;
            transition: all 0.3s ease; /* Smooth title position changes */
        }

        .song-genre {
            background: var(--category-primary, #4FA8B8);
            color: white;
            padding: 0.25rem 1rem;
            font-weight: bold;
            display: inline-block;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            border-radius: 0;
            transition: all 0.3s ease;
        }

        /* Stats Panel - Independent grid item */
        .stats-panel {
            grid-area: stats;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border: 3px solid #8B4513;
            height: 100%;
        }

        /* Desktop stats panel styling */
        @media (min-width: 1024px) {
            .stats-panel {
                padding: 1rem;
            }

            .stats-title {
                font-size: 0.875rem;
                margin-bottom: 1rem;
                padding-bottom: 0.5rem;
            }

            .stats-panel .stat-row {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }

            .stats-panel .stat-label {
                font-size: 0.75rem;
            }

            .stats-panel .stat-value {
                font-size: 0.75rem;
            }
        }

        .stats-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #8B4513;
            border-bottom: 2px solid #8B4513;
            padding-bottom: 0.25rem;
            font-size: 0.75rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
            font-size: 0.625rem;
        }

        .stats-panel .stat-label {
            color: #333;
            font-size: 0.625rem;
        }

        .stats-panel .stat-value {
            font-weight: bold;
            color: #8B4513;
            font-size: 0.625rem; /* Same size as stat-label, more specific selector */
        }

        /* Song List Container - Fixed bottom panel (45% height) */
        .song-list-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 45vh;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            z-index: 1001;
        }

        /* Category Selection Button */
        .category-select-btn {
            position: absolute;
            top: calc(50% + 50px); /* Same level as start performance button */
            left: calc(50% - 150px); /* Position to the left of start button */
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            border: none;
            border-radius: 0; /* Remove rounded corners */
            color: white; /* Match start button color */
            width: 120px; /* Fixed width - same as start button */
            height: 50px; /* Fixed height - same as start button */
            font-size: 16px; /* Fixed font size - same as start button */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .category-select-btn:hover {
            background: linear-gradient(45deg, #357ABD, #2C5F8A);
            /* Remove transform animation, keep same position */
        }

        .category-select-btn.active {
            background: linear-gradient(45deg, var(--category-primary, #4A90E2), var(--category-accent, #357ABD));
            border-color: var(--category-accent, #2C5F8A);
        }

        /* Category Dropdown */
        .category-dropdown {
            position: absolute;
            top: calc(50% + 120px); /* Position below the category button */
            left: calc(50% - 150px); /* Match button left position */
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4A90E2, #357ABD); /* Same gradient as button */
            border: none; /* Same as button */
            border-radius: 0; /* Same as button */
            padding: 8px;
            width: 120px; /* Same width as button */
            z-index: 9999;
            display: none;
        }

        .category-dropdown.show {
            display: block;
        }

        .category-dropdown-item {
            padding: 8px;
            background: transparent; /* Transparent background to show dropdown gradient */
            border: none; /* Remove border */
            border-radius: 0; /* Remove rounded corners */
            color: white; /* Same color as button text */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: bold;
            font-size: 16px; /* Same font size as button */
            margin-bottom: 2px;
            height: 36px; /* Fixed height for consistency */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .category-dropdown-item:last-child {
            margin-bottom: 0;
        }

        .category-dropdown-item:hover {
            background: linear-gradient(45deg, #357ABD, #2C5F8A); /* Same hover gradient as button */
        }

        .category-dropdown-item.active {
            background: linear-gradient(45deg, var(--category-primary, #4A90E2), var(--category-accent, #357ABD)); /* Same active gradient as button */
            color: white;
        }

        /* Mobile responsive adjustments for category button */
        @media (max-width: 768px) {
            .category-select-btn {
                left: calc(50% - 120px); /* Adjust spacing for smaller screens */
                width: 100px;
                height: 40px;
                font-size: 14px;
            }

            .start-performance-btn {
                width: 100px;
                height: 40px;
                font-size: 14px;
            }

            .category-dropdown {
                left: calc(50% - 120px);
                width: 100px;
            }

            .category-dropdown-item {
                font-size: 14px;
                height: 32px;
            }
        }

        @media (max-width: 480px) {
            .category-select-btn {
                left: calc(50% - 100px); /* Even closer spacing for mobile */
                width: 80px;
                height: 35px;
                font-size: 12px;
            }

            .start-performance-btn {
                width: 80px;
                height: 35px;
                font-size: 12px;
            }

            .category-dropdown {
                left: calc(50% - 100px);
                width: 80px;
            }

            .category-dropdown-item {
                font-size: 12px;
                height: 28px;
            }
        }

        .song-list {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding: 1rem;
            /* Add generous padding on sides so edge items can be centered comfortably */
            padding-left: calc(50vw - 30px); /* More space: half viewport width minus 30px */
            padding-right: calc(50vw - 30px); /* More space: half viewport width minus 30px */
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            align-items: center;
            /* Better scrolling on mobile */
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scroll-behavior: smooth;
            justify-content: flex-start;
        }

        .song-list::-webkit-scrollbar {
            height: 6px;
        }

        .song-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        .song-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 0;
        }

        .song-item {
            min-width: 100px;
            width: 100px;
            height: 180px; /* Increased from 140px to 180px */
            background: linear-gradient(45deg, #FF006E, #8338EC);
            border: 3px solid #FFFFFF;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        /* Selected song (clicked) */
        .song-item.selected {
            transform: scale(1.1);
            border-color: #FFD700 !important;
            border-width: 4px;
            z-index: 2;
            filter: brightness(1.2) saturate(1.3);
        }

        /* Center-focused song (based on scroll position) */
        .song-item.center-focus {
            transform: scale(1.05);
            border-color: #FFD700 !important;
            border-width: 3px;
            z-index: 1;
            filter: brightness(1.1) saturate(1.1);
        }

        /* Dummy song styling */
        .song-item[data-is-real="false"] {
            opacity: 0.8;
            background: linear-gradient(45deg, #888888, #AAAAAA);
            border-color: #666666;
        }

        .song-item[data-is-real="false"] .song-item-name {
            color: #CCCCCC;
            font-style: italic;
        }

        .song-item[data-is-real="false"].selected {
            background: linear-gradient(45deg, #B8860B, #DAA520);
            border-color: #B8860B;
            opacity: 1;
        }

        .song-item[data-is-real="false"].center-focus {
            background: linear-gradient(45deg, #B8860B, #DAA520);
            border-color: #B8860B;
            opacity: 1;
        }

        .song-item:hover:not(.selected):not(.center-focus) {
            transform: translateY(-3px);
            border-color: #FFD700;
            box-shadow: 0 3px 10px rgba(255, 215, 0, 0.3);
        }

        .song-item.selected:hover {
            transform: scale(1.15);
        }

        .song-item.center-focus:hover {
            transform: scale(1.1);
        }


        .song-item-name {
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 0.75rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            word-break: break-all;
            line-height: 1.2;
        }

        /* Navigation buttons */
        .nav-button {
            min-width: 80px;
            width: 80px;
            height: 180px; /* Updated to match song-item height */
            background: linear-gradient(45deg, #FF6B47, #FF8C00);
            border: 3px solid #CC5238;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            transition: all 0.3s ease;
            flex-shrink: 0;
            position: relative;
        }

        .nav-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 107, 71, 0.4);
            background: linear-gradient(45deg, #FF8C00, #FFA500);
        }

        .nav-button:active {
            transform: scale(0.98);
        }

        .nav-button-content {
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 0.7rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            word-break: break-all;
            line-height: 1.2;
        }

        /* Position navigation buttons at edges */
        .nav-button-left {
            order: -1; /* Appear first */
        }

        .nav-button-right {
            order: 999; /* Appear last */
        }

        /* Mobile optimizations */
        @media (max-width: 767px) {
            .song-list {
                /* More generous padding for mobile */
                padding-left: calc(50vw - 20px); /* More space: half viewport width minus 20px */
                padding-right: calc(50vw - 20px); /* More space: half viewport width minus 20px */
            }

            .song-item {
                min-width: 80px;
                width: 80px;
                height: 160px; /* Increased from 120px to 160px */
                padding: 0.25rem;
            }

            .song-item.selected {
                transform: scale(1.1);
            }

            .song-item.selected:hover {
                transform: scale(1.15);
            }

            .song-item-name {
                font-size: 0.625rem;
            }

            /* Mobile navigation buttons */
            .nav-button {
                min-width: 60px;
                width: 60px;
                height: 160px; /* Updated to match mobile song-item height */
                padding: 0.25rem;
            }

            .nav-button-content {
                font-size: 0.625rem;
            }
        }

        /* Tablet Optimizations */
        @media (min-width: 768px) and (max-width: 1023px) {
            .song-list {
                /* More generous padding for tablet */
                padding-left: calc(50vw - 35px); /* More space: half viewport width minus 35px */
                padding-right: calc(50vw - 35px); /* More space: half viewport width minus 35px */
            }

            .song-item {
                min-width: 110px;
                width: 110px;
                height: 190px; /* Increased from 150px to 190px */
            }

            .song-item-name {
                font-size: 0.8rem;
            }

            /* Tablet navigation buttons */
            .nav-button {
                min-width: 90px;
                width: 90px;
                height: 190px; /* Updated to match tablet song-item height */
            }

            .nav-button-content {
                font-size: 0.75rem;
            }
        }

        /* Large Desktop Optimizations */
        @media (min-width: 1024px) {
            .song-list-container {
                padding: 1.5rem;
            }

            .song-list {
                /* More generous padding for desktop */
                padding-left: calc(50vw - 40px); /* More space: half viewport width minus 40px */
                padding-right: calc(50vw - 40px); /* More space: half viewport width minus 40px */
            }

            .song-item {
                min-width: 120px;
                width: 120px;
                height: 200px; /* Increased from 160px to 200px */
                padding: 0.75rem;
            }

            .song-item-name {
                font-size: 0.875rem;
            }

            /* Desktop navigation buttons */
            .nav-button {
                min-width: 100px;
                width: 100px;
                height: 200px; /* Updated to match desktop song-item height */
                padding: 0.75rem;
            }

            .nav-button-content {
                font-size: 0.8rem;
            }
        }

        /* Main Game Area - Full screen */
        .game-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            overflow: hidden;
            z-index: 5; /* Higher than banner to ensure character visibility */
        }

        /* Beat Track - Horizontal scrolling area */
        .beat-track {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 130px; /* Increased by 10px */
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.8);
            overflow: hidden;
        }

        /* Beat Grid Lines */
        .beat-grid {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 10000px; /* Large width for scrolling */
            pointer-events: none;
            z-index: 1;
        }

        .beat-line {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
        }

        .beat-line.measure {
            background: rgba(255, 215, 0, 0.8);
            width: 3px;
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.5);
        }

        /* Hit Target Zone */
        .hit-target {
            position: absolute;
            left: 150px;
            top: 0;
            bottom: 0;
            width: 4px;
            transform: translateX(-50%); /* Center the line at 150px */
            background: white;
            z-index: 10;
            display: none; /* Hidden by default */
        }

        .hit-target.visible {
            display: block;
        }


        /* Target Drum - Simplified transparent ring */
        .target-drum {
            position: absolute;
            left: 150px; /* Align with hit target line */
            top: 50%;
            transform: translateY(-50%) translateX(-50%);
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            z-index: 5; /* Behind notes but above beat grid */
            transition: all 0.1s ease;
        }

        /* Golden Hit Effects - Target Drum Only */
        .target-drum.golden-hit {
            /* Keep original border color - don't change border */
            background: radial-gradient(circle, rgba(6, 255, 165, 0.6), rgba(255, 190, 11, 0.3));
            box-shadow: 
                0 0 30px rgba(6, 255, 165, 0.8),
                inset 0 0 25px rgba(255, 190, 11, 0.4);
            animation: goldenFillAndFade 0.8s ease-out;
        }

        @keyframes goldenFillAndFade {
            0% {
                transform: translateY(-50%) translateX(-50%) scale(1);
                background: radial-gradient(circle, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.6));
            }
            30% {
                transform: translateY(-50%) translateX(-50%) scale(1.1);
                background: radial-gradient(circle, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.7));
            }
            100% {
                transform: translateY(-50%) translateX(-50%) scale(1);
                background: radial-gradient(circle, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.05));
            }
        }

        /* White Hit Effects for Good hits - Target Drum Only */
        .target-drum.white-hit {
            /* Keep original border color - don't change border */
            background: radial-gradient(circle, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
            box-shadow: 
                0 0 30px rgba(255, 255, 255, 0.8),
                inset 0 0 25px rgba(255, 255, 255, 0.5);
            animation: whiteFillAndFade 0.8s ease-out;
        }

        @keyframes whiteFillAndFade {
            0% {
                transform: translateY(-50%) translateX(-50%) scale(1);
                background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.6));
            }
            30% {
                transform: translateY(-50%) translateX(-50%) scale(1.1);
                background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            }
            100% {
                transform: translateY(-50%) translateX(-50%) scale(1);
                background: radial-gradient(circle, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            }
        }


        /* Beat Notes Container */
        .notes-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 10000px; /* Large width for scrolling */
            z-index: 2;
        }

        /* Individual Beat Notes */
        .beat-note {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%) translateX(-50%);
            border: 3px solid var(--text-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-white);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px var(--drum-shadow);
            transition: transform 0.1s ease;
            z-index: 8; /* Above target drum but below hit target line */
        }

        .beat-note.don {
            background: radial-gradient(circle, var(--don-color), var(--don-accent));
            border: 2px solid var(--vaporwave-white);
        }

        .beat-note.ka {
            background: radial-gradient(circle, var(--ka-color), var(--ka-accent));
            border: 2px solid var(--vaporwave-white);
        }

        .beat-note.hit {
            transform: translateY(-50%) translateX(-50%) scale(1.3);
            box-shadow: 0 0 30px var(--hit-effect);
        }


        /* Drum Kit */
        .drum-kit {
            position: absolute;
            bottom: -150px; /* 调整位置适应更大的鼓 */
            left: 50%;
            transform: translateX(-50%);
            width: 450px; /* 2倍大小：225 * 2 */
            height: 300px; /* 2倍大小：150 * 2 */
            overflow: hidden; /* 隐藏下半部分 */
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 6; /* Above game track but below UI elements */
        }

        .drum-kit.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .drum.unified {
            width: 450px; /* 2倍大小：225 * 2 */
            height: 300px; /* 2倍大小：150 * 2 */
            border-radius: 450px 450px 0 0; /* 2倍大小：225 * 2 */
            border: 10px solid var(--text-white); /* 2倍大小：5 * 2 */
            border-bottom: none; /* 移除底部边框 */
            cursor: pointer;
            position: relative;
            transition: all 0.1s ease;
            background: var(--ka-color); /* 整个鼓面是蒸汽波紫色 - Ka区域 */
        }

        /* Don区域 - 独立的可点击元素 */
        .drum-don {
            position: absolute;
            top: 40%; /* 保持相同的相对位置 */
            left: 50%;
            width: 270px; /* 2倍大小：135 * 2 */
            height: 180px; /* 2倍大小：90 * 2 */
            border-radius: 270px 270px 0 0; /* 2倍大小：135 * 2 */
            background: linear-gradient(45deg, var(--don-color), var(--don-accent));
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            z-index: 3; /* 高于Ka区域 */
            cursor: pointer;
        }

        /* Don击打效果 - Don区域放大 */
        .drum-don.hit {
            transform: translate(-50%, -50%) scale(1.2);
            background: linear-gradient(45deg, var(--don-accent), #FF9BCE);
        }

        /* Ka击打效果 - 外圈变大变色，Don区域保持原大小 */
        .drum.unified.hit-ka {
            transform: scaleX(1.1) scaleY(1.1);
            background: var(--ka-accent);
            box-shadow: 0 0 20px rgba(179, 102, 236, 0.6);
        }

        /* 当Ka变大时，Don区域反向缩放保持原始大小 */
        .drum.unified.hit-ka .drum-don {
            transform: translate(-50%, -50%) scale(0.909); /* 1/1.1 ≈ 0.909 */
        }

        /* Ka区域按下效果 - 变小变色，Don区域保持原大小 */
        .drum.unified:active {
            transform: scaleX(0.98) scaleY(0.98);
            background: #5C2A8E;
        }

        /* 当Ka被按下时，Don区域反向缩放保持原始大小 */
        .drum.unified:active .drum-don {
            transform: translate(-50%, -50%) scale(1.02); /* 1/0.98 ≈ 1.02 */
        }
        
        /* Don区域按下效果 */
        .drum-don:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        /* Don标签 - 显示在内圈中心 */
        .drum-label-don {
            position: absolute;
            top: 40%; /* 调整位置适应半圆 */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px; /* 2倍大小：10 * 2 */
            font-weight: bold;
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* 2倍大小：1px -> 2px */
            z-index: 3;
            pointer-events: none;
        }

        /* Ka标签 - 显示在外圈环形区域 */
        .drum-label-ka {
            position: absolute;
            top: 40px; /* 2倍大小：20 * 2 */
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px; /* 2倍大小：9 * 2 */
            font-weight: bold;
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* 2倍大小：1px -> 2px */
            z-index: 3;
            pointer-events: none;
        }

        /* Hit Effects */
        .hit-effect {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--hit-effect), transparent);
            pointer-events: none;
            animation: hitExplosion 0.3s ease-out forwards;
            z-index: 15; /* Above everything for hit effects */
        }
        
        .hit-effect.ka {
            background: radial-gradient(circle, var(--ka-hit-effect), transparent);
        }

        @keyframes hitExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* Particle Effects */
        .hit-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 16;
        }

        .particle-golden {
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.8);
        }

        .particle-white {
            background: radial-gradient(circle, #FFFFFF, #E0E0E0);
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
        }
        
        /* Chinese Element Particles */
        .particle-chinese {
            width: auto;
            height: auto;
            background: none;
            border-radius: 0;
            box-shadow: none;
        }
        
        .particle-chinese.particle-golden {
            filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.8));
        }
        
        .particle-chinese.particle-white {
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.6));
        }
        
        .particle-lotus-petal {
            animation: petalFloat 2s ease-out forwards;
        }
        
        .particle-cloud-wisp {
            animation: cloudDrift 2.5s ease-out forwards;
        }
        
        .particle-bamboo-leaf {
            animation: leafFall 2.2s ease-out forwards;
        }
        
        /* Chinese particle animations */
        @keyframes petalFloat {
            0% {
                transform: scale(0.5) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
        
        @keyframes cloudDrift {
            0% {
                transform: scale(0.3) translateY(0px);
                opacity: 1;
            }
            70% {
                transform: scale(1.2) translateY(-20px);
                opacity: 0.4;
            }
            100% {
                transform: scale(1.8) translateY(-40px);
                opacity: 0;
            }
        }
        
        @keyframes leafFall {
            0% {
                transform: scale(0.8) rotate(-10deg) translateY(0px);
                opacity: 1;
            }
            30% {
                transform: scale(1) rotate(15deg) translateY(10px);
                opacity: 0.9;
            }
            70% {
                transform: scale(1.1) rotate(-25deg) translateY(30px);
                opacity: 0.5;
            }
            100% {
                transform: scale(1.3) rotate(45deg) translateY(50px);
                opacity: 0;
            }
        }

        /* Judgment Text */
        .judgment {
            position: absolute;
            top: calc(30% - 80px); /* Position above the game track container */
            left: 150px;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            animation: judgmentFade 1s ease-out forwards;
            z-index: 12; /* Above target drum and notes */
            text-align: center;
        }

        .judgment.perfect {
            color: #FFD700;
        }

        .judgment.good {
            color: white;
        }

        .judgment.miss {
            color: #CCCCCC;
        }

        @keyframes judgmentFade {
            0% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px);
            }
        }

        /* Song Selector - Floating in top left */
        .song-selector {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border: 3px solid var(--primary-blue);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 20;
            display: none;
        }

        .song-selector.show {
            display: block;
        }

        .song-selector select {
            padding: 8px 12px;
            border: 2px solid var(--primary-red);
            background: white;
            font-weight: bold;
            color: var(--text-dark);
            margin-right: 10px;
            min-width: 200px;
        }

        .song-selector button {
            padding: 8px 16px;
            background: var(--primary-red);
            border: none;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .song-selector button:hover {
            background: #CC5238;
        }

        /* Pause Menu - Enter key popup */
        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .pause-menu.show {
            display: flex;
        }

        .pause-menu-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            padding: 40px;
            border: 4px solid var(--primary-blue);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 300px;
        }

        .pause-menu-content h2 {
            font-size: 32px;
            color: var(--primary-blue);
            margin-bottom: 30px;
        }

        .pause-menu-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 15px 20px;
            font-size: 18px;
            font-weight: bold;
            border: 3px solid var(--primary-blue);
            background: rgba(255, 255, 255, 0.9);
            color: var(--primary-blue);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pause-menu-btn:hover, .pause-menu-btn.selected {
            background: var(--primary-blue);
            color: white;
        }

        /* Pause Menu Settings */
        .pause-menu-settings {
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid var(--primary-blue);
            border-radius: 0;
            padding: 20px;
            margin-bottom: 20px;
        }

        .pause-menu-settings h3 {
            font-size: 20px;
            color: var(--primary-blue);
            margin-bottom: 15px;
            margin-top: 0;
        }

        .setting-item {
            margin-bottom: 10px;
        }

        .setting-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.8);
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 0;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .setting-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: var(--primary-blue);
            transform: scale(1.02);
        }

        .setting-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 0;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .setting-checkbox.checked {
            background: var(--primary-blue);
            color: white;
        }

        .setting-checkbox::after {
            content: '✓';
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .setting-checkbox.checked::after {
            opacity: 1;
        }

        /* Loading Screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-gradient);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--primary-red);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Curtain Transition Effect - Dark Mysterious Girl Style */
        .curtain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #2D1B2D 0%, #3D2A3D 50%, #2D1B2D 100%);
            z-index: 10000;
            display: none;
            overflow: hidden;
        }

        .curtain.active {
            display: block;
        }

        /* Left curtain panel */
        .curtain-left {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(135deg, #2D1B2D 0%, #4A2D4A 50%, #3D2A3D 100%);
            transform: translateX(-100%);
            transition: transform 0.8s ease-in-out;
            border-right: 3px solid #8B4B8B;
            box-shadow: 
                2px 0 15px rgba(139, 75, 139, 0.4),
                inset -5px 0 20px rgba(75, 45, 75, 0.3);
        }

        /* Right curtain panel */
        .curtain-right {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(135deg, #2D1B2D 0%, #3D2B4A 50%, #3D2A3D 100%);
            transform: translateX(100%);
            transition: transform 0.8s ease-in-out;
            border-left: 3px solid #6B4B8B;
            box-shadow: 
                -2px 0 15px rgba(107, 75, 139, 0.4),
                inset 5px 0 20px rgba(61, 43, 74, 0.3);
        }

        /* Curtain closing animation */
        .curtain.closing .curtain-left {
            transform: translateX(0);
        }

        .curtain.closing .curtain-right {
            transform: translateX(0);
        }

        /* Curtain opening animation */
        .curtain.opening .curtain-left {
            transform: translateX(-100%);
        }

        .curtain.opening .curtain-right {
            transform: translateX(100%);
        }

        /* Curtain loading content - Dark Mysterious Girl Style */
        .curtain-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #D8B3D8;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .curtain.closing .curtain-content {
            opacity: 1;
            transition-delay: 0.4s;
            animation: mysteriousGlow 2s ease-in-out infinite alternate;
        }

        @keyframes mysteriousGlow {
            0% {
                filter: drop-shadow(0 0 10px rgba(216, 179, 216, 0.3));
            }
            100% {
                filter: drop-shadow(0 0 20px rgba(216, 179, 216, 0.6));
            }
        }

        .curtain-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(139, 75, 139, 0.2);
            border-top: 3px solid #B366B3;
            border-right: 3px solid #8B4B8B;
            border-radius: 50%;
            animation: mysterySpin 1.5s ease-in-out infinite;
            margin: 0 auto 20px;
            box-shadow: 0 0 15px rgba(179, 102, 179, 0.3);
        }

        @keyframes mysterySpin {
            0% {
                transform: rotate(0deg);
                box-shadow: 0 0 15px rgba(179, 102, 179, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(139, 75, 139, 0.5);
            }
            100% {
                transform: rotate(360deg);
                box-shadow: 0 0 15px rgba(179, 102, 179, 0.3);
            }
        }

        .curtain-text {
            font-size: 16px;
            font-weight: bold;
            color: #D8B3D8;
            text-shadow: 
                0 0 10px rgba(216, 179, 216, 0.8),
                2px 2px 4px rgba(61, 42, 61, 0.8);
        }

        /* Game Over Screen */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--text-white);
        }

        .game-over h2 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #FFD700;
        }

        .final-stats {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary-red);
        }

        .stat-label {
            font-size: 16px;
            margin-top: 5px;
        }

        /* Hit Statistics Section */
        .hit-stats {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .hit-stat-item {
            text-align: center;
            padding: 20px;
            border-radius: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            min-width: 120px;
        }

        .hit-stat-item.perfect {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .hit-stat-item.good {
            border-color: #FFFFFF;
            background: rgba(255, 255, 255, 0.1);
        }

        .hit-stat-item.miss {
            border-color: #CCCCCC;
            background: rgba(204, 204, 204, 0.1);
        }

        .hit-stat-count {
            font-size: 28px;
            font-weight: bold;
            color: var(--text-white);
            margin-bottom: 5px;
        }

        .hit-stat-label {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .hit-stat-item.perfect .hit-stat-label {
            color: #FFD700;
        }

        .hit-stat-item.good .hit-stat-label {
            color: #FFFFFF;
        }

        .hit-stat-item.miss .hit-stat-label {
            color: #CCCCCC;
        }

        .hit-stat-score {
            font-size: 14px;
            color: var(--text-white);
            opacity: 0.8;
        }

        /* Game Over Action Buttons */
        .game-over-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .action-btn {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s ease;
            border-radius: 0;
        }

        .restart-btn {
            background: var(--primary-red);
            color: var(--text-white);
        }

        .restart-btn:hover {
            background: #CC5238;
        }

        .back-btn {
            background: var(--primary-blue);
            color: var(--text-white);
        }

        .back-btn:hover {
            background: #3A72B8;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .top-section {
                padding: 15px 20px;
                height: 100px;
            }

            .score-value {
                font-size: 24px;
            }

            .combo-display {
                font-size: 28px;
            }

            .drum {
                width: 100px;
                height: 100px;
            }

            .beat-note {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .judgment {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Mondrian Grid Background -->
        <svg class="mondrian-grid" viewBox="0 0 1920 1080">
            <!-- Main grid lines -->
            <line x1="400" y1="0" x2="400" y2="1080" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="800" y1="0" x2="800" y2="1080" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            <line x1="1200" y1="0" x2="1200" y2="1080" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="0" y1="200" x2="1920" y2="200" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            <line x1="0" y1="500" x2="1920" y2="500" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="0" y1="800" x2="1920" y2="800" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            
            <!-- Vaporwave color blocks -->
            <rect x="0" y="0" width="400" height="200" fill="#FF006E" opacity="0.15"/>
            <rect x="400" y="0" width="400" height="200" fill="#8338EC" opacity="0.15"/>
            <rect x="800" y="0" width="400" height="200" fill="#3A86FF" opacity="0.15"/>
            <rect x="1200" y="0" width="720" height="200" fill="#06FFA5" opacity="0.15"/>
            
            <rect x="0" y="200" width="400" height="300" fill="#FFBE0B" opacity="0.15"/>
            <rect x="400" y="200" width="800" height="300" fill="#FF006E" opacity="0.1"/>
            <rect x="1200" y="200" width="720" height="300" fill="#8338EC" opacity="0.15"/>
            
            <rect x="0" y="500" width="800" height="300" fill="#3A86FF" opacity="0.15"/>
            <rect x="800" y="500" width="400" height="300" fill="#06FFA5" opacity="0.15"/>
            <rect x="1200" y="500" width="720" height="300" fill="#FFBE0B" opacity="0.15"/>
            
            <rect x="0" y="800" width="400" height="280" fill="#8338EC" opacity="0.15"/>
            <rect x="400" y="800" width="400" height="280" fill="#FF006E" opacity="0.15"/>
            <rect x="800" y="800" width="400" height="280" fill="#3A86FF" opacity="0.15"/>
            <rect x="1200" y="800" width="720" height="280" fill="#06FFA5" opacity="0.15"/>
        </svg>
        
        <!-- Chinese Elements Background -->
        <svg class="chinese-elements" viewBox="0 0 1920 1080">
            <!-- Auspicious Clouds (祥云) - Floating foreground elements -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.4">
                <!-- Traditional Chinese cloud patterns -->
                <g transform="translate(500,150)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 15,15 Q 25,5 35,15 Q 45,5 55,15 Q 65,10 75,20 Q 70,25 60,25 Q 50,30 40,25 Q 30,30 20,25 Q 10,25 15,15 Z" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <g transform="translate(1200,180) scale(0.8)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 15,15 Q 25,5 35,15 Q 45,5 55,15 Q 65,10 75,20 Q 70,25 60,25 Q 50,30 40,25 Q 30,30 20,25 Q 10,25 15,15 Z" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Bottom clouds -->
                <g transform="translate(300,900) scale(1.2)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.08"/>
                </g>
                
                <g transform="translate(1400,880) scale(0.9)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.08"/>
                </g>
            </g>
            
            <!-- Traditional Chinese Decorative Elements -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.3">
                <!-- Chinese Knot (中国结) patterns in corners -->
                <g transform="translate(100,100)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(1820,100) rotate(90)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(100,980) rotate(270)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(1820,980) rotate(180)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
            </g>
            
            <!-- Mountain silhouettes with varying heights -->
            <g fill="#FFFFFF" opacity="0.15">
                <polygon points="50,1080 150,900 250,1080"/>
                <polygon points="200,1080 320,850 440,1080"/>
                <polygon points="1480,1080 1600,920 1720,1080"/>
                <polygon points="1670,1080 1770,880 1870,1080"/>
                <!-- Layered mountains for depth -->
                <polygon points="100,1080 200,950 300,1080" opacity="0.8"/>
                <polygon points="1520,1080 1650,940 1780,1080" opacity="0.8"/>
                <!-- Distant mountains -->
                <polygon points="600,1080 700,980 800,1080" opacity="0.6"/>
                <polygon points="1000,1080 1100,970 1200,1080" opacity="0.6"/>
            </g>
            
            <!-- Chinese Musical Instruments -->
            <g fill="none" stroke="#FFFFFF" stroke-width="3" opacity="0.9">
                <!-- Ancient Guqin (古琴) - traditional Chinese zither -->
                <g class="floating-instrument" style="animation: floatGuqin 12s ease-in-out infinite;">
                    <animateTransform attributeName="transform" type="translate" values="300,200; 325,180; 280,220; 305,190; 300,200" dur="12s" repeatCount="indefinite"/>
                    <rect x="0" y="0" width="120" height="15" rx="7" fill="#FFFFFF" opacity="0.3"/>
                    <line x1="10" y1="0" x2="10" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="30" y1="0" x2="30" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="50" y1="0" x2="50" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="70" y1="0" x2="70" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="90" y1="0" x2="90" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="110" y1="0" x2="110" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Bamboo Flute (竹笛) -->
                <g class="floating-instrument">
                    <animateTransform attributeName="transform" type="translate" values="1400,300; 1430,275; 1370,325; 1415,285; 1400,300" dur="10s" repeatCount="indefinite"/>
                    <animateTransform attributeName="transform" type="rotate" values="15; 35; -5; 25; 15" dur="8s" repeatCount="indefinite" additive="sum"/>
                    <rect x="0" y="0" width="80" height="6" rx="3" fill="#FFFFFF" opacity="0.3"/>
                    <circle cx="15" cy="3" r="2" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="25" cy="3" r="1.5" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="35" cy="3" r="1.5" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="45" cy="3" r="1.5" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="55" cy="3" r="1.5" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="65" cy="3" r="1.5" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Ancient Bells (编钟) -->
                <g class="floating-instrument">
                    <animateTransform attributeName="transform" type="translate" values="400,800; 375,780; 425,820; 390,790; 400,800" dur="14s" repeatCount="indefinite"/>
                    <path d="M 0,20 Q 0,5 10,5 Q 20,5 20,20 L 18,40 L 2,40 Z" fill="#FFFFFF" opacity="0.3"/>
                    <path d="M 25,15 Q 25,2 35,2 Q 45,2 45,15 L 43,35 L 27,35 Z" fill="#FFFFFF" opacity="0.3"/>
                    <path d="M 50,25 Q 50,8 60,8 Q 70,8 70,25 L 68,45 L 52,45 Z" fill="#FFFFFF" opacity="0.3"/>
                    <line x1="10" y1="0" x2="10" y2="5" stroke="#FFFFFF"/>
                    <line x1="35" y1="0" x2="35" y2="2" stroke="#FFFFFF"/>
                    <line x1="60" y1="0" x2="60" y2="8" stroke="#FFFFFF"/>
                </g>
                
                <!-- Pipa (琵琶) - Chinese lute -->
                <g class="floating-instrument">
                    <animateTransform attributeName="transform" type="translate" values="1300,750; 1330,720; 1270,770; 1310,740; 1300,750" dur="11s" repeatCount="indefinite"/>
                    <animateTransform attributeName="transform" type="rotate" values="0; 8; -8; 5; 0" dur="15s" repeatCount="indefinite" additive="sum"/>
                    <ellipse cx="15" cy="40" rx="15" ry="25" fill="#FFFFFF" opacity="0.3"/>
                    <rect x="10" y="0" width="10" height="25" rx="5" fill="#FFFFFF" opacity="0.3"/>
                    <line x1="8" y1="5" x2="22" y2="5" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="8" y1="10" x2="22" y2="10" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="8" y1="15" x2="22" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="8" y1="20" x2="22" y2="20" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Erhu (二胡) - Traditional fiddle -->
                <g class="floating-instrument">
                    <animateTransform attributeName="transform" type="translate" values="800,300; 825,275; 775,325; 810,285; 800,300" dur="9s" repeatCount="indefinite"/>
                    <animateTransform attributeName="transform" type="rotate" values="0; -10; 10; -5; 0" dur="12s" repeatCount="indefinite" additive="sum"/>
                    <rect x="0" y="0" width="4" height="60" fill="#FFFFFF" opacity="0.3"/>
                    <circle cx="2" cy="0" r="8" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="2" cy="0" r="12" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="-6" y1="10" x2="10" y2="10" stroke="#FFFFFF" stroke-width="1"/>
                    <line x1="-6" y1="15" x2="10" y2="15" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Traditional Gong (锣) -->
                <g class="floating-instrument">
                    <animateTransform attributeName="transform" type="translate" values="1500,600; 1470,580; 1530,620; 1485,590; 1500,600" dur="13s" repeatCount="indefinite"/>
                    <animateTransform attributeName="transform" type="rotate" values="0; 15; -15; 8; 0" dur="7s" repeatCount="indefinite" additive="sum"/>
                    <circle cx="0" cy="0" r="25" fill="none" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="15" fill="none" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="8" fill="#FFFFFF" opacity="0.3"/>
                    <line x1="-30" y1="-30" x2="-20" y2="-20" stroke="#FFFFFF" stroke-width="3"/>
                    <line x1="-35" y1="-25" x2="-25" y2="-15" stroke="#FFFFFF" stroke-width="2"/>
                </g>
            </g>
            
            <!-- Bamboo Grove (竹林) -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.2">
                <g transform="translate(80,600)">
                    <line x1="0" y1="0" x2="0" y2="480" stroke="#FFFFFF" stroke-width="3"/>
                    <line x1="15" y1="50" x2="15" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="30" y1="30" x2="30" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="45" y1="70" x2="45" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <!-- Bamboo segments -->
                    <line x1="-3" y1="100" x2="3" y2="100" stroke="#FFFFFF"/>
                    <line x1="-3" y1="200" x2="3" y2="200" stroke="#FFFFFF"/>
                    <line x1="-3" y1="300" x2="3" y2="300" stroke="#FFFFFF"/>
                    <line x1="-3" y1="400" x2="3" y2="400" stroke="#FFFFFF"/>
                    <!-- Bamboo leaves -->
                    <path d="M 5,150 Q 15,145 20,155 Q 15,165 5,160" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 35,250 Q 45,245 50,255 Q 45,265 35,260" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 20,350 Q 30,345 35,355 Q 30,365 20,360" fill="#FFFFFF" opacity="0.1"/>
                </g>
                
                <g transform="translate(1800,500)">
                    <line x1="0" y1="0" x2="0" y2="580" stroke="#FFFFFF" stroke-width="3"/>
                    <line x1="-15" y1="80" x2="-15" y2="580" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="-30" y1="60" x2="-30" y2="580" stroke="#FFFFFF" stroke-width="2"/>
                    <!-- Bamboo segments -->
                    <line x1="-3" y1="150" x2="3" y2="150" stroke="#FFFFFF"/>
                    <line x1="-3" y1="280" x2="3" y2="280" stroke="#FFFFFF"/>
                    <line x1="-3" y1="410" x2="3" y2="410" stroke="#FFFFFF"/>
                    <!-- Bamboo leaves -->
                    <path d="M -35,200 Q -25,195 -20,205 Q -25,215 -35,210" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M -18,330 Q -8,325 -3,335 Q -8,345 -18,340" fill="#FFFFFF" opacity="0.1"/>
                </g>
            </g>
            
            <!-- Flowing Water (流水) -->
            <g fill="none" stroke="#FFFFFF" stroke-width="1.5" opacity="0.2">
                <path d="M 200,900 Q 300,880 400,900 Q 500,920 600,900" stroke="#FFFFFF" stroke-width="2"/>
                <path d="M 210,910 Q 310,890 410,910 Q 510,930 610,910" stroke="#FFFFFF" stroke-width="1.5"/>
                <path d="M 220,920 Q 320,900 420,920 Q 520,940 620,920" stroke="#FFFFFF" stroke-width="1"/>
                
                <path d="M 1300,950 Q 1400,930 1500,950 Q 1600,970 1700,950" stroke="#FFFFFF" stroke-width="2"/>
                <path d="M 1310,960 Q 1410,940 1510,960 Q 1610,980 1710,960" stroke="#FFFFFF" stroke-width="1.5"/>
                
                <!-- Additional water streams through mountains -->
                <path d="M 700,1000 Q 800,980 900,1000 Q 1000,1020 1100,1000" stroke="#FFFFFF" stroke-width="1.5" opacity="0.15"/>
                <path d="M 710,1010 Q 810,990 910,1010 Q 1010,1030 1110,1010" stroke="#FFFFFF" stroke-width="1" opacity="0.15"/>
            </g>
            
            <!-- Lotus Patterns (荷花) - For future hit effects -->
            <g fill="none" stroke="#FFFFFF" stroke-width="1" opacity="0.3">
                <g transform="translate(960,300) scale(0.5)">
                    <path d="M 0,20 Q -10,10 -15,0 Q -10,-10 0,-15 Q 10,-10 15,0 Q 10,10 0,20 Z" fill="#FFFFFF" opacity="0.05"/>
                    <path d="M 0,15 Q -8,5 -12,-5 Q -5,-12 0,-10 Q 5,-12 12,-5 Q 8,5 0,15 Z" fill="#FFFFFF" opacity="0.05"/>
                    <circle cx="0" cy="0" r="3" fill="#FFFFFF" opacity="0.1"/>
                </g>
                
                <g transform="translate(960,780) scale(0.4)">
                    <path d="M 0,20 Q -10,10 -15,0 Q -10,-10 0,-15 Q 10,-10 15,0 Q 10,10 0,20 Z" fill="#FFFFFF" opacity="0.05"/>
                    <path d="M 0,15 Q -8,5 -12,-5 Q -5,-12 0,-10 Q 5,-12 12,-5 Q 8,5 0,15 Z" fill="#FFFFFF" opacity="0.05"/>
                    <circle cx="0" cy="0" r="3" fill="#FFFFFF" opacity="0.1"/>
                </g>
            </g>
            
            <!-- Geometric circles -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.25">
                <circle cx="1700" cy="250" r="30"/>
                <circle cx="220" cy="850" r="25"/>
                <circle cx="1750" cy="700" r="35"/>
                <circle cx="170" cy="300" r="20"/>
            </g>
        </svg>

        <!-- Loading Screen -->
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">加载游戏中...</div>
        </div>

        <!-- Curtain Transition Effect -->
        <div class="curtain" id="curtain">
            <div class="curtain-left"></div>
            <div class="curtain-right"></div>
            <div class="curtain-content">
                <div class="curtain-spinner"></div>
                <div class="curtain-text" id="curtainText">准备演奏...</div>
            </div>
        </div>

        <!-- Song Selector (Floating) -->
        <div class="song-selector" id="songSelector">
            <select id="projectSelect">
                <option value="">-- 选择歌曲 --</option>
            </select>
            <button id="loadGameBtn">载入</button>
        </div>

        <!-- Score Display -->
        <div class="score-bar" id="scoreBar">得分: 0</div>

        <!-- Spirit System -->
        <div class="spirit-system" id="spiritSystem">
            <div class="spirit-lines" id="spiritLines">
                <!-- 40 spirit lines for denser DDR-style display (2.5% per line) -->
                <div class="spirit-line" data-threshold="2.5"></div>
                <div class="spirit-line" data-threshold="5"></div>
                <div class="spirit-line" data-threshold="7.5"></div>
                <div class="spirit-line" data-threshold="10"></div>
                <div class="spirit-line" data-threshold="12.5"></div>
                <div class="spirit-line" data-threshold="15"></div>
                <div class="spirit-line" data-threshold="17.5"></div>
                <div class="spirit-line" data-threshold="20"></div>
                <div class="spirit-line" data-threshold="22.5"></div>
                <div class="spirit-line" data-threshold="25"></div>
                <div class="spirit-line" data-threshold="27.5"></div>
                <div class="spirit-line" data-threshold="30"></div>
                <div class="spirit-line" data-threshold="32.5"></div>
                <div class="spirit-line" data-threshold="35"></div>
                <div class="spirit-line" data-threshold="37.5"></div>
                <div class="spirit-line" data-threshold="40"></div>
                <div class="spirit-line" data-threshold="42.5"></div>
                <div class="spirit-line" data-threshold="45"></div>
                <div class="spirit-line" data-threshold="47.5"></div>
                <div class="spirit-line" data-threshold="50"></div>
                <div class="spirit-line" data-threshold="52.5"></div>
                <div class="spirit-line" data-threshold="55"></div>
                <div class="spirit-line" data-threshold="57.5"></div>
                <div class="spirit-line" data-threshold="60"></div>
                <div class="spirit-line" data-threshold="62.5"></div>
                <div class="spirit-line" data-threshold="65"></div>
                <div class="spirit-line" data-threshold="67.5"></div>
                <div class="spirit-line" data-threshold="70"></div>
                <div class="spirit-line" data-threshold="72.5"></div>
                <div class="spirit-line" data-threshold="75"></div>
                <div class="spirit-line" data-threshold="77.5"></div>
                <div class="spirit-line" data-threshold="80"></div>
                <div class="spirit-line" data-threshold="82.5"></div>
                <div class="spirit-line" data-threshold="85"></div>
                <div class="spirit-line" data-threshold="87.5"></div>
                <div class="spirit-line" data-threshold="90"></div>
                <div class="spirit-line" data-threshold="92.5"></div>
                <div class="spirit-line" data-threshold="95"></div>
                <div class="spirit-line" data-threshold="97.5"></div>
                <div class="spirit-line" data-threshold="100"></div>
            </div>
            <div class="spirit-label" id="spiritLabel">灵: 0%</div>
        </div>

        <!-- Pause Menu (Enter key popup) -->
        <div class="pause-menu" id="pauseMenu">
            <div class="pause-menu-content">
                <h2>游戏菜单</h2>
                
                <!-- Settings Section -->
                <div class="pause-menu-settings">
                    <h3>游戏设置</h3>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseTouchDrumToggle">
                            <div class="setting-checkbox" id="pauseTouchDrumCheckbox"></div>
                            <span>显示触控鼓</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseHitTargetToggle">
                            <div class="setting-checkbox" id="pauseHitTargetCheckbox"></div>
                            <span>显示命中线</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseBannerToggle">
                            <div class="setting-checkbox" id="pauseBannerCheckbox"></div>
                            <span>显示顶部横幅</span>
                        </div>
                    </div>
                </div>
                
                <button class="pause-menu-btn" id="pauseBtn">继续</button>
                <button class="pause-menu-btn" id="restartBtn">重新开始</button>
                <button class="pause-menu-btn" id="selectSongBtn">选择歌曲</button>
                <button class="pause-menu-btn" id="exitBtn">退出</button>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-area">
            <!-- Song Name Display -->
            <div class="song-name" id="songName">待加载</div>
            
            <!-- Background Image Container -->
            <div class="game-background" id="gameBackground"></div>
            
            <!-- Top Banner (Above background) -->
            <div class="top-banner" id="topBanner"></div>
            
            <!-- Character Display (Above game track) -->
            <div class="character-display" id="characterDisplay">
                <img id="characterImage" alt="Character" src="cute-chinese-drum.svg" />
            </div>
            
            <!-- Game Track Container (Don + Beat Track) -->
            <div class="game-track-container">
                <!-- Don Character Display (Left of beat track) -->
                <div class="don-display">
                    <div class="don-face" id="donFace">
                        <div class="don-combo" id="donCombo">0</div>
                    </div>
                </div>

                <!-- Beat Track -->
                <div class="beat-track">
                    <div class="beat-grid" id="beatGrid">
                        <!-- Beat grid lines will be generated here -->
                    </div>
                    <div class="hit-target"></div>
                    <!-- Target Drum -->
                    <div class="target-drum"></div>
                    <div class="notes-container" id="notesContainer">
                        <!-- Beat notes will be generated here -->
                    </div>
                </div>
            </div>


            <!-- Drum Kit -->
            <div class="drum-kit" id="drumKit">
                <div class="drum unified" id="unifiedDrum">
                    <!-- Don区域 - 独立元素 -->
                    <div class="drum-don" id="drumDon">
                        <div class="drum-label-don">咚<br>空格</div>
                    </div>
                    <div class="drum-label-ka">咔<br>字母</div>
                </div>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div class="game-over" id="gameOverScreen" style="display: none;">
            <h2>游戏结束！</h2>
            <div class="final-stats">
                <div class="stat-item">
                    <div class="stat-value" id="finalScore">0</div>
                    <div class="stat-label">最终得分</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="maxCombo">0</div>
                    <div class="stat-label">最大连击</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalAccuracy">0%</div>
                    <div class="stat-label">准确率</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalSpirit">0%</div>
                    <div class="stat-label">最终灵魂值</div>
                </div>
            </div>
            
            <!-- Detailed Hit Statistics -->
            <div class="hit-stats">
                <div class="hit-stat-item perfect">
                    <div class="hit-stat-count" id="finalPerfectHits">0</div>
                    <div class="hit-stat-label">优</div>
                    <div class="hit-stat-score" id="perfectScore">0分</div>
                </div>
                <div class="hit-stat-item good">
                    <div class="hit-stat-count" id="finalGoodHits">0</div>
                    <div class="hit-stat-label">良</div>
                    <div class="hit-stat-score" id="goodScore">0分</div>
                </div>
                <div class="hit-stat-item miss">
                    <div class="hit-stat-count" id="finalMissedHits">0</div>
                    <div class="hit-stat-label">不可</div>
                    <div class="hit-stat-score" id="missScore">0分</div>
                </div>
            </div>
            
            <!-- Action buttons -->
            <div class="game-over-actions">
                <button class="action-btn restart-btn" id="playAgainBtn">再来一遍</button>
                <button class="action-btn back-btn" id="backToSelectionBtn">返回选曲</button>
            </div>
        </div>
    </div>

    <!-- Song Selection Screen -->
    <div class="song-selection-screen" id="songSelectionScreen" style="display: none;">
        <!-- Main Content Area -->
        <div class="selection-main">
            <!-- Character Display -->
            <div class="character-panel">
                <div class="character-avatar">
                    <img src="cute-chinese-drum.svg" alt="Character" id="selectionCharacter" />
                </div>
                <div class="difficulty-info">
                    <div class="difficulty-label">蒙德里安大鼓</div>
                </div>
            </div>

            <!-- Song Info -->
            <div class="song-info-panel">
                <div class="song-info-frame" id="songInfoFrame">
                    <div class="song-icon">
                        <div class="song-symbol">♪</div>
                    </div>
                    <div class="selected-song-name" id="selectedSongName">请选择歌曲</div>
                    <div class="song-genre" id="songGenre">J-POP</div>
                </div>
            </div>

            <!-- Stats Panel -->
            <div class="stats-panel">
                <div class="stats-title">最佳成绩</div>
                <div class="stat-row">
                    <span class="stat-label">最佳成绩</span>
                    <span class="stat-value">0点</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">音符敲打率</span>
                    <span class="stat-value">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">优</span>
                    <span class="stat-value">0回</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">良</span>
                    <span class="stat-value">0回</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">不可</span>
                    <span class="stat-value">0回</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">最多连段数</span>
                    <span class="stat-value">0回</span>
                </div>
            </div>

            <!-- Category Selection Button -->
            <div class="category-select-btn" id="categorySelectBtn">
                全部
            </div>

            <!-- Category Dropdown -->
            <div class="category-dropdown" id="categoryDropdown">
                <div class="category-dropdown-item active" data-category="All">全部</div>
                <div class="category-dropdown-item" data-category="Pop">Pop</div>
                <div class="category-dropdown-item" data-category="Trance">Trance</div>
                <div class="category-dropdown-item" data-category="Brutal">Brutal</div>
                <div class="category-dropdown-item" data-category="Softcore">Softcore</div>
            </div>

            <!-- Floating Start Performance Button -->
            <div class="start-performance-btn" id="startPerformanceBtn">
                开始演奏
            </div>
        </div>


        <!-- Song List -->
        <div class="song-list-container">
            <div class="song-list" id="songList">
                <!-- Songs will be populated here dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            score: 0,
            combo: 0,
            maxCombo: 0,
            totalNotes: 0,
            hitNotes: 0,
            perfectHits: 0,
            goodHits: 0,
            missedHits: 0,
            perfectScore: 0,   // Score from perfect hits
            goodScore: 0,      // Score from good hits
            comboScore: 0,     // Score from combo bonuses
            isPlaying: false,
            isPaused: false,
            currentProject: null,
            notes: [],
            currentTime: 0,
            duration: 0,
            audio: null,
            startTime: null,
            animationId: null,
            audioOffset: 0.0,  // BPM detection offset for alignment
            spiritValue: 0,    // Spirit value (0-100%)
            spiritCombo: 0,    // Current combo for spirit calculation
            maxSpiritCombo: 0, // Maximum spirit combo achieved
            challengeFailed: false, // Whether challenge failed
            currentProjectName: null, // Current project name for reloading images
            selectedProject: null, // Selected project in song selection screen
            selectedCategory: 'All', // Selected category for filtering
            categoryColors: null // Category color configuration
        };

        // Particle system
        let particles = [];

        // Spirit System Functions
        function updateSpiritValue(hitType) {
            if (hitType === 'miss') {
                // Miss reduces spirit value (1.5x original)
                gameState.spiritValue = Math.max(0, gameState.spiritValue - 7.5);
                gameState.spiritCombo = 0;
            } else {
                // Successful hit increases spirit combo
                gameState.spiritCombo++;
                gameState.maxSpiritCombo = Math.max(gameState.maxSpiritCombo, gameState.spiritCombo);
                
                // Calculate spirit gain based on hit type and combo
                let spiritGain;
                
                if (hitType === 'perfect') {
                    // Perfect hit: ~1.67% base + combo bonus
                    spiritGain = 1.67;
                } else {
                    // Good hit: ~1.33% base + combo bonus  
                    spiritGain = 1.33;
                }
                
                // Combo bonus: more combo = faster spirit gain
                if (gameState.spiritCombo >= 10) {
                    spiritGain += Math.floor(gameState.spiritCombo / 15); // Reduced combo bonus
                }
                
                // Backend value can exceed 85%, but frontend display caps at 85%
                gameState.spiritValue += spiritGain;
            }
            
            updateSpiritDisplay();
            updateCharacterDisplay(); // Update character based on spirit value
            updateBannerDisplay(); // Update banner based on spirit value
            checkChallengeStatus();
        }

        function updateSpiritDisplay() {
            // Update spirit label with actual value
            spiritElements.label.textContent = `灵: ${Math.round(gameState.spiritValue)}%`;
            
            // Reset all lines to inactive state
            spiritElements.lines.forEach(line => {
                line.className = 'spirit-line';
            });
            
            // Check if we're in rainbow mode (85%+)
            const isRainbowMode = gameState.spiritValue >= 85;
            
            // Add or remove rainbow mode class from container
            if (isRainbowMode) {
                spiritElements.system.classList.add('rainbow-mode');
            } else {
                spiritElements.system.classList.remove('rainbow-mode');
            }
            
            // Activate lines based on spirit value
            spiritElements.lines.forEach(line => {
                const threshold = parseFloat(line.dataset.threshold);
                if (gameState.spiritValue >= threshold) {
                    if (isRainbowMode) {
                        // 85%+: All active lines become thick rainbow lines
                        line.classList.add('active-rainbow');
                    } else if (threshold < 60) {
                        // Below 60%: Yellow thin lines
                        line.classList.add('active-yellow');
                    } else {
                        // 60-84%: Orange thin lines
                        line.classList.add('active-orange');
                    }
                }
            });
        }

        function checkChallengeStatus() {
            // Check if challenge failed (spirit below 60% at song end)
            if (gameState.currentTime >= gameState.duration - 1) {
                if (gameState.spiritValue < 60 && !gameState.challengeFailed) {
                    gameState.challengeFailed = true;
                    showChallengeFailed();
                }
            }
        }

        function showChallengeFailed() {
            // Create challenge failed message
            const judgment = document.createElement('div');
            judgment.className = 'judgment miss';
            judgment.textContent = '挑战失败';
            judgment.style.fontSize = '24px';
            judgment.style.color = '#FF6B6B';
            
            document.querySelector('.game-area').appendChild(judgment);
            
            // Remove after delay
            setTimeout(() => {
                if (judgment.parentNode) {
                    judgment.remove();
                }
            }, 3000);
        }

        function resetSpiritSystem() {
            gameState.spiritValue = 0;
            gameState.spiritCombo = 0;
            gameState.maxSpiritCombo = 0;
            gameState.challengeFailed = false;
            
            // Reset visual display - all lines to inactive
            spiritElements.lines.forEach(line => {
                line.className = 'spirit-line';
            });
            spiritElements.label.textContent = '灵: 0%';
            spiritElements.system.classList.remove('rainbow-mode');
            
            // Update character and banner to unsatisfied state
            updateCharacterDisplay();
            updateBannerDisplay();
        }

        // Game settings
        const settings = {
            scrollSpeed: 300, // pixels per second
            hitTargetX: 150,
            noteSpawnX: window.innerWidth,
            hitWindow: {
                perfect: 0.05, // 50ms
                good: 0.1,     // 100ms
                miss: 0.15     // 150ms
            },
            scoring: {
                perfect: 1000,
                good: 500,
                miss: 0
            },
            showBanner: false // Default: don't show banner
        };

        // DOM elements - will be initialized in initGame
        let elements = {};
        let donElements = {};
        let spiritElements = {};

        // Initialize game
        async function initGame() {
            // Initialize DOM elements
            elements = {
                loadingScreen: document.getElementById('loadingScreen'),
                projectSelect: document.getElementById('projectSelect'),
                loadGameBtn: document.getElementById('loadGameBtn'),
                songSelector: document.getElementById('songSelector'),
                scoreBar: document.getElementById('scoreBar'),
                pauseMenu: document.getElementById('pauseMenu'),
                pauseBtn: document.getElementById('pauseBtn'),
                restartBtn: document.getElementById('restartBtn'),
                selectSongBtn: document.getElementById('selectSongBtn'),
                exitBtn: document.getElementById('exitBtn'),
                notesContainer: document.getElementById('notesContainer'),
                beatGrid: document.getElementById('beatGrid'),
                unifiedDrum: document.getElementById('unifiedDrum'),
                drumDon: document.getElementById('drumDon'),
                drumKit: document.getElementById('drumKit'),
                pauseTouchDrumToggle: document.getElementById('pauseTouchDrumToggle'),
                pauseTouchDrumCheckbox: document.getElementById('pauseTouchDrumCheckbox'),
                pauseHitTargetToggle: document.getElementById('pauseHitTargetToggle'),
                pauseHitTargetCheckbox: document.getElementById('pauseHitTargetCheckbox'),
                pauseBannerToggle: document.getElementById('pauseBannerToggle'),
                pauseBannerCheckbox: document.getElementById('pauseBannerCheckbox'),
                gameOverScreen: document.getElementById('gameOverScreen'),
                finalScore: document.getElementById('finalScore'),
                maxCombo: document.getElementById('maxCombo'),
                finalAccuracy: document.getElementById('finalAccuracy'),
                finalSpirit: document.getElementById('finalSpirit'),
                finalPerfectHits: document.getElementById('finalPerfectHits'),
                finalGoodHits: document.getElementById('finalGoodHits'),
                finalMissedHits: document.getElementById('finalMissedHits'),
                perfectScore: document.getElementById('perfectScore'),
                goodScore: document.getElementById('goodScore'),
                missScore: document.getElementById('missScore'),
                playAgainBtn: document.getElementById('playAgainBtn'),
                backToSelectionBtn: document.getElementById('backToSelectionBtn'),
                gameBackground: document.getElementById('gameBackground'),
                characterDisplay: document.getElementById('characterDisplay'),
                characterImage: document.getElementById('characterImage'),
                topBanner: document.getElementById('topBanner'),
                songName: document.getElementById('songName'),
                // Song Selection Screen elements
                songSelectionScreen: document.getElementById('songSelectionScreen'),
                selectedSongName: document.getElementById('selectedSongName'),
                songGenre: document.getElementById('songGenre'),
                songList: document.getElementById('songList'),
                selectionCharacter: document.getElementById('selectionCharacter'),
                songInfoFrame: document.getElementById('songInfoFrame'),
                startPerformanceBtn: document.getElementById('startPerformanceBtn'),
                categorySelectBtn: document.getElementById('categorySelectBtn'),
                categoryDropdown: document.getElementById('categoryDropdown'),
                // Curtain elements
                curtain: document.getElementById('curtain'),
                curtainText: document.getElementById('curtainText')
            };

            donElements = {
                donFace: document.getElementById('donFace'),
                donCombo: document.getElementById('donCombo')
            };

            spiritElements = {
                system: document.getElementById('spiritSystem'),
                lines: document.querySelectorAll('.spirit-line'),
                label: document.getElementById('spiritLabel')
            };

            await loadProjects();
            await loadCategoryColors();
            elements.loadingScreen.style.display = 'none';
            
            // Show song selection screen directly instead of song selector
            showSongSelectionScreen();
            
            setupEventListeners();
            initPauseMenuToggles();
        }

        // Initialize pause menu toggles functionality
        function initPauseMenuToggles() {
            // Initialize touch drum toggle
            const touchDrumEnabled = localStorage.getItem('touchDrumEnabled') !== 'false';
            setTouchDrumEnabled(touchDrumEnabled);
            updatePauseMenuCheckbox(elements.pauseTouchDrumCheckbox, touchDrumEnabled);

            // Initialize hit target toggle
            const hitTargetEnabled = localStorage.getItem('hitTargetEnabled') === 'true';
            setHitTargetEnabled(hitTargetEnabled);
            updatePauseMenuCheckbox(elements.pauseHitTargetCheckbox, hitTargetEnabled);

            // Add click event listeners
            elements.pauseTouchDrumToggle.addEventListener('click', () => {
                const currentState = !elements.pauseTouchDrumCheckbox.classList.contains('checked');
                setTouchDrumEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseTouchDrumCheckbox, currentState);
                localStorage.setItem('touchDrumEnabled', currentState);
            });

            elements.pauseHitTargetToggle.addEventListener('click', () => {
                const currentState = !elements.pauseHitTargetCheckbox.classList.contains('checked');
                setHitTargetEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseHitTargetCheckbox, currentState);
                localStorage.setItem('hitTargetEnabled', currentState);
            });

            // Initialize banner toggle
            const bannerEnabled = localStorage.getItem('bannerEnabled') === 'true';
            setBannerEnabled(bannerEnabled);
            updatePauseMenuCheckbox(elements.pauseBannerCheckbox, bannerEnabled);

            elements.pauseBannerToggle.addEventListener('click', () => {
                console.log('[Banner] Toggle button clicked');
                const currentState = !elements.pauseBannerCheckbox.classList.contains('checked');
                console.log('[Banner] Current state will be:', currentState);
                setBannerEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseBannerCheckbox, currentState);
                localStorage.setItem('bannerEnabled', currentState);
                console.log('[Banner] Settings updated');
            });
        }

        // Set touch drum enabled/disabled state
        function setTouchDrumEnabled(enabled) {
            if (enabled) {
                elements.drumKit.classList.remove('hidden');
            } else {
                elements.drumKit.classList.add('hidden');
            }
        }

        // Set hit target enabled/disabled state
        function setHitTargetEnabled(enabled) {
            const hitTarget = document.querySelector('.hit-target');
            if (enabled) {
                hitTarget.classList.add('visible');
            } else {
                hitTarget.classList.remove('visible');
            }
        }

        // Set banner enabled/disabled state
        function setBannerEnabled(enabled) {
            console.log('[Banner] setBannerEnabled called with:', enabled);
            settings.showBanner = enabled;
            
            if (elements.topBanner) {
                if (enabled) {
                    elements.topBanner.style.display = 'block';
                    console.log('[Banner] Banner display set to block');
                    
                    // Update banner display with current spirit value
                    updateBannerDisplay();
                } else {
                    elements.topBanner.style.display = 'none';
                    console.log('[Banner] Banner display set to none');
                }
            } else {
                console.warn('[Banner] topBanner element not found');
            }
        }

        // Update pause menu checkbox visual state
        function updatePauseMenuCheckbox(checkbox, enabled) {
            if (enabled) {
                checkbox.classList.add('checked');
            } else {
                checkbox.classList.remove('checked');
            }
        }

        // Load available projects
        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const data = await response.json();
                
                if (data.status === 'success') {
                    elements.projectSelect.innerHTML = '<option value="">-- 请选择歌曲 --</option>';
                    data.projects.forEach(project => {
                        const option = document.createElement('option');
                        // Use folder_name as value for backend compatibility
                        option.value = project.folder_name;
                        // Display the friendly display_name to user
                        option.textContent = project.display_name;
                        // Store both values for potential future use
                        option.dataset.folderName = project.folder_name;
                        option.dataset.displayName = project.display_name;
                        elements.projectSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to load projects:', error);
            }
        }

        // Load project images (background and character)
        function loadProjectImages(projectName, projectImages) {
            if (!projectImages) {
                console.log('[Images] No images data provided');
                return;
            }

            // Load background image
            if (elements.gameBackground) {
                const sceneImages = projectImages.scene;
                if (sceneImages && sceneImages.background) {
                    const imageUrl = `/api/project/${projectName}/images/${sceneImages.background}`;
                    console.log('[Background] Loading background image:', imageUrl);
                    
                    const img = new Image();
                    img.onload = function() {
                        elements.gameBackground.style.backgroundImage = `url('${imageUrl}')`;
                        elements.gameBackground.classList.add('loaded');
                        console.log('[Background] Background image loaded successfully');
                    };
                    img.onerror = function() {
                        console.warn('[Background] Failed to load background image:', imageUrl);
                    };
                    img.src = imageUrl;
                } else {
                    console.log('[Background] No scene background image found');
                }
            }

            // Use the cute Chinese drum SVG as character image
            if (elements.characterImage) {
                console.log('[Character] Using cute Chinese drum SVG');
                updateCharacterDisplay();
            }

            // Load banner images and store URLs (always load for potential use)
            if (elements.topBanner && projectImages.banner) {
                const bannerImages = projectImages.banner;
                
                // Store banner image URLs in gameState for switching
                gameState.bannerImages = {
                    unsatisfied: null,
                    satisfied: null
                };

                // Preload unsatisfied banner image
                if (bannerImages.unsatisfied) {
                    const unsatisfiedUrl = `/api/project/${projectName}/images/${bannerImages.unsatisfied}`;
                    const unsatisfiedImg = new Image();
                    unsatisfiedImg.onload = function() {
                        gameState.bannerImages.unsatisfied = unsatisfiedUrl;
                        console.log('[Banner] Unsatisfied banner image loaded');
                        // Set initial banner (unsatisfied by default)
                        updateBannerDisplay();
                    };
                    unsatisfiedImg.onerror = function() {
                        console.warn('[Banner] Failed to load unsatisfied banner image');
                    };
                    unsatisfiedImg.src = unsatisfiedUrl;
                }

                // Preload satisfied banner image
                if (bannerImages.satisfied) {
                    const satisfiedUrl = `/api/project/${projectName}/images/${bannerImages.satisfied}`;
                    const satisfiedImg = new Image();
                    satisfiedImg.onload = function() {
                        gameState.bannerImages.satisfied = satisfiedUrl;
                        console.log('[Banner] Satisfied banner image loaded');
                    };
                    satisfiedImg.onerror = function() {
                        console.warn('[Banner] Failed to load satisfied banner image');
                    };
                    satisfiedImg.src = satisfiedUrl;
                }
            } else {
                console.log('[Banner] No banner images found');
            }
        }

        // Load game data for selected project
        // Load game data with curtain transition
        async function loadGameWithCurtain(projectName) {
            if (!projectName) return;

            gameState.currentProject = projectName;
            gameState.currentProjectName = projectName;
            
            // Update song name display
            const selectedOption = elements.projectSelect.querySelector(`option[value="${projectName}"]`);
            const displayName = selectedOption ? selectedOption.dataset.displayName : projectName;
            elements.songName.textContent = displayName;

            try {
                updateCurtainText('加载资源...');
                // Load project images
                const imagesResponse = await fetch(`/api/project/${projectName}/images`);
                let projectImages = null;
                if (imagesResponse.ok) {
                    const imagesData = await imagesResponse.json();
                    if (imagesData.status === 'success') {
                        projectImages = imagesData.images;
                        console.log('Loaded project images:', projectImages);
                    }
                }

                updateCurtainText('加载谱面...');
                // Load score data (beatmap)
                const scoreResponse = await fetch(`/api/score/${projectName}`);
                const scoreData = await scoreResponse.json();
                
                let notes = [];
                if (scoreData.status === 'success' && scoreData.score) {
                    if (Array.isArray(scoreData.score)) {
                        notes = scoreData.score;
                    } else if (scoreData.score.notes) {
                        notes = scoreData.score.notes;
                    }
                }

                // Generate uniform beat grid from BPM data
                let beatGrid = null;
                try {
                    const metadataResponse = await fetch(`/api/metadata/${projectName}`);
                    const metadataData = await metadataResponse.json();
                    console.log('Metadata response:', metadataData);
                    
                    if (metadataData.metadata && metadataData.metadata.bpm_data) {
                        gameState.metadata = metadataData.metadata;
                        
                        // Get BPM and offset from metadata
                        const bpm = metadataData.metadata.bpm_data.bpm;
                        gameState.audioOffset = metadataData.metadata.bpm_data.offset || 0.0;
                        console.log(`[Beat Grid] Using BPM: ${bpm}, Offset: ${gameState.audioOffset.toFixed(3)}s`);
                        
                        if (bpm && gameState.duration) {
                            // Generate uniform beat grid based on BPM
                            const beatInterval = 60 / bpm; // seconds per beat
                            const beats = [];
                            const downbeats = [];
                            
                            // Generate beats from 0 to duration
                            for (let time = 0; time < gameState.duration; time += beatInterval) {
                                beats.push(time);
                                
                                // Every 4th beat is a downbeat (measure line)
                                const beatIndex = Math.round(time / beatInterval);
                                if (beatIndex % 4 === 0) {
                                    downbeats.push(time);
                                }
                            }
                            
                            beatGrid = { 
                                beats, 
                                downbeats,
                                beat_interval: beatInterval 
                            };
                            console.log(`[Beat Grid] Generated uniform grid: ${beats.length} beats, ${downbeats.length} measures`);
                        }
                    }
                } catch (metaError) {
                    console.warn('Could not load beat grid data:', metaError);
                }

                updateCurtainText('加载音频...');
                // Load audio - use original song instead of backing track
                const audioPath = `data/${projectName}/${projectName}.mp3`;
                gameState.audio = new Audio(audioPath);
                
                await new Promise((resolve, reject) => {
                    gameState.audio.onloadeddata = resolve;
                    gameState.audio.onerror = reject;
                });

                updateCurtainText('初始化游戏...');
                
                gameState.duration = gameState.audio.duration;
                gameState.notes = notes.sort((a, b) => a.time - b.time);
                gameState.totalNotes = notes.length;

                generateNoteElements();
                
                // Now generate beat grid with available duration
                generateUniformBeatGrid();
                
                // Load project images (background and character)
                loadProjectImages(projectName, projectImages);
                
                console.log(`Loaded ${notes.length} notes for ${projectName}`);
                
                updateCurtainText('即将开始演奏...');
                
                // Wait a moment then hide curtain and start game
                setTimeout(() => {
                    hideCurtain();
                    setTimeout(() => {
                        startGame();
                    }, 200); // Start game just after curtain starts opening
                }, 800);
                
            } catch (error) {
                console.error('Failed to load game:', error);
                updateCurtainText('加载失败...');
                setTimeout(() => {
                    hideCurtain();
                    setTimeout(() => {
                        alert('加载游戏失败: ' + error.message);
                        showSongSelectionScreen();
                    }, 500);
                }, 1000);
            }
        }

        // Keep original loadGame for backward compatibility
        async function loadGame(projectName) {
            if (!projectName) return;

            elements.loadingScreen.style.display = 'flex';
            
            try {
                await loadGameWithCurtain(projectName);
                elements.loadingScreen.style.display = 'none';
            } catch (error) {
                elements.loadingScreen.style.display = 'none';
                throw error;
            }
        }

        // Generate visual note elements
        function generateNoteElements() {
            elements.notesContainer.innerHTML = '';
            
            gameState.notes.forEach((note, index) => {
                const noteElement = document.createElement('div');
                noteElement.className = `beat-note ${note.type}`;
                // Create SVG icon instead of text
                noteElement.innerHTML = note.type === 'don' ? createDonSVG() : createKaSVG();
                noteElement.dataset.noteIndex = index;
                noteElement.dataset.time = note.time;
                noteElement.dataset.hit = 'false';
                
                // Position note based on time
                const initialX = settings.noteSpawnX + (note.time * settings.scrollSpeed);
                noteElement.style.left = `${initialX}px`;
                
                elements.notesContainer.appendChild(noteElement);
            });
        }

        // Beat grid optimization
        let beatGridData = null;
        let activeBeatLines = new Map(); // Track active beat lines
        let beatLinePool = []; // Pool of reusable beat line elements
        
        // Initialize beat grid data without rendering
        function initializeBeatGrid(beatGrid) {
            console.log('initializeBeatGrid called with:', beatGrid);
            
            if (!beatGrid || !gameState.duration) {
                console.log('No beatGrid data or duration, skipping grid initialization');
                beatGridData = null;
                return;
            }

            // Store beat data for lazy loading
            beatGridData = {
                beats: beatGrid.beats || [],
                downbeats: beatGrid.downbeats || []
            };
            
            console.log('Beat grid initialized with', beatGridData.beats.length, 'beats and', beatGridData.downbeats.length, 'downbeats');
            console.log('Beat grid optimization: using viewport rendering instead of creating', (beatGridData.beats.length + beatGridData.downbeats.length), 'DOM elements at once');
        }

        // Create or reuse a beat line element
        function createBeatLine(time, isMeasure = false) {
            let beatLine;
            
            if (beatLinePool.length > 0) {
                beatLine = beatLinePool.pop();
            } else {
                beatLine = document.createElement('div');
            }
            
            beatLine.className = isMeasure ? 'beat-line measure' : 'beat-line';
            beatLine.dataset.time = time;
            beatLine.style.display = 'block';
            
            return beatLine;
        }

        // Return beat line to pool
        function recycleBeatLine(beatLine) {
            beatLine.style.display = 'none';
            beatLinePool.push(beatLine);
        }

        // Update visible beat lines based on current viewport
        function updateBeatGridViewport() {
            if (!beatGridData || !elements.beatGrid) return;
            
            const currentTime = gameState.currentTime;
            const viewportStart = currentTime - 2; // Show 2 seconds before current time
            const viewportEnd = currentTime + 10;  // Show 10 seconds ahead
            
            // Remove lines that are outside viewport
            for (const [timeKey, beatLine] of activeBeatLines) {
                const lineTime = parseFloat(timeKey);
                if (lineTime < viewportStart || lineTime > viewportEnd) {
                    elements.beatGrid.removeChild(beatLine);
                    recycleBeatLine(beatLine);
                    activeBeatLines.delete(timeKey);
                }
            }
            
            // Add lines that should be visible
            const linesToAdd = [];
            
            // Check downbeats (measures)
            beatGridData.downbeats.forEach(time => {
                if (time >= viewportStart && time <= viewportEnd && !activeBeatLines.has(time.toString())) {
                    linesToAdd.push({ time, isMeasure: true });
                }
            });
            
            // Check regular beats
            beatGridData.beats.forEach(time => {
                if (time >= viewportStart && time <= viewportEnd && 
                    !activeBeatLines.has(time.toString()) && 
                    !beatGridData.downbeats.includes(time)) {
                    linesToAdd.push({ time, isMeasure: false });
                }
            });
            
            // Add new lines in batches to avoid blocking
            if (linesToAdd.length > 0) {
                const batchSize = 10;
                for (let i = 0; i < Math.min(batchSize, linesToAdd.length); i++) {
                    const { time, isMeasure } = linesToAdd[i];
                    const beatLine = createBeatLine(time, isMeasure);
                    
                    // Position based on time with offset for alignment
                    const offsetTime = time + gameState.audioOffset;
                    const timeDiff = offsetTime - currentTime;
                    const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                    beatLine.style.left = `${x}px`;
                    
                    elements.beatGrid.appendChild(beatLine);
                    activeBeatLines.set(time.toString(), beatLine);
                }
            }
        }

        // Update beat grid positions and viewport
        function updateBeatGrid() {
            if (!beatGridData) return;
            
            // Update viewport every few frames to avoid excessive computation
            if (gameState.currentTime % 0.1 < 0.05) { // Approximately every 100ms
                updateBeatGridViewport();
            }
            
            // Update positions of active beat lines
            for (const [timeKey, beatLine] of activeBeatLines) {
                const lineTime = parseFloat(timeKey);
                const offsetTime = lineTime + gameState.audioOffset;
                const timeDiff = offsetTime - gameState.currentTime;
                const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                beatLine.style.left = `${x}px`;
            }
        }

        // Generate uniform beat grid from metadata BPM
        function generateUniformBeatGrid() {
            if (!gameState.metadata || !gameState.metadata.bpm_data || !gameState.duration) {
                console.log('[Beat Grid] Cannot generate: missing metadata or duration');
                return;
            }
            
            const bpm = gameState.metadata.bpm_data.bpm;
            console.log(`[Beat Grid] Generating uniform grid: BPM=${bpm}, Duration=${gameState.duration.toFixed(2)}s`);
            
            // Generate uniform beat grid based on BPM
            const beatInterval = 60 / bpm; // seconds per beat
            const beats = [];
            const downbeats = [];
            
            // Generate beats from 0 to duration
            for (let time = 0; time < gameState.duration; time += beatInterval) {
                beats.push(time);
                
                // Every 4th beat is a downbeat (measure line)
                const beatIndex = Math.round(time / beatInterval);
                if (beatIndex % 4 === 0) {
                    downbeats.push(time);
                }
            }
            
            const beatGrid = { 
                beats, 
                downbeats,
                beat_interval: beatInterval 
            };
            
            console.log(`[Beat Grid] Generated: ${beats.length} beats, ${downbeats.length} measures (interval: ${beatInterval.toFixed(6)}s)`);
            initializeBeatGrid(beatGrid);
        }

        // Clear beat grid
        function clearBeatGrid() {
            // Return all active beat lines to pool
            for (const [timeKey, beatLine] of activeBeatLines) {
                elements.beatGrid.removeChild(beatLine);
                recycleBeatLine(beatLine);
            }
            activeBeatLines.clear();
        }

        // Start game
        function startGame() {
            if (!gameState.currentProject || !gameState.audio) return;

            resetGameState();
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.startTime = performance.now();
            
            gameState.audio.currentTime = 0;
            gameState.audio.play();
            
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            if (!gameState.isPlaying || gameState.isPaused) return;

            const now = performance.now();
            gameState.currentTime = (now - gameState.startTime) / 1000;
            
            // Update audio sync
            if (Math.abs(gameState.audio.currentTime - gameState.currentTime) > 0.1) {
                gameState.currentTime = gameState.audio.currentTime;
            }

            updateNotePositions();
            updateBeatGrid();
            checkMissedNotes();
            updateUI();
            updateParticles();

            // Check if song finished
            if (gameState.currentTime >= gameState.duration) {
                endGame();
                return;
            }

            gameState.animationId = requestAnimationFrame(gameLoop);
        }

        // Update note positions
        function updateNotePositions() {
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            
            notes.forEach(noteElement => {
                // Skip notes that are already hit but still animating
                if (noteElement.dataset.hit === 'true' && !noteElement.classList.contains('hit')) {
                    return;
                }
                
                const noteTime = parseFloat(noteElement.dataset.time);
                const timeDiff = noteTime - gameState.currentTime;
                const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                
                noteElement.style.left = `${x}px`;
                
                // Remove notes that are too far off screen (left side)
                if (x < -100) {
                    noteElement.remove();
                }
            });
        }

        // Check for missed notes
        function checkMissedNotes() {
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            
            notes.forEach(noteElement => {
                if (noteElement.dataset.hit === 'true') return;
                
                const noteTime = parseFloat(noteElement.dataset.time);
                
                if (gameState.currentTime > noteTime + settings.hitWindow.miss) {
                    // Note missed
                    noteElement.dataset.hit = 'true';
                    gameState.missedHits++;
                    gameState.combo = 0;
                    showJudgment('miss');
                    
                    // Update Spirit system for miss
                    updateSpiritValue('miss');
                    
                    // Remove missed note after brief delay
                    setTimeout(() => {
                        if (noteElement.parentNode) {
                            noteElement.remove();
                        }
                    }, 500);
                }
            });
        }

        // Handle drum hits
        function hitDrum(type) {
            // Update Don character display
            updateDonDisplay(type);
            
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            let bestNote = null;
            let bestTimeDiff = Infinity;
            
            // Find the closest note of matching type
            notes.forEach(noteElement => {
                if (noteElement.dataset.hit === 'true') return;
                if (!noteElement.classList.contains(type)) return;
                
                const noteTime = parseFloat(noteElement.dataset.time);
                const timeDiff = Math.abs(noteTime - gameState.currentTime);
                
                if (timeDiff <= settings.hitWindow.miss && timeDiff < bestTimeDiff) {
                    bestNote = noteElement;
                    bestTimeDiff = timeDiff;
                }
            });
            
            if (bestNote) {
                // Hit successful
                bestNote.dataset.hit = 'true';
                bestNote.classList.add('hit');
                
                let judgment, points;
                if (bestTimeDiff <= settings.hitWindow.perfect) {
                    judgment = 'perfect';
                    points = settings.scoring.perfect;
                    gameState.perfectHits++;
                } else if (bestTimeDiff <= settings.hitWindow.good) {
                    judgment = 'good';
                    points = settings.scoring.good;
                    gameState.goodHits++;
                } else {
                    judgment = 'miss';
                    points = settings.scoring.miss;
                    gameState.missedHits++;
                }
                
                if (judgment !== 'miss') {
                    gameState.combo++;
                    gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                    gameState.hitNotes++;
                } else {
                    gameState.combo = 0;
                }
                
                // Track separate scores for detailed statistics
                const comboBonus = gameState.combo * 10;
                if (judgment === 'perfect') {
                    gameState.perfectScore += points + comboBonus;
                } else if (judgment === 'good') {
                    gameState.goodScore += points + comboBonus;
                }
                gameState.comboScore += comboBonus;
                
                gameState.score += points + comboBonus;
                showJudgment(judgment);
                createHitEffect(type);
                
                // Update Spirit system
                updateSpiritValue(judgment);
                
                // Add hit effect for successful hits with different colors
                if (judgment === 'perfect') {
                    createHitEffect_Golden();
                } else if (judgment === 'good') {
                    createHitEffect_White();
                }
                
                // Remove note immediately if hit successfully, otherwise after animation
                if (judgment === 'perfect' || judgment === 'good') {
                    // Immediately remove successful hits
                    if (bestNote.parentNode) {
                        bestNote.remove();
                    }
                } else {
                    // Keep original delay for miss
                    setTimeout(() => {
                        if (bestNote.parentNode) {
                            bestNote.remove();
                        }
                    }, 300);
                }
            }
            
            // Visual drum feedback - updated for separate elements
            if (type === 'don') {
                elements.drumDon.classList.add('hit');
                setTimeout(() => {
                    elements.drumDon.classList.remove('hit');
                }, 150);
            } else {
                elements.unifiedDrum.classList.add('hit-ka');
                setTimeout(() => {
                    elements.unifiedDrum.classList.remove('hit-ka');
                }, 150);
            }
        }

        // Show judgment text
        function showJudgment(type) {
            // Remove existing judgment
            const existingJudgment = document.querySelector('.judgment');
            if (existingJudgment) {
                existingJudgment.remove();
            }
            
            const judgment = document.createElement('div');
            judgment.className = `judgment ${type}`;
            
            switch (type) {
                case 'perfect':
                    judgment.textContent = '优';
                    break;
                case 'good':
                    judgment.textContent = '良';
                    break;
                case 'miss':
                    judgment.textContent = '不可';
                    break;
            }
            
            document.querySelector('.game-area').appendChild(judgment);
        }

        // Create hit effect
        function createHitEffect(type) {
            const effect = document.createElement('div');
            effect.className = type === 'ka' ? 'hit-effect ka' : 'hit-effect';
            
            // Position exactly at target drum center
            const targetDrum = document.querySelector('.target-drum');
            const drumRect = targetDrum.getBoundingClientRect();
            const beatTrackRect = document.querySelector('.beat-track').getBoundingClientRect();
            
            // Calculate relative position within beat-track
            const relativeLeft = drumRect.left + drumRect.width/2 - beatTrackRect.left;
            const relativeTop = drumRect.top + drumRect.height/2 - beatTrackRect.top;
            
            effect.style.left = `${relativeLeft}px`;
            effect.style.top = `${relativeTop}px`;
            effect.style.transform = 'translate(-50%, -50%)';
            
            document.querySelector('.beat-track').appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 300);
        }

        // Create particles for hit effects with Chinese elements
        function createParticles(type, count = 8) {
            const targetDrum = document.querySelector('.target-drum');
            const drumRect = targetDrum.getBoundingClientRect();
            const beatTrack = document.querySelector('.beat-track');
            const beatTrackRect = beatTrack.getBoundingClientRect();
            
            // Calculate center position within beat-track
            const centerX = drumRect.left + drumRect.width/2 - beatTrackRect.left;
            const centerY = drumRect.top + drumRect.height/2 - beatTrackRect.top;
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                
                // Create different particle types for Chinese elements
                const chineseElements = ['lotus-petal', 'cloud-wisp', 'bamboo-leaf'];
                const randomElement = chineseElements[Math.floor(Math.random() * chineseElements.length)];
                
                if (type === 'golden' && Math.random() < 0.6) {
                    // Golden hits spawn more lotus petals and cloud wisps
                    particle.className = `hit-particle particle-chinese particle-${randomElement} particle-golden`;
                    particle.innerHTML = createChineseParticleSVG(randomElement, 'golden');
                } else if (type === 'white' && Math.random() < 0.4) {
                    // White hits spawn some Chinese elements too
                    particle.className = `hit-particle particle-chinese particle-${randomElement} particle-white`;
                    particle.innerHTML = createChineseParticleSVG(randomElement, 'white');
                } else {
                    // Fallback to original particle system
                    particle.className = `hit-particle particle-${type}`;
                }
                
                // Random initial position around the center (slight spread)
                const spread = 15;
                const startX = centerX + (Math.random() - 0.5) * spread;
                const startY = centerY + (Math.random() - 0.5) * spread;
                
                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;
                
                beatTrack.appendChild(particle);
                
                // Create particle object for animation
                const particleObj = {
                    element: particle,
                    startX: startX,
                    startY: startY,
                    // Random velocity components (overall rightward)
                    velocityX: 2 + Math.random() * 4, // 2-6 rightward base speed
                    velocityY: (Math.random() - 0.5) * 3, // -1.5 to 1.5 vertical speed
                    // Random wave parameters for sin/cos motion
                    waveAmplitude: 20 + Math.random() * 30, // 20-50 wave height
                    waveFrequency: 0.05 + Math.random() * 0.1, // wave frequency
                    // Lifecycle
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.015, // 0.015-0.03 decay per frame
                    startTime: performance.now()
                };
                
                particles.push(particleObj);
            }
        }
        
        // Create Chinese particle SVG elements
        function createChineseParticleSVG(elementType, colorType) {
            const goldColor = colorType === 'golden' ? '#FFD700' : '#FFFFFF';
            const accentColor = colorType === 'golden' ? '#FFA500' : '#E0E0E0';
            
            switch (elementType) {
                case 'lotus-petal':
                    return `
                        <svg width="12" height="12" viewBox="0 0 20 20" style="pointer-events: none;">
                            <path d="M 10,18 Q 5,10 2,2 Q 10,5 18,2 Q 15,10 10,18 Z" 
                                  fill="${goldColor}" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.9"/>
                            <path d="M 10,15 Q 7,10 5,5 Q 10,7 15,5 Q 13,10 10,15 Z" 
                                  fill="${accentColor}" 
                                  opacity="0.6"/>
                        </svg>
                    `;
                
                case 'cloud-wisp':
                    return `
                        <svg width="16" height="8" viewBox="0 0 32 16" style="pointer-events: none;">
                            <path d="M 2,8 Q 0,4 4,4 Q 8,2 12,4 Q 16,2 20,4 Q 24,2 28,4 Q 32,4 30,8 Q 28,12 24,10 Q 20,12 16,10 Q 12,12 8,10 Q 4,12 2,8 Z" 
                                  fill="${goldColor}" 
                                  opacity="0.7"/>
                            <path d="M 6,7 Q 4,5 6,5 Q 10,4 14,5 Q 18,4 22,5 Q 26,4 28,7 Q 26,9 22,8 Q 18,9 14,8 Q 10,9 6,7 Z" 
                                  fill="${accentColor}" 
                                  opacity="0.5"/>
                        </svg>
                    `;
                
                case 'bamboo-leaf':
                    return `
                        <svg width="8" height="16" viewBox="0 0 16 32" style="pointer-events: none;">
                            <path d="M 8,30 Q 4,20 2,10 Q 4,5 8,2 Q 12,5 14,10 Q 12,20 8,30 Z" 
                                  fill="${goldColor}" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.8"/>
                            <line x1="8" y1="4" x2="8" y2="28" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.6"/>
                        </svg>
                    `;
                
                default:
                    return '';
            }
        }

        // Update all particles
        function updateParticles() {
            const currentTime = performance.now();
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                const elapsed = (currentTime - particle.startTime) / 1000; // seconds
                
                // Update position using sin/cos for wave motion
                const baseX = particle.startX + particle.velocityX * elapsed * 60; // 60fps base
                const baseY = particle.startY + particle.velocityY * elapsed * 60;
                const waveY = Math.sin(elapsed * particle.waveFrequency * Math.PI * 2) * particle.waveAmplitude * particle.life;
                
                const finalX = baseX;
                const finalY = baseY + waveY;
                
                // Update particle position
                particle.element.style.left = `${finalX}px`;
                particle.element.style.top = `${finalY}px`;
                
                // Update life and opacity
                particle.life -= particle.decay;
                particle.element.style.opacity = Math.max(0, particle.life);
                particle.element.style.transform = `scale(${0.5 + particle.life * 0.5})`;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                }
            }
        }

        // Create golden hit effect for perfect hits
        function createHitEffect_Golden() {
            const targetDrum = document.querySelector('.target-drum');
            
            // Add golden effect only to target drum
            targetDrum.classList.add('golden-hit');
            
            // Create golden particles
            createParticles('golden', 12);
            
            // Remove effects after animation
            setTimeout(() => {
                targetDrum.classList.remove('golden-hit');
            }, 800);
        }

        // Create white hit effect for good hits
        function createHitEffect_White() {
            const targetDrum = document.querySelector('.target-drum');
            
            // Add white effect only to target drum
            targetDrum.classList.add('white-hit');
            
            // Create white particles
            createParticles('white', 8);
            
            // Remove effects after animation
            setTimeout(() => {
                targetDrum.classList.remove('white-hit');
            }, 800);
        }

        // Update Don character display
        function updateDonDisplay(type) {
            if (!donElements.donFace) return;
            
            // 根据击打类型亮起对应区域
            if (type === 'don') {
                // Don - 内圈亮红
                donElements.donFace.classList.remove('hit-ka');
                donElements.donFace.classList.add('hit-don');
            } else if (type === 'ka') {
                // Ka - 外圈亮蓝  
                donElements.donFace.classList.remove('hit-don');
                donElements.donFace.classList.add('hit-ka');
            }
            
            // Reset after animation
            setTimeout(() => {
                donElements.donFace.classList.remove('hit-don', 'hit-ka');
            }, 200);
        }

        // Update UI
        function updateUI() {
            // Update score bar
            elements.scoreBar.textContent = `得分: ${gameState.score.toLocaleString()}`;
            
            // Update Don combo display
            if (donElements.donCombo) {
                donElements.donCombo.textContent = gameState.combo;
            }
        }


        // Reset game state
        function resetGameState() {
            gameState.score = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.hitNotes = 0;
            gameState.perfectHits = 0;
            gameState.goodHits = 0;
            gameState.missedHits = 0;
            gameState.perfectScore = 0;
            gameState.goodScore = 0;
            gameState.comboScore = 0;
            gameState.currentTime = 0;
            
            // Reset Spirit system
            resetSpiritSystem();
            
            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }
            
            // Clear beat grid
            clearBeatGrid();
            
            // Clear all particles
            particles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            particles = [];
            
            generateNoteElements();
            
            // Regenerate uniform beat grid
            generateUniformBeatGrid();
        }

        // Update character display based on spirit value
        function updateCharacterDisplay() {
            if (!elements.characterImage) {
                return;
            }

            // Always use the cute Chinese drum SVG
            elements.characterImage.src = 'cute-chinese-drum.svg';
            elements.characterDisplay.classList.add('loaded');
            
            console.log(`[Character] Using cute Chinese drum SVG (spirit: ${Math.round(gameState.spiritValue)}%)`);
        }

        // Update banner display based on spirit value
        function updateBannerDisplay() {
            if (!settings.showBanner || !elements.topBanner || !gameState.bannerImages) {
                return;
            }

            const isSatisfied = gameState.spiritValue >= 60; // Spirit >= 60% is satisfied
            const imageUrl = isSatisfied ? 
                gameState.bannerImages.satisfied : 
                gameState.bannerImages.unsatisfied;

            if (imageUrl) {
                elements.topBanner.style.backgroundImage = `url('${imageUrl}')`;
                elements.topBanner.classList.add('loaded');
                
                console.log(`[Banner] Updated to ${isSatisfied ? 'satisfied' : 'unsatisfied'} (spirit: ${Math.round(gameState.spiritValue)}%)`);
            }
        }

        // Clear project images
        function clearProjectImages() {
            // Clear background image
            if (elements.gameBackground) {
                elements.gameBackground.style.backgroundImage = '';
                elements.gameBackground.classList.remove('loaded');
            }
            
            // Clear character image
            if (elements.characterImage) {
                elements.characterImage.src = '';
                elements.characterDisplay.classList.remove('loaded');
            }
            
            // Clear banner image
            if (elements.topBanner) {
                elements.topBanner.style.backgroundImage = '';
                elements.topBanner.classList.remove('loaded');
            }
            
            // Clear stored image URLs
            if (gameState.characterImages) {
                gameState.characterImages = null;
            }
            if (gameState.bannerImages) {
                gameState.bannerImages = null;
            }
        }

        // End game
        function endGame() {
            gameState.isPlaying = false;
            if (gameState.audio) {
                gameState.audio.pause();
            }
            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }
            
            showGameOverScreen();
        }

        // Send game result to backend
        async function sendGameResult() {
            if (!gameState.currentProject) {
                console.warn('No current project - cannot send game result');
                return;
            }
            
            const accuracy = gameState.totalNotes > 0 ? 
                Math.round((gameState.hitNotes / Math.max(gameState.hitNotes + gameState.missedHits, 1)) * 100) : 100;
            
            // Calculate play time (actual time spent playing)
            const playTime = gameState.currentTime;
            
            const gameResult = {
                project_name: gameState.currentProject,
                timestamp: new Date().toISOString(),
                final_score: gameState.score,
                max_combo: gameState.maxCombo,
                accuracy: accuracy,
                spirit_value: Math.round(gameState.spiritValue),
                max_spirit_combo: gameState.maxSpiritCombo,
                total_notes: gameState.totalNotes,
                hit_notes: gameState.hitNotes,
                perfect_hits: gameState.perfectHits,
                good_hits: gameState.goodHits,
                missed_hits: gameState.missedHits,
                perfect_score: gameState.perfectHits * settings.scoring.perfect,
                good_score: gameState.goodHits * settings.scoring.good,
                combo_score: gameState.comboScore,
                duration: gameState.duration,
                play_time: playTime,
                completion_rate: Math.round((playTime / gameState.duration) * 100),
                challenge_failed: gameState.challengeFailed,
                // Additional metadata
                game_settings: {
                    scroll_speed: settings.scrollSpeed,
                    hit_window_perfect: settings.hitWindow.perfect,
                    hit_window_good: settings.hitWindow.good,
                    scoring_perfect: settings.scoring.perfect,
                    scoring_good: settings.scoring.good
                }
            };
            
            try {
                const response = await fetch('/api/game-result', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(gameResult)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Game result saved successfully:', result);
                } else {
                    console.error('Failed to save game result:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('Error sending game result:', error);
            }
        }
        
        // Show game over screen
        function showGameOverScreen() {
            const accuracy = gameState.totalNotes > 0 ? 
                Math.round((gameState.hitNotes / Math.max(gameState.hitNotes + gameState.missedHits, 1)) * 100) : 100;
            
            // Basic stats
            elements.finalScore.textContent = gameState.score.toLocaleString();
            elements.maxCombo.textContent = gameState.maxCombo;
            elements.finalAccuracy.textContent = `${accuracy}%`;
            elements.finalSpirit.textContent = `${Math.round(gameState.spiritValue)}%`;
            
            // Detailed hit statistics
            elements.finalPerfectHits.textContent = gameState.perfectHits;
            elements.finalGoodHits.textContent = gameState.goodHits;
            elements.finalMissedHits.textContent = gameState.missedHits;
            
            // Individual scores (approximated since we track combined scores)
            const perfectBaseScore = gameState.perfectHits * settings.scoring.perfect;
            const goodBaseScore = gameState.goodHits * settings.scoring.good;
            
            elements.perfectScore.textContent = `${perfectBaseScore.toLocaleString()}分`;
            elements.goodScore.textContent = `${goodBaseScore.toLocaleString()}分`;
            elements.missScore.textContent = '0分';
            
            // Send game result to backend
            sendGameResult();
            
            elements.gameOverScreen.style.display = 'flex';
        }

        // Song Selection Screen Functions
        function showSongSelectionScreen() {
            elements.songSelectionScreen.style.display = 'flex';
            populateSongList();
            console.log('[SongSelection] Song selection screen shown');
        }

        function hideSongSelectionScreen() {
            elements.songSelectionScreen.style.display = 'none';
            console.log('[SongSelection] Song selection screen hidden');
        }


        async function populateSongList() {
            if (!elements.songList) return;
            
            // Clear only song items, not navigation buttons
            const songItems = elements.songList.querySelectorAll('.song-item');
            songItems.forEach(item => item.remove());
            
            try {
                const response = await fetch('/api/projects');
                const data = await response.json();
                
                if (data.status === 'success' && data.projects) {
                    // Create navigation button to right (if not already exists)
                    let navButtonRight = document.getElementById('navButtonRight');
                    if (!navButtonRight) {
                        navButtonRight = document.createElement('div');
                        navButtonRight.className = 'nav-button nav-button-left';
                        navButtonRight.id = 'navButtonRight';
                        navButtonRight.innerHTML = '<div class="nav-button-content">来到最右侧</div>';
                        elements.songList.appendChild(navButtonRight);
                    }
                    
                    // Filter projects by selected category
                    const filteredProjects = await filterProjectsByCategory(data.projects);
                    
                    // Create real song items
                    for (const project of filteredProjects) {
                        const songItem = await createSongItem(project, true);
                        elements.songList.appendChild(songItem);
                    }
                    
                    // Create navigation button to left (if not already exists)
                    let navButtonLeft = document.getElementById('navButtonLeft');
                    if (!navButtonLeft) {
                        navButtonLeft = document.createElement('div');
                        navButtonLeft.className = 'nav-button nav-button-right';
                        navButtonLeft.id = 'navButtonLeft';
                        navButtonLeft.innerHTML = '<div class="nav-button-content">来到最左侧</div>';
                        elements.songList.appendChild(navButtonLeft);
                    }
                }
                
                // Initialize center selection after populating
                initializeCenterSelection();
                
                // Setup navigation button listeners after songs are populated
                setupNavigationButtons();
                
            } catch (error) {
                console.error('Failed to populate song list:', error);
            }
        }

        // Create a song item element
        async function createSongItem(project, isReal) {
            const songItem = document.createElement('div');
            songItem.className = 'song-item';
            songItem.dataset.projectName = project.folder_name;
            songItem.dataset.displayName = project.display_name;
            songItem.dataset.isReal = isReal ? 'true' : 'false';
            
            const songName = document.createElement('div');
            songName.className = 'song-item-name';
            songName.textContent = project.display_name;
            
            songItem.appendChild(songName);
            
            // Set song item colors based on category
            await setSongItemColors(songItem, project, isReal);
            
            // Add click handler
            songItem.addEventListener('click', () => {
                selectSong(songItem, project);
            });
            
            return songItem;
        }

        // Set song item colors based on project category
        async function setSongItemColors(songItem, project, isReal) {
            // Default color for demo/test songs
            if (!isReal || !project.folder_name || project.folder_name.includes('_test')) {
                songItem.style.background = 'linear-gradient(45deg, #FF006E, #8338EC)';
                songItem.style.borderColor = '#FFFFFF';
                return;
            }
            
            try {
                const response = await fetch(`/api/project/${project.folder_name}/metadata`);
                const metadata = await response.json();
                
                if (response.ok && metadata) {
                    const category = metadata.category || 'Pop';
                    
                    // Get category colors
                    let categoryConfig;
                    if (gameState.categoryColors && gameState.categoryColors.categories[category]) {
                        categoryConfig = gameState.categoryColors.categories[category];
                    } else {
                        // Fallback colors
                        const fallbackColors = {
                            'Pop': { primary: '#FF6B9D', secondary: '#FFE1EC', accent: '#FF1F6A' },
                            'Trance': { primary: '#00D4FF', secondary: '#E0F7FF', accent: '#0099CC' },
                            'Brutal': { primary: '#FF4444', secondary: '#FFE6E6', accent: '#CC0000' },
                            'Softcore': { primary: '#90EE90', secondary: '#F0FFF0', accent: '#32CD32' }
                        };
                        categoryConfig = fallbackColors[category] || fallbackColors['Pop'];
                    }
                    
                    // Apply category colors
                    songItem.style.background = `linear-gradient(45deg, ${categoryConfig.primary}, ${categoryConfig.secondary})`;
                    songItem.style.borderColor = categoryConfig.accent;
                    
                } else {
                    // Fallback to Pop colors
                    songItem.style.background = 'linear-gradient(45deg, #FF6B9D, #FFE1EC)';
                    songItem.style.borderColor = '#FF1F6A';
                }
            } catch (error) {
                console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                // Fallback to Pop colors
                songItem.style.background = 'linear-gradient(45deg, #FF6B9D, #FFE1EC)';
                songItem.style.borderColor = '#FF1F6A';
            }
        }


        function selectSong(songItem, project) {
            // Remove selection from all songs
            document.querySelectorAll('.song-item').forEach(item => {
                item.classList.remove('selected');
                item.classList.remove('center-focus');
            });
            
            // Select this song and add center focus
            songItem.classList.add('selected');
            songItem.classList.add('center-focus');
            
            // Update song info display
            elements.selectedSongName.textContent = project.display_name;
            
            // Update song genre display and colors based on project metadata
            updateSongGenreDisplay(project);
            
            // Store selected project (only if it's a real song)
            if (songItem.dataset.isReal === 'true') {
                gameState.selectedProject = project.folder_name;
            } else {
                gameState.selectedProject = null; // Dummy song can't be played
            }
            
            // Show or hide start button based on selection
            showStartButton();
            
            // Mark that this is a click-initiated scroll with longer protection
            gameState.isClickScrolling = true;
            gameState.clickScrollStartTime = performance.now();
            
            // Center the clicked song with smooth animation
            centerSongItem(songItem);
            
            // Extend the click scrolling protection time for longer animations
            setTimeout(() => {
                gameState.isClickScrolling = false;
                gameState.clickScrollStartTime = null;
                
                // Final state cleanup: ensure the clicked song is properly centered and focused
                setTimeout(() => {
                    // Re-run center selection to ensure final state is correct
                    const finalUpdate = () => {
                        const containerRect = elements.songList.getBoundingClientRect();
                        const containerCenter = containerRect.left + containerRect.width / 2;
                        
                        let finalClosestItem = null;
                        let finalClosestDistance = Infinity;
                        
                        document.querySelectorAll('.song-item').forEach(item => {
                            const itemRect = item.getBoundingClientRect();
                            const itemCenter = itemRect.left + itemRect.width / 2;
                            const distance = Math.abs(itemCenter - containerCenter);
                            
                            if (distance < finalClosestDistance) {
                                finalClosestDistance = distance;
                                finalClosestItem = item;
                            }
                        });
                        
                        if (finalClosestItem) {
                            // Clean final state
                            document.querySelectorAll('.song-item').forEach(item => {
                                item.classList.remove('center-focus');
                            });
                            finalClosestItem.classList.add('center-focus');
                        }
                    };
                    
                    finalUpdate();
                }, 100); // Small delay to ensure scroll animation is complete
            }, 800); // Increased from 500ms to 800ms
            
            console.log('[SongSelection] Selected song:', project.display_name);
        }

        // Initialize center selection functionality with auto-snap
        function initializeCenterSelection() {
            const container = elements.songList;
            let scrollTimeout;
            let isScrolling = false;
            let isUserScrolling = false; // Track if user is manually scrolling
            
            function updateCenterSelection() {
                const containerRect = container.getBoundingClientRect();
                const containerCenter = containerRect.left + containerRect.width / 2;
                
                let closestItem = null;
                let closestDistance = Infinity;
                
                // Find the song item closest to center
                document.querySelectorAll('.song-item').forEach(item => {
                    const itemRect = item.getBoundingClientRect();
                    const itemCenter = itemRect.left + itemRect.width / 2;
                    const distance = Math.abs(itemCenter - containerCenter);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItem = item;
                    }
                });
                
                if (closestItem) {
                    // During click scrolling, don't change the visual states to prevent flicker
                    if (gameState.isClickScrolling) {
                        // Only update the song info but don't change visual classes
                        const project = {
                            folder_name: closestItem.dataset.projectName,
                            display_name: closestItem.dataset.displayName
                        };
                        
                        elements.selectedSongName.textContent = project.display_name;
                        
                        // Update song genre display and colors
                        updateSongGenreDisplay(project);
                        
                        // Store selected project (only if it's a real song)
                        if (closestItem.dataset.isReal === 'true') {
                            gameState.selectedProject = project.folder_name;
                        } else {
                            gameState.selectedProject = null;
                        }
                        
                        return closestItem;
                    }
                    
                    // Normal scroll behavior - update visual states
                    document.querySelectorAll('.song-item').forEach(item => {
                        item.classList.remove('center-focus');
                        // If user is scrolling, also remove selected state to avoid conflicts
                        if (isUserScrolling) {
                            item.classList.remove('selected');
                        }
                    });
                    
                    // Add center focus to closest item
                    closestItem.classList.add('center-focus');
                    
                    // Update song info display automatically
                    const project = {
                        folder_name: closestItem.dataset.projectName,
                        display_name: closestItem.dataset.displayName
                    };
                    
                    elements.selectedSongName.textContent = project.display_name;
                    
                    // Update song genre display and colors
                    updateSongGenreDisplay(project);
                    
                    // Store selected project (only if it's a real song)
                    if (closestItem.dataset.isReal === 'true') {
                        gameState.selectedProject = project.folder_name;
                    } else {
                        gameState.selectedProject = null;
                    }
                    
                    // Update start button visibility
                    showStartButton();
                    
                    return closestItem;
                }
                return null;
            }
            
            function handleScrollEnd() {
                isScrolling = false;
                isUserScrolling = false; // Reset user scrolling flag
                
                // Don't auto-snap if we're still in click scrolling mode
                if (gameState.isClickScrolling) {
                    return;
                }
                
                // Additional protection: don't auto-snap if click was recent
                if (gameState.clickScrollStartTime && 
                    (performance.now() - gameState.clickScrollStartTime) < 1000) {
                    return;
                }
                
                // Find center item and snap to it
                const centerItem = updateCenterSelection();
                if (centerItem) {
                    centerSongItem(centerItem);
                }
            }
            
            // Update center selection on scroll
            container.addEventListener('scroll', () => {
                // Only set user scrolling flag if this is not programmatic scrolling
                if (!isScrolling && !gameState.isClickScrolling) {
                    isUserScrolling = true;
                }
                isScrolling = true;
                
                // Update center focus immediately for visual feedback
                updateCenterSelection();
                
                // Clear existing timeout
                clearTimeout(scrollTimeout);
                
                // Set timeout to snap to center after scrolling stops (increased delay)
                scrollTimeout = setTimeout(handleScrollEnd, 300); // Increased from 150ms to 300ms
            });
            
            // Initial center selection
            setTimeout(() => {
                const centerItem = updateCenterSelection();
                if (centerItem) {
                    // Center the first item without smooth animation initially
                    container.style.scrollBehavior = 'auto';
                    centerSongItem(centerItem);
                    container.style.scrollBehavior = 'smooth';
                }
            }, 100);
        }

        // Center a specific song item in view
        function centerSongItem(songItem) {
            const container = elements.songList;
            const containerRect = container.getBoundingClientRect();
            const itemRect = songItem.getBoundingClientRect();
            
            const scrollLeft = container.scrollLeft;
            const itemCenter = itemRect.left + itemRect.width / 2;
            const containerCenter = containerRect.left + containerRect.width / 2;
            const offset = itemCenter - containerCenter;
            
            // Increased tolerance to reduce micro-adjustments and oscillation
            if (Math.abs(offset) > 15) { // Increased from 5px to 15px tolerance
                // Temporarily disable scroll-behavior for more precise control
                const originalBehavior = container.style.scrollBehavior;
                container.style.scrollBehavior = 'smooth';
                
                container.scrollTo({
                    left: scrollLeft + offset,
                    behavior: 'smooth'
                });
                
                // Restore original scroll behavior after a delay
                setTimeout(() => {
                    container.style.scrollBehavior = originalBehavior;
                }, 100);
            }
        }


        function setupSongSelectionListeners() {
            // Start performance button (no longer inside song info frame)
            elements.startPerformanceBtn.addEventListener('click', () => {
                if (gameState.selectedProject) {
                    startPerformance();
                }
            });

            // Category selection button event listeners
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategoryDropdown();
                });
            }

            if (elements.categoryDropdown) {
                elements.categoryDropdown.addEventListener('click', (e) => {
                    const categoryItem = e.target.closest('.category-dropdown-item');
                    if (categoryItem) {
                        const selectedCategory = categoryItem.dataset.category;
                        selectCategory(selectedCategory);
                        hideCategoryDropdown();
                    }
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#categorySelectBtn') && !e.target.closest('#categoryDropdown')) {
                    hideCategoryDropdown();
                }
            });

        }

        // Toggle category dropdown visibility
        function toggleCategoryDropdown() {
            if (elements.categoryDropdown.classList.contains('show')) {
                hideCategoryDropdown();
            } else {
                showCategoryDropdown();
            }
        }

        // Show category dropdown
        function showCategoryDropdown() {
            elements.categoryDropdown.classList.add('show');
        }

        // Hide category dropdown
        function hideCategoryDropdown() {
            elements.categoryDropdown.classList.remove('show');
        }

        // Category selection functionality
        function selectCategory(category) {
            // Update visual state of dropdown items
            document.querySelectorAll('.category-dropdown-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.category === category) {
                    item.classList.add('active');
                }
            });

            // Update category button text
            const categoryDisplayNames = {
                'All': '全部',
                'Pop': 'Pop',
                'Trance': 'Trance',  
                'Brutal': 'Brutal',
                'Softcore': 'Softcore'
            };
            
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.textContent = categoryDisplayNames[category] || category;
            }

            // Update game state
            gameState.selectedCategory = category;

            // Apply category colors
            applyCategoryColors(category);

            // Re-populate song list with filtered results
            populateSongList();

            console.log('[Category] Selected category:', category);
        }

        // Filter projects by selected category
        async function filterProjectsByCategory(projects) {
            if (gameState.selectedCategory === 'All') {
                return projects;
            }

            const filteredProjects = [];
            
            for (const project of projects) {
                try {
                    const response = await fetch(`/api/project/${project.folder_name}/metadata`);
                    const metadata = await response.json();
                    
                    if (response.ok && metadata) {
                        // Check if project matches selected category (default to 'Pop' if no category set)
                        const projectCategory = metadata.category || 'Pop';
                        if (projectCategory === gameState.selectedCategory) {
                            filteredProjects.push(project);
                        }
                    } else {
                        // If can't load metadata, include in 'Pop' category by default
                        if (gameState.selectedCategory === 'Pop') {
                            filteredProjects.push(project);
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                    // If error loading metadata, include in 'Pop' category by default
                    if (gameState.selectedCategory === 'Pop') {
                        filteredProjects.push(project);
                    }
                }
            }
            
            return filteredProjects;
        }

        // Load category colors configuration
        async function loadCategoryColors() {
            try {
                const response = await fetch('/category-colors.json');
                const colorConfig = await response.json();
                gameState.categoryColors = colorConfig;
                console.log('[Colors] Category colors loaded:', colorConfig);
                return colorConfig;
            } catch (error) {
                console.warn('[Colors] Failed to load category colors configuration:', error);
                // Return default color configuration
                return {
                    categories: {
                        Pop: { primary: '#FF6B9D', secondary: '#FFE1EC', accent: '#FF1F6A' },
                        Trance: { primary: '#00D4FF', secondary: '#E0F7FF', accent: '#0099CC' },
                        Brutal: { primary: '#FF4444', secondary: '#FFE6E6', accent: '#CC0000' },
                        Softcore: { primary: '#90EE90', secondary: '#F0FFF0', accent: '#32CD32' }
                    }
                };
            }
        }

        // Apply category colors to UI elements
        function applyCategoryColors(category) {
            if (!gameState.categoryColors || category === 'All') {
                // Reset to default colors if no category selected or colors not loaded
                document.documentElement.style.removeProperty('--category-primary');
                document.documentElement.style.removeProperty('--category-secondary');
                document.documentElement.style.removeProperty('--category-accent');
                
                // Reset category button styling
                if (elements.categorySelectBtn) {
                    elements.categorySelectBtn.classList.remove('active');
                }
                return;
            }

            const categoryConfig = gameState.categoryColors.categories[category];
            if (!categoryConfig) {
                console.warn(`[Colors] No color configuration found for category: ${category}`);
                return;
            }

            // Update CSS custom properties for dynamic theming
            document.documentElement.style.setProperty('--category-primary', categoryConfig.primary);
            document.documentElement.style.setProperty('--category-secondary', categoryConfig.secondary);
            document.documentElement.style.setProperty('--category-accent', categoryConfig.accent);

            // Apply colors to specific UI elements
            const activeCategory = document.querySelector('.category-dropdown-item.active');
            if (activeCategory) {
                activeCategory.style.borderColor = categoryConfig.accent;
                activeCategory.style.background = `rgba(${hexToRgb(categoryConfig.primary)}, 0.2)`;
                activeCategory.style.color = categoryConfig.accent;
            }

            // Update category select button colors
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.classList.add('active');
            }

            // Apply accent color to selected song items
            document.querySelectorAll('.song-item.selected').forEach(item => {
                item.style.borderColor = categoryConfig.accent;
                item.style.background = `linear-gradient(45deg, ${categoryConfig.primary}, ${categoryConfig.secondary})`;
            });

            console.log(`[Colors] Applied colors for category: ${category}`, categoryConfig);
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                '255, 255, 255';
        }

        // Update song genre display based on project metadata
        async function updateSongGenreDisplay(project) {
            if (!elements.songGenre) return;
            
            // Default values for dummy songs
            if (!project.folder_name || project.folder_name.includes('_test')) {
                elements.songGenre.textContent = 'Demo';
                elements.songGenre.style.background = '#FF006E'; // Default color
                return;
            }
            
            try {
                const response = await fetch(`/api/project/${project.folder_name}/metadata`);
                const metadata = await response.json();
                
                if (response.ok && metadata) {
                    const category = metadata.category || 'Pop';
                    
                    // Update genre text
                    elements.songGenre.textContent = category;
                    
                    // Update genre color based on category
                    if (gameState.categoryColors && gameState.categoryColors.categories[category]) {
                        const categoryConfig = gameState.categoryColors.categories[category];
                        elements.songGenre.style.background = categoryConfig.primary;
                    } else {
                        // Fallback colors for each category
                        const fallbackColors = {
                            'Pop': '#FF6B9D',
                            'Trance': '#00D4FF', 
                            'Brutal': '#FF4444',
                            'Softcore': '#90EE90'
                        };
                        elements.songGenre.style.background = fallbackColors[category] || '#FF006E';
                    }
                } else {
                    // Fallback to default
                    elements.songGenre.textContent = 'Pop';
                    elements.songGenre.style.background = '#FF6B9D';
                }
            } catch (error) {
                console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                // Fallback to default
                elements.songGenre.textContent = 'Pop';
                elements.songGenre.style.background = '#FF6B9D';
            }
        }

        // Setup navigation buttons - called after songs are populated
        function setupNavigationButtons() {
            // Navigation buttons - with null checks and debugging
            const navButtonRight = document.getElementById('navButtonRight');
            const navButtonLeft = document.getElementById('navButtonLeft');

            console.log('[Navigation] Setting up navigation buttons...');
            console.log('[Navigation] Right button found:', !!navButtonRight);
            console.log('[Navigation] Left button found:', !!navButtonLeft);

            if (navButtonRight) {
                navButtonRight.addEventListener('click', () => {
                    console.log('[Navigation] Right button clicked');
                    goToRightmost();
                });
            } else {
                console.warn('[Navigation] Right button not found');
            }

            if (navButtonLeft) {
                navButtonLeft.addEventListener('click', () => {
                    console.log('[Navigation] Left button clicked');
                    goToLeftmost();
                });
            } else {
                console.warn('[Navigation] Left button not found');
            }
        }

        // Navigate to rightmost song
        function goToRightmost() {
            const songs = document.querySelectorAll('.song-item');
            if (songs.length > 0) {
                const rightmostSong = songs[songs.length - 1];
                const project = {
                    folder_name: rightmostSong.dataset.projectName,
                    display_name: rightmostSong.dataset.displayName
                };
                selectSong(rightmostSong, project);
            }
        }

        // Navigate to leftmost song
        function goToLeftmost() {
            const songs = document.querySelectorAll('.song-item');
            if (songs.length > 0) {
                const leftmostSong = songs[0];
                const project = {
                    folder_name: leftmostSong.dataset.projectName,
                    display_name: leftmostSong.dataset.displayName
                };
                selectSong(leftmostSong, project);
            }
        }

        function showStartButton() {
            // Show floating start button if a real song is selected
            if (gameState.selectedProject) {
                elements.startPerformanceBtn.classList.add('visible');
                console.log('[SongSelection] Start button shown');
            } else {
                elements.startPerformanceBtn.classList.remove('visible');
                console.log('[SongSelection] Start button hidden - no real song selected');
            }
        }

        function hideStartButton() {
            elements.startPerformanceBtn.classList.remove('visible');
            console.log('[SongSelection] Start button hidden');
        }

        // Curtain transition functions
        function showCurtain() {
            elements.curtain.classList.add('active');
            setTimeout(() => {
                elements.curtain.classList.add('closing');
            }, 50);
        }

        function hideCurtain() {
            elements.curtain.classList.remove('closing');
            elements.curtain.classList.add('opening');
            
            setTimeout(() => {
                elements.curtain.classList.remove('active', 'opening');
            }, 800);
        }

        function updateCurtainText(text) {
            if (elements.curtainText) {
                elements.curtainText.textContent = text;
            }
        }

        function startPerformance() {
            if (gameState.selectedProject) {
                console.log('[SongSelection] Starting performance for:', gameState.selectedProject);
                
                // Show curtain with loading
                showCurtain();
                updateCurtainText('准备演奏...');
                
                // Hide song selection screen after curtain starts
                setTimeout(() => {
                    hideSongSelectionScreen();
                    // Start loading game behind curtain
                    loadGameWithCurtain(gameState.selectedProject);
                }, 400);
            } else {
                console.log('[SongSelection] Cannot start performance - no real song selected');
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Project loading
            // Game controls in pause menu
            elements.pauseBtn.addEventListener('click', () => {
                if (gameState.isPlaying && gameState.isPaused) {
                    // Resume
                    gameState.isPaused = false;
                    gameState.startTime = performance.now() - (gameState.currentTime * 1000);
                    gameState.audio.play();
                    gameLoop();
                } else {
                    // Start new game if not playing
                    if (!gameState.isPlaying) {
                        startGame();
                    }
                }
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.restartBtn.addEventListener('click', () => {
                if (gameState.currentProject) {
                    elements.gameOverScreen.style.display = 'none';
                    startGame();
                }
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.selectSongBtn.addEventListener('click', () => {
                // Show song selector
                elements.songSelector.classList.add('show');
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.exitBtn.addEventListener('click', () => {
                if (confirm('确定要退出游戏吗？')) {
                    location.href = '/daw';
                }
            });
            
            // Don区域点击 - 简单直接
            elements.drumDon.addEventListener('click', (e) => {
                console.log('Don被点击了');
                e.stopPropagation(); // 防止冒泡到Ka区域
                hitDrum('don');
            });
            
            // Don区域触控
            elements.drumDon.addEventListener('touchstart', (e) => {
                console.log('Don被触控了');
                e.preventDefault();
                e.stopPropagation();
                hitDrum('don');
            });
            
            // Ka区域点击（整个鼓面减去Don区域）
            elements.unifiedDrum.addEventListener('click', (e) => {
                console.log('Ka被点击了');
                hitDrum('ka');
            });
            
            // Ka区域触控
            elements.unifiedDrum.addEventListener('touchstart', (e) => {
                console.log('Ka被触控了');
                e.preventDefault();
                hitDrum('ka');
            });
            
            // Game over screen
            elements.playAgainBtn.addEventListener('click', () => {
                elements.gameOverScreen.style.display = 'none';
                startGame();
            });
            
            elements.backToSelectionBtn.addEventListener('click', () => {
                elements.gameOverScreen.style.display = 'none';
                showSongSelectionScreen();
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                
                const key = e.key.toLowerCase();
                
                // Space bar for Don (咚)
                if (key === ' ') {
                    e.preventDefault();
                    hitDrum('don');
                    return;
                }
                
                // Enter for pause menu
                if (key === 'enter') {
                    e.preventDefault();
                    if (gameState.isPlaying) {
                        // Pause game and show menu
                        gameState.isPaused = true;
                        gameState.audio.pause();
                        elements.pauseMenu.classList.add('show');
                    } else {
                        // Show song selector if no game running
                        elements.songSelector.classList.add('show');
                    }
                    return;
                }
                
                // Letter keys for Ka (咔)
                const kaKeys = ['s', 'd', 'f', 'j', 'k', 'l', 'a', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'z', 'x', 'c', 'v', 'b', 'n', 'm'];
                if (kaKeys.includes(key)) {
                    e.preventDefault();
                    hitDrum('ka');
                    return;
                }
                
                // Special shortcuts
                if (key === 'escape') {
                    e.preventDefault();
                    // Hide any open menus
                    elements.pauseMenu.classList.remove('show');
                    elements.songSelector.classList.remove('show');
                }
            });
            
            // Prevent context menu on drum
            elements.unifiedDrum.addEventListener('contextmenu', e => e.preventDefault());
            
            // Setup song selection screen listeners
            setupSongSelectionListeners();
        }

        // Create SVG icons for don and ka notes
        function createDonSVG() {
            return `
                <svg width="30" height="30" viewBox="0 0 100 100" style="pointer-events: none;">
                    <!-- Mondrian-style don icon - square with geometric divisions -->
                    <rect x="10" y="10" width="80" height="80" fill="#FFFFFF" stroke="#000000" stroke-width="4"/>
                    <rect x="10" y="10" width="40" height="40" fill="#FF006E"/>
                    <rect x="50" y="10" width="40" height="40" fill="#FF6B9D"/>
                    <rect x="10" y="50" width="40" height="40" fill="#FF6B9D"/>
                    <rect x="50" y="50" width="40" height="40" fill="#FFFFFF"/>
                    <!-- Central geometric element -->
                    <circle cx="50" cy="50" r="12" fill="#000000"/>
                    <circle cx="50" cy="50" r="6" fill="#FFFFFF"/>
                </svg>
            `;
        }

        function createKaSVG() {
            return `
                <svg width="30" height="30" viewBox="0 0 100 100" style="pointer-events: none;">
                    <!-- Mondrian-style ka icon - square with different geometric divisions -->
                    <rect x="10" y="10" width="80" height="80" fill="#FFFFFF" stroke="#000000" stroke-width="4"/>
                    <rect x="10" y="10" width="30" height="30" fill="#8338EC"/>
                    <rect x="40" y="10" width="50" height="30" fill="#B366EC"/>
                    <rect x="10" y="40" width="50" height="50" fill="#B366EC"/>
                    <rect x="60" y="40" width="30" height="50" fill="#8338EC"/>
                    <!-- Central cross element -->
                    <rect x="45" y="20" width="10" height="60" fill="#000000"/>
                    <rect x="20" y="45" width="60" height="10" fill="#000000"/>
                </svg>
            `;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>