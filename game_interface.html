<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大鼓达人 - 演奏模式</title>
    <link rel="stylesheet" href="game_styles.css">
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Mondrian Grid Background -->
        <svg class="mondrian-grid" viewBox="0 0 1920 1080">
            <!-- Main grid lines -->
            <line x1="400" y1="0" x2="400" y2="1080" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="800" y1="0" x2="800" y2="1080" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            <line x1="1200" y1="0" x2="1200" y2="1080" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="0" y1="200" x2="1920" y2="200" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            <line x1="0" y1="500" x2="1920" y2="500" stroke="#FFFFFF" stroke-width="8" opacity="0.4"/>
            <line x1="0" y1="800" x2="1920" y2="800" stroke="#FFFFFF" stroke-width="6" opacity="0.3"/>
            
            <!-- Vaporwave color blocks -->
            <rect x="0" y="0" width="400" height="200" fill="#FF006E" opacity="0.15"/>
            <rect x="400" y="0" width="400" height="200" fill="#8338EC" opacity="0.15"/>
            <rect x="800" y="0" width="400" height="200" fill="#3A86FF" opacity="0.15"/>
            <rect x="1200" y="0" width="720" height="200" fill="#06FFA5" opacity="0.15"/>
            
            <rect x="0" y="200" width="400" height="300" fill="#FFBE0B" opacity="0.15"/>
            <rect x="400" y="200" width="800" height="300" fill="#FF006E" opacity="0.1"/>
            <rect x="1200" y="200" width="720" height="300" fill="#8338EC" opacity="0.15"/>
            
            <rect x="0" y="500" width="800" height="300" fill="#3A86FF" opacity="0.15"/>
            <rect x="800" y="500" width="400" height="300" fill="#06FFA5" opacity="0.15"/>
            <rect x="1200" y="500" width="720" height="300" fill="#FFBE0B" opacity="0.15"/>
            
            <rect x="0" y="800" width="400" height="280" fill="#8338EC" opacity="0.15"/>
            <rect x="400" y="800" width="400" height="280" fill="#FF006E" opacity="0.15"/>
            <rect x="800" y="800" width="400" height="280" fill="#3A86FF" opacity="0.15"/>
            <rect x="1200" y="800" width="720" height="280" fill="#06FFA5" opacity="0.15"/>
        </svg>
        
        <!-- Chinese Elements Background -->
        <svg class="chinese-elements" viewBox="0 0 1920 1080">
            <!-- Auspicious Clouds (祥云) - Floating foreground elements -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.4">
                <!-- Traditional Chinese cloud patterns -->
                <g transform="translate(500,150)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 15,15 Q 25,5 35,15 Q 45,5 55,15 Q 65,10 75,20 Q 70,25 60,25 Q 50,30 40,25 Q 30,30 20,25 Q 10,25 15,15 Z" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <g transform="translate(1200,180) scale(0.8)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 15,15 Q 25,5 35,15 Q 45,5 55,15 Q 65,10 75,20 Q 70,25 60,25 Q 50,30 40,25 Q 30,30 20,25 Q 10,25 15,15 Z" stroke="#FFFFFF" stroke-width="1"/>
                </g>
                
                <!-- Bottom clouds -->
                <g transform="translate(300,900) scale(1.2)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.08"/>
                </g>
                
                <g transform="translate(1400,880) scale(0.9)">
                    <path d="M 0,20 Q -10,10 0,0 Q 20,-5 40,0 Q 60,-5 80,0 Q 90,10 80,20 Q 90,30 80,40 Q 60,45 40,40 Q 20,45 0,40 Q -10,30 0,20 Z" fill="#FFFFFF" opacity="0.08"/>
                </g>
            </g>
            
            <!-- Traditional Chinese Decorative Elements -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.3">
                <!-- Chinese Knot (中国结) patterns in corners -->
                <g transform="translate(100,100)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(1820,100) rotate(90)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(100,980) rotate(270)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
                
                <g transform="translate(1820,980) rotate(180)">
                    <circle cx="0" cy="0" r="8" stroke="#FFFFFF" stroke-width="2"/>
                    <circle cx="0" cy="0" r="16" stroke="#FFFFFF" stroke-width="1"/>
                    <path d="M -12,-12 L 12,12 M 12,-12 L -12,12" stroke="#FFFFFF" stroke-width="1"/>
                    <circle cx="0" cy="0" r="4" fill="#FFFFFF" opacity="0.2"/>
                </g>
            </g>
            
            <!-- Mountain silhouettes with varying heights -->
            <g fill="#FFFFFF" opacity="0.15">
                <polygon points="50,1080 150,900 250,1080"/>
                <polygon points="200,1080 320,850 440,1080"/>
                <polygon points="1480,1080 1600,920 1720,1080"/>
                <polygon points="1670,1080 1770,880 1870,1080"/>
                <!-- Layered mountains for depth -->
                <polygon points="100,1080 200,950 300,1080" opacity="0.8"/>
                <polygon points="1520,1080 1650,940 1780,1080" opacity="0.8"/>
                <!-- Distant mountains -->
                <polygon points="600,1080 700,980 800,1080" opacity="0.6"/>
                <polygon points="1000,1080 1100,970 1200,1080" opacity="0.6"/>
            </g>
            
            <!-- Bamboo Grove (竹林) -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.2">
                <g transform="translate(80,600)">
                    <line x1="0" y1="0" x2="0" y2="480" stroke="#FFFFFF" stroke-width="3"/>
                    <line x1="15" y1="50" x2="15" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="30" y1="30" x2="30" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="45" y1="70" x2="45" y2="480" stroke="#FFFFFF" stroke-width="2"/>
                    <!-- Bamboo segments -->
                    <line x1="-3" y1="100" x2="3" y2="100" stroke="#FFFFFF"/>
                    <line x1="-3" y1="200" x2="3" y2="200" stroke="#FFFFFF"/>
                    <line x1="-3" y1="300" x2="3" y2="300" stroke="#FFFFFF"/>
                    <line x1="-3" y1="400" x2="3" y2="400" stroke="#FFFFFF"/>
                    <!-- Bamboo leaves -->
                    <path d="M 5,150 Q 15,145 20,155 Q 15,165 5,160" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 35,250 Q 45,245 50,255 Q 45,265 35,260" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M 20,350 Q 30,345 35,355 Q 30,365 20,360" fill="#FFFFFF" opacity="0.1"/>
                </g>
                
                <g transform="translate(1800,500)">
                    <line x1="0" y1="0" x2="0" y2="580" stroke="#FFFFFF" stroke-width="3"/>
                    <line x1="-15" y1="80" x2="-15" y2="580" stroke="#FFFFFF" stroke-width="2"/>
                    <line x1="-30" y1="60" x2="-30" y2="580" stroke="#FFFFFF" stroke-width="2"/>
                    <!-- Bamboo segments -->
                    <line x1="-3" y1="150" x2="3" y2="150" stroke="#FFFFFF"/>
                    <line x1="-3" y1="280" x2="3" y2="280" stroke="#FFFFFF"/>
                    <line x1="-3" y1="410" x2="3" y2="410" stroke="#FFFFFF"/>
                    <!-- Bamboo leaves -->
                    <path d="M -35,200 Q -25,195 -20,205 Q -25,215 -35,210" fill="#FFFFFF" opacity="0.1"/>
                    <path d="M -18,330 Q -8,325 -3,335 Q -8,345 -18,340" fill="#FFFFFF" opacity="0.1"/>
                </g>
            </g>
            
            <!-- Flowing Water (流水) -->
            <g fill="none" stroke="#FFFFFF" stroke-width="1.5" opacity="0.2">
                <path d="M 200,900 Q 300,880 400,900 Q 500,920 600,900" stroke="#FFFFFF" stroke-width="2"/>
                <path d="M 210,910 Q 310,890 410,910 Q 510,930 610,910" stroke="#FFFFFF" stroke-width="1.5"/>
                <path d="M 220,920 Q 320,900 420,920 Q 520,940 620,920" stroke="#FFFFFF" stroke-width="1"/>
                
                <path d="M 1300,950 Q 1400,930 1500,950 Q 1600,970 1700,950" stroke="#FFFFFF" stroke-width="2"/>
                <path d="M 1310,960 Q 1410,940 1510,960 Q 1610,980 1710,960" stroke="#FFFFFF" stroke-width="1.5"/>
                
                <!-- Additional water streams through mountains -->
                <path d="M 700,1000 Q 800,980 900,1000 Q 1000,1020 1100,1000" stroke="#FFFFFF" stroke-width="1.5" opacity="0.15"/>
                <path d="M 710,1010 Q 810,990 910,1010 Q 1010,1030 1110,1010" stroke="#FFFFFF" stroke-width="1" opacity="0.15"/>
            </g>
            
            <!-- Lotus Patterns (荷花) - For future hit effects -->
            <g fill="none" stroke="#FFFFFF" stroke-width="1" opacity="0.3">
                <g transform="translate(960,300) scale(0.5)">
                    <path d="M 0,20 Q -10,10 -15,0 Q -10,-10 0,-15 Q 10,-10 15,0 Q 10,10 0,20 Z" fill="#FFFFFF" opacity="0.05"/>
                    <path d="M 0,15 Q -8,5 -12,-5 Q -5,-12 0,-10 Q 5,-12 12,-5 Q 8,5 0,15 Z" fill="#FFFFFF" opacity="0.05"/>
                    <circle cx="0" cy="0" r="3" fill="#FFFFFF" opacity="0.1"/>
                </g>
                
                <g transform="translate(960,780) scale(0.4)">
                    <path d="M 0,20 Q -10,10 -15,0 Q -10,-10 0,-15 Q 10,-10 15,0 Q 10,10 0,20 Z" fill="#FFFFFF" opacity="0.05"/>
                    <path d="M 0,15 Q -8,5 -12,-5 Q -5,-12 0,-10 Q 5,-12 12,-5 Q 8,5 0,15 Z" fill="#FFFFFF" opacity="0.05"/>
                    <circle cx="0" cy="0" r="3" fill="#FFFFFF" opacity="0.1"/>
                </g>
            </g>
            
            <!-- Geometric circles -->
            <g fill="none" stroke="#FFFFFF" stroke-width="2" opacity="0.25">
                <circle cx="1700" cy="250" r="30"/>
                <circle cx="220" cy="850" r="25"/>
                <circle cx="1750" cy="700" r="35"/>
                <circle cx="170" cy="300" r="20"/>
            </g>
        </svg>

        <!-- Loading Screen -->
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">加载游戏中...</div>
        </div>

        <!-- Curtain Transition Effect -->
        <div class="curtain" id="curtain">
            <div class="curtain-left"></div>
            <div class="curtain-right"></div>
        </div>

        <!-- Song Selector (Floating) -->
        <div class="song-selector" id="songSelector">
            <select id="projectSelect">
                <option value="">-- 选择歌曲 --</option>
            </select>
            <button id="loadGameBtn">载入</button>
        </div>

        <!-- Score Display -->
        <div class="score-bar" id="scoreBar">得分: 0</div>

        <!-- Spirit System -->
        <div class="spirit-system" id="spiritSystem">
            <div class="spirit-lines" id="spiritLines">
                <!-- 40 spirit lines for denser DDR-style display (2.5% per line) -->
                <div class="spirit-line" data-threshold="2.5"></div>
                <div class="spirit-line" data-threshold="5"></div>
                <div class="spirit-line" data-threshold="7.5"></div>
                <div class="spirit-line" data-threshold="10"></div>
                <div class="spirit-line" data-threshold="12.5"></div>
                <div class="spirit-line" data-threshold="15"></div>
                <div class="spirit-line" data-threshold="17.5"></div>
                <div class="spirit-line" data-threshold="20"></div>
                <div class="spirit-line" data-threshold="22.5"></div>
                <div class="spirit-line" data-threshold="25"></div>
                <div class="spirit-line" data-threshold="27.5"></div>
                <div class="spirit-line" data-threshold="30"></div>
                <div class="spirit-line" data-threshold="32.5"></div>
                <div class="spirit-line" data-threshold="35"></div>
                <div class="spirit-line" data-threshold="37.5"></div>
                <div class="spirit-line" data-threshold="40"></div>
                <div class="spirit-line" data-threshold="42.5"></div>
                <div class="spirit-line" data-threshold="45"></div>
                <div class="spirit-line" data-threshold="47.5"></div>
                <div class="spirit-line" data-threshold="50"></div>
                <div class="spirit-line" data-threshold="52.5"></div>
                <div class="spirit-line" data-threshold="55"></div>
                <div class="spirit-line" data-threshold="57.5"></div>
                <div class="spirit-line" data-threshold="60"></div>
                <div class="spirit-line" data-threshold="62.5"></div>
                <div class="spirit-line" data-threshold="65"></div>
                <div class="spirit-line" data-threshold="67.5"></div>
                <div class="spirit-line" data-threshold="70"></div>
                <div class="spirit-line" data-threshold="72.5"></div>
                <div class="spirit-line" data-threshold="75"></div>
                <div class="spirit-line" data-threshold="77.5"></div>
                <div class="spirit-line" data-threshold="80"></div>
                <div class="spirit-line" data-threshold="82.5"></div>
                <div class="spirit-line" data-threshold="85"></div>
                <div class="spirit-line" data-threshold="87.5"></div>
                <div class="spirit-line" data-threshold="90"></div>
                <div class="spirit-line" data-threshold="92.5"></div>
                <div class="spirit-line" data-threshold="95"></div>
                <div class="spirit-line" data-threshold="97.5"></div>
                <div class="spirit-line" data-threshold="100"></div>
            </div>
            <!-- Spirit Label (Child of spirit-system) -->
            <div class="spirit-label" id="spiritLabel">灵: 0%</div>
        </div>

        <!-- Pause Menu (Enter key popup) -->
        <div class="pause-menu" id="pauseMenu">
            <div class="pause-menu-content">
                <h2>游戏菜单</h2>
                
                <!-- Settings Section -->
                <div class="pause-menu-settings">
                    <h3>游戏设置</h3>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseTouchDrumToggle">
                            <div class="setting-checkbox" id="pauseTouchDrumCheckbox"></div>
                            <span>显示触控鼓</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseHitTargetToggle">
                            <div class="setting-checkbox" id="pauseHitTargetCheckbox"></div>
                            <span>显示命中线</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-toggle" id="pauseBannerToggle">
                            <div class="setting-checkbox" id="pauseBannerCheckbox"></div>
                            <span>显示顶部横幅</span>
                        </div>
                    </div>
                </div>
                
                <button class="pause-menu-btn" id="pauseBtn">继续</button>
                <button class="pause-menu-btn" id="restartBtn">重新开始</button>
                <button class="pause-menu-btn" id="selectSongBtn">选择歌曲</button>
                <button class="pause-menu-btn" id="exitBtn">退出</button>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-area">
            <!-- Song Name Display - Simple Text Above Spirit System -->
            <div class="song-name-simple" id="songNameSimple">
                <div class="title-cloud-decoration">
                    <img src="/static/title-cloud.svg" alt="Cloud Decoration" />
                </div>
                <span id="songNameText">待加载</span>
            </div>
            
            <!-- Background Image Container -->
            <div class="game-background" id="gameBackground"></div>
            
            <!-- Top Banner (Above background) -->
            <div class="top-banner" id="topBanner"></div>
            
            <!-- Character Display (Above game track) -->
            <div class="character-display" id="characterDisplay">
                <img id="characterImage" alt="Character" src="/static/ghost-drum.svg" />
            </div>
            
            <!-- Game Track Container (Don + Beat Track) -->
            <div class="game-track-container">
                <!-- Don Character Display (Left of beat track) -->
                <div class="don-display">
                    <div class="don-face" id="donFace">
                        <div class="don-combo" id="donCombo">0</div>
                    </div>
                </div>

                <!-- Beat Track -->
                <div class="beat-track">
                    <div class="beat-grid" id="beatGrid">
                        <!-- Beat grid lines will be generated here -->
                    </div>
                    <div class="hit-target"></div>
                    <!-- Target Drum -->
                    <div class="target-drum" id="targetDrum"></div>
                    <div class="notes-container" id="notesContainer">
                        <!-- Beat notes will be generated here -->
                    </div>
                </div>
            </div>


            <!-- Drum Kit -->
            <div class="drum-kit" id="drumKit">
                <div class="drum unified" id="unifiedDrum">
                    <!-- Don区域 - 独立元素 -->
                    <div class="drum-don" id="drumDon">
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div class="game-over" id="gameOverScreen" style="display: none;">
            <h2>出成绩啦！</h2>
            <div class="final-stats">
                <div class="stat-item">
                    <div class="stat-value" id="finalScore">0</div>
                    <div class="stat-label">最终得分</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="maxCombo">0</div>
                    <div class="stat-label">最大连击</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalAccuracy">0%</div>
                    <div class="stat-label">准确率</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalSpirit">0%</div>
                    <div class="stat-label">最终灵魂值</div>
                </div>
            </div>
            
            <!-- Detailed Hit Statistics -->
            <div class="hit-stats">
                <div class="hit-stat-item perfect">
                    <div class="hit-stat-count" id="finalPerfectHits">0</div>
                    <div class="hit-stat-label">优</div>
                    <div class="hit-stat-score" id="perfectScore">0分</div>
                </div>
                <div class="hit-stat-item good">
                    <div class="hit-stat-count" id="finalGoodHits">0</div>
                    <div class="hit-stat-label">良</div>
                    <div class="hit-stat-score" id="goodScore">0分</div>
                </div>
                <div class="hit-stat-item miss">
                    <div class="hit-stat-count" id="finalMissedHits">0</div>
                    <div class="hit-stat-label">不可</div>
                    <div class="hit-stat-score" id="missScore">0分</div>
                </div>
            </div>
            
            <!-- Action buttons -->
            <div class="game-over-actions">
                <button class="action-btn restart-btn" id="playAgainBtn">再来一遍</button>
                <button class="action-btn back-btn" id="backToSelectionBtn">返回选曲</button>
            </div>
        </div>
    </div>

    <!-- Song Selection Screen -->
    <div class="song-selection-screen" id="songSelectionScreen" style="display: none;">
        <!-- Main Content Area -->
        <div class="selection-main">
            <!-- Character Display -->
            <div class="character-panel">
                <div class="character-avatar">
                    <img src="/static/ghost-drum.svg" alt="Character" id="selectionCharacter" />
                </div>
                <div class="avatar-info">
                    <div class="avatar-name-stamp">
                        <div class="stamp-line">幽灵</div>
                        <div class="stamp-line">大鼓</div>
                    </div>
                </div>
            </div>

            <!-- Song Info -->
            <div class="song-info-panel">
                <div class="song-info-frame" id="songInfoFrame">
                    <div class="song-icon">
                        <div class="song-symbol">♪</div>
                    </div>
                    <div class="selected-song-name" id="selectedSongName">请选择歌曲</div>
                    <div class="song-genre" id="songGenre">J-POP</div>
                </div>
            </div>

            <!-- Stats Panel -->
            <div class="stats-panel">
                <div class="stats-title">本曲成绩</div>
                <div class="stat-row">
                    <span class="stat-label">最佳成绩</span>
                    <span class="stat-value" id="bestScore">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">最高准确率</span>
                    <span class="stat-value" id="bestAccuracy">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">最大连击数</span>
                    <span class="stat-value" id="bestCombo">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">最高灵魂值</span>
                    <span class="stat-value" id="bestSpirit">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">总游戏次数</span>
                    <span class="stat-value" id="totalGames">-</span>
                </div>
            </div>

            <!-- Category Selection Button -->
            <div class="category-select-btn" id="categorySelectBtn">
                全部
            </div>

            <!-- Category Dropdown -->
            <div class="category-dropdown" id="categoryDropdown">
                <div class="category-dropdown-item active" data-category="All">全部</div>
                <div class="category-dropdown-item" data-category="Pop">Pop</div>
                <div class="category-dropdown-item" data-category="Trance">Trance</div>
                <div class="category-dropdown-item" data-category="Brutal">Brutal</div>
                <div class="category-dropdown-item" data-category="Softcore">Softcore</div>
            </div>

            <!-- Floating Start Performance Button -->
            <div class="start-performance-btn" id="startPerformanceBtn">
                开始演奏
            </div>
        </div>


        <!-- Song List -->
        <div class="song-list-container">
            <div class="song-list" id="songList">
                <!-- Songs will be populated here dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            score: 0,
            combo: 0,
            maxCombo: 0,
            totalNotes: 0,
            hitNotes: 0,
            perfectHits: 0,
            goodHits: 0,
            missedHits: 0,
            perfectScore: 0,   // Score from perfect hits
            goodScore: 0,      // Score from good hits
            comboScore: 0,     // Score from combo bonuses
            isPlaying: false,
            isPaused: false,
            currentProject: null,
            notes: [],
            currentTime: 0,
            duration: 0,
            audio: null,
            startTime: null,
            animationId: null,
            audioOffset: 0.0,  // BPM detection offset for alignment
            spiritValue: 0,    // Spirit value (0-100%)
            spiritCombo: 0,    // Current combo for spirit calculation
            maxSpiritCombo: 0, // Maximum spirit combo achieved
            challengeFailed: false, // Whether challenge failed
            currentProjectName: null, // Current project name for reloading images
            selectedProject: null, // Selected project in song selection screen
            selectedCategory: 'All', // Selected category for filtering
            categoryColors: null // Category color configuration
        };

        // Particle system
        let particles = [];

        // Spirit System Functions
        function updateSpiritValue(hitType) {
            if (hitType === 'miss') {
                // Miss reduces spirit value (1.5x original)
                gameState.spiritValue = Math.max(0, gameState.spiritValue - 7.5);
                gameState.spiritCombo = 0;
            } else {
                // Successful hit increases spirit combo
                gameState.spiritCombo++;
                gameState.maxSpiritCombo = Math.max(gameState.maxSpiritCombo, gameState.spiritCombo);
                
                // Calculate spirit gain based on hit type and combo
                let spiritGain;
                
                if (hitType === 'perfect') {
                    // Perfect hit: ~1.67% base + combo bonus
                    spiritGain = 1.67;
                } else {
                    // Good hit: ~1.33% base + combo bonus  
                    spiritGain = 1.33;
                }
                
                // Combo bonus: more combo = faster spirit gain
                if (gameState.spiritCombo >= 10) {
                    spiritGain += Math.floor(gameState.spiritCombo / 15); // Reduced combo bonus
                }
                
                // Backend value can exceed 85%, but frontend display caps at 85%
                gameState.spiritValue += spiritGain;
            }
            
            updateSpiritDisplay();
            updateCharacterDisplay(); // Update character based on spirit value
            updateBannerDisplay(); // Update banner based on spirit value
            checkChallengeStatus();
        }

        function updateSpiritDisplay() {
            // Update spirit label with actual value
            spiritElements.label.textContent = `灵: ${Math.round(gameState.spiritValue)}%`;
            
            // Reset all lines to inactive state
            spiritElements.lines.forEach(line => {
                line.className = 'spirit-line';
            });
            
            // Check if we're in rainbow mode (85%+)
            const isRainbowMode = gameState.spiritValue >= 85;
            
            // Add or remove rainbow mode class from container
            if (isRainbowMode) {
                spiritElements.system.classList.add('rainbow-mode');
            } else {
                spiritElements.system.classList.remove('rainbow-mode');
            }
            
            // Activate lines based on spirit value
            spiritElements.lines.forEach(line => {
                const threshold = parseFloat(line.dataset.threshold);
                if (gameState.spiritValue >= threshold) {
                    if (isRainbowMode) {
                        // 85%+: All active lines become thick rainbow lines
                        line.classList.add('active-rainbow');
                    } else if (threshold < 60) {
                        // Below 60%: Yellow thin lines
                        line.classList.add('active-yellow');
                    } else {
                        // 60-84%: Orange thin lines
                        line.classList.add('active-orange');
                    }
                }
            });
        }

        function checkChallengeStatus() {
            // Check if challenge failed (spirit below 60% at song end)
            if (gameState.currentTime >= gameState.duration - 1) {
                if (gameState.spiritValue < 60 && !gameState.challengeFailed) {
                    gameState.challengeFailed = true;
                    showChallengeFailed();
                }
            }
        }

        function showChallengeFailed() {
            // Create challenge failed message
            const judgment = document.createElement('div');
            judgment.className = 'judgment miss';
            judgment.textContent = '挑战失败';
            judgment.style.fontSize = '24px';
            judgment.style.color = '#FF6B6B';
            
            document.querySelector('.game-area').appendChild(judgment);
            
            // Remove after delay
            setTimeout(() => {
                if (judgment.parentNode) {
                    judgment.remove();
                }
            }, 3000);
        }

        function resetSpiritSystem() {
            gameState.spiritValue = 0;
            gameState.spiritCombo = 0;
            gameState.maxSpiritCombo = 0;
            gameState.challengeFailed = false;
            
            // Reset visual display - all lines to inactive
            spiritElements.lines.forEach(line => {
                line.className = 'spirit-line';
            });
            spiritElements.label.textContent = '灵: 0%';
            spiritElements.system.classList.remove('rainbow-mode');
            
            // Update character and banner to unsatisfied state
            updateCharacterDisplay();
            updateBannerDisplay();
        }

        // Game settings
        const settings = {
            scrollSpeed: 300, // pixels per second
            hitTargetX: 150,
            noteSpawnX: window.innerWidth,
            hitWindow: {
                perfect: 0.05, // 50ms
                good: 0.1,     // 100ms
                miss: 0.15     // 150ms
            },
            scoring: {
                perfect: 1000,
                good: 500,
                miss: 0
            },
            showBanner: false // Default: don't show banner
        };

        // DOM elements - will be initialized in initGame
        let elements = {};
        let donElements = {};
        let spiritElements = {};

        // Initialize game
        async function initGame() {
            // Initialize DOM elements
            elements = {
                loadingScreen: document.getElementById('loadingScreen'),
                projectSelect: document.getElementById('projectSelect'),
                loadGameBtn: document.getElementById('loadGameBtn'),
                songSelector: document.getElementById('songSelector'),
                scoreBar: document.getElementById('scoreBar'),
                pauseMenu: document.getElementById('pauseMenu'),
                pauseBtn: document.getElementById('pauseBtn'),
                restartBtn: document.getElementById('restartBtn'),
                selectSongBtn: document.getElementById('selectSongBtn'),
                exitBtn: document.getElementById('exitBtn'),
                notesContainer: document.getElementById('notesContainer'),
                beatGrid: document.getElementById('beatGrid'),
                unifiedDrum: document.getElementById('unifiedDrum'),
                drumDon: document.getElementById('drumDon'),
                drumKit: document.getElementById('drumKit'),
                pauseTouchDrumToggle: document.getElementById('pauseTouchDrumToggle'),
                pauseTouchDrumCheckbox: document.getElementById('pauseTouchDrumCheckbox'),
                pauseHitTargetToggle: document.getElementById('pauseHitTargetToggle'),
                pauseHitTargetCheckbox: document.getElementById('pauseHitTargetCheckbox'),
                pauseBannerToggle: document.getElementById('pauseBannerToggle'),
                pauseBannerCheckbox: document.getElementById('pauseBannerCheckbox'),
                gameOverScreen: document.getElementById('gameOverScreen'),
                finalScore: document.getElementById('finalScore'),
                maxCombo: document.getElementById('maxCombo'),
                finalAccuracy: document.getElementById('finalAccuracy'),
                finalSpirit: document.getElementById('finalSpirit'),
                finalPerfectHits: document.getElementById('finalPerfectHits'),
                finalGoodHits: document.getElementById('finalGoodHits'),
                finalMissedHits: document.getElementById('finalMissedHits'),
                perfectScore: document.getElementById('perfectScore'),
                goodScore: document.getElementById('goodScore'),
                missScore: document.getElementById('missScore'),
                playAgainBtn: document.getElementById('playAgainBtn'),
                backToSelectionBtn: document.getElementById('backToSelectionBtn'),
                gameBackground: document.getElementById('gameBackground'),
                characterDisplay: document.getElementById('characterDisplay'),
                characterImage: document.getElementById('characterImage'),
                topBanner: document.getElementById('topBanner'),
                songNameText: document.getElementById('songNameText'),
                songNameSimple: document.getElementById('songNameSimple'),
                // Song Selection Screen elements
                songSelectionScreen: document.getElementById('songSelectionScreen'),
                selectedSongName: document.getElementById('selectedSongName'),
                songGenre: document.getElementById('songGenre'),
                songList: document.getElementById('songList'),
                selectionCharacter: document.getElementById('selectionCharacter'),
                songInfoFrame: document.getElementById('songInfoFrame'),
                startPerformanceBtn: document.getElementById('startPerformanceBtn'),
                categorySelectBtn: document.getElementById('categorySelectBtn'),
                categoryDropdown: document.getElementById('categoryDropdown'),
                // Curtain elements
                curtain: document.getElementById('curtain'),
                curtainText: document.getElementById('curtainText')
            };

            donElements = {
                donFace: document.getElementById('donFace'),
                donCombo: document.getElementById('donCombo')
            };

            spiritElements = {
                system: document.getElementById('spiritSystem'),
                lines: document.querySelectorAll('.spirit-line'),
                label: document.getElementById('spiritLabel')
            };

            await loadProjects();
            await loadCategoryColors();
            await loadGameStats();
            elements.loadingScreen.style.display = 'none';
            
            // Show song selection screen directly instead of song selector
            showSongSelectionScreen();
            
            setupEventListeners();
            initPauseMenuToggles();
        }

        // Initialize pause menu toggles functionality
        function initPauseMenuToggles() {
            // Initialize touch drum toggle
            const touchDrumEnabled = localStorage.getItem('touchDrumEnabled') !== 'false';
            setTouchDrumEnabled(touchDrumEnabled);
            updatePauseMenuCheckbox(elements.pauseTouchDrumCheckbox, touchDrumEnabled);

            // Initialize hit target toggle
            const hitTargetEnabled = localStorage.getItem('hitTargetEnabled') === 'true';
            setHitTargetEnabled(hitTargetEnabled);
            updatePauseMenuCheckbox(elements.pauseHitTargetCheckbox, hitTargetEnabled);

            // Add click event listeners
            elements.pauseTouchDrumToggle.addEventListener('click', () => {
                const currentState = !elements.pauseTouchDrumCheckbox.classList.contains('checked');
                setTouchDrumEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseTouchDrumCheckbox, currentState);
                localStorage.setItem('touchDrumEnabled', currentState);
            });

            elements.pauseHitTargetToggle.addEventListener('click', () => {
                const currentState = !elements.pauseHitTargetCheckbox.classList.contains('checked');
                setHitTargetEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseHitTargetCheckbox, currentState);
                localStorage.setItem('hitTargetEnabled', currentState);
            });

            // Initialize banner toggle
            const bannerEnabled = localStorage.getItem('bannerEnabled') === 'true';
            setBannerEnabled(bannerEnabled);
            updatePauseMenuCheckbox(elements.pauseBannerCheckbox, bannerEnabled);

            elements.pauseBannerToggle.addEventListener('click', () => {
                console.log('[Banner] Toggle button clicked');
                const currentState = !elements.pauseBannerCheckbox.classList.contains('checked');
                console.log('[Banner] Current state will be:', currentState);
                setBannerEnabled(currentState);
                updatePauseMenuCheckbox(elements.pauseBannerCheckbox, currentState);
                localStorage.setItem('bannerEnabled', currentState);
                console.log('[Banner] Settings updated');
            });
        }

        // Set touch drum enabled/disabled state
        function setTouchDrumEnabled(enabled) {
            if (enabled) {
                elements.drumKit.classList.remove('hidden');
            } else {
                elements.drumKit.classList.add('hidden');
            }
        }

        // Set hit target enabled/disabled state
        function setHitTargetEnabled(enabled) {
            const hitTarget = document.querySelector('.hit-target');
            if (enabled) {
                hitTarget.classList.add('visible');
            } else {
                hitTarget.classList.remove('visible');
            }
        }

        // Set banner enabled/disabled state
        function setBannerEnabled(enabled) {
            console.log('[Banner] setBannerEnabled called with:', enabled);
            settings.showBanner = enabled;
            
            if (elements.topBanner) {
                if (enabled) {
                    elements.topBanner.style.display = 'block';
                    console.log('[Banner] Banner display set to block');
                    
                    // Update banner display with current spirit value
                    updateBannerDisplay();
                } else {
                    elements.topBanner.style.display = 'none';
                    console.log('[Banner] Banner display set to none');
                }
            } else {
                console.warn('[Banner] topBanner element not found');
            }
        }

        // Update pause menu checkbox visual state
        function updatePauseMenuCheckbox(checkbox, enabled) {
            if (enabled) {
                checkbox.classList.add('checked');
            } else {
                checkbox.classList.remove('checked');
            }
        }

        // Load available projects
        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const data = await response.json();
                
                if (data.status === 'success') {
                    elements.projectSelect.innerHTML = '<option value="">-- 请选择歌曲 --</option>';
                    data.projects.forEach(project => {
                        const option = document.createElement('option');
                        // Use folder_name as value for backend compatibility
                        option.value = project.folder_name;
                        // Display the friendly display_name to user
                        option.textContent = project.display_name;
                        // Store both values for potential future use
                        option.dataset.folderName = project.folder_name;
                        option.dataset.displayName = project.display_name;
                        elements.projectSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to load projects:', error);
            }
        }

        // Load game statistics from database
        async function loadGameStats() {
            try {
                const response = await fetch('/api/game-stats');
                const data = await response.json();
                
                if (data.overall_stats) {
                    // Update overall stats with best values only
                    const stats = data.overall_stats;
                    document.getElementById('totalGames').textContent = stats.total_games || '0';
                    document.getElementById('bestScore').textContent = stats.best_score ? stats.best_score.toLocaleString() + '点' : '0点';
                    document.getElementById('bestAccuracy').textContent = stats.best_accuracy ? stats.best_accuracy + '%' : '0%';
                    document.getElementById('bestCombo').textContent = stats.best_combo ? stats.best_combo + '回' : '0回';
                    document.getElementById('bestSpirit').textContent = stats.best_spirit ? stats.best_spirit + '%' : '0%';
                }
                
                console.log('游戏统计数据加载成功');
            } catch (error) {
                console.error('加载游戏统计数据失败:', error);
                // Show error message
                document.getElementById('totalGames').textContent = '错误';
                document.getElementById('bestScore').textContent = '加载失败';
            }
        }

        // Load project images (background and character)
        function loadProjectImages(projectName, projectImages) {
            if (!projectImages) {
                console.log('[Images] No images data provided');
                return;
            }

            // Load background image
            if (elements.gameBackground) {
                const sceneImages = projectImages.scene;
                if (sceneImages && sceneImages.background) {
                    const imageUrl = `/api/project/${projectName}/images/${sceneImages.background}`;
                    console.log('[Background] Loading background image:', imageUrl);
                    
                    const img = new Image();
                    img.onload = function() {
                        elements.gameBackground.style.backgroundImage = `url('${imageUrl}')`;
                        elements.gameBackground.classList.add('loaded');
                        console.log('[Background] Background image loaded successfully');
                    };
                    img.onerror = function() {
                        console.warn('[Background] Failed to load background image:', imageUrl);
                    };
                    img.src = imageUrl;
                } else {
                    console.log('[Background] No scene background image found');
                }
            }

            // Use the cute Chinese drum SVG as character image
            if (elements.characterImage) {
                console.log('[Character] Using cute Chinese drum SVG');
                updateCharacterDisplay();
            }

            // Load banner images and store URLs (always load for potential use)
            if (elements.topBanner && projectImages.banner) {
                const bannerImages = projectImages.banner;
                
                // Store banner image URLs in gameState for switching
                gameState.bannerImages = {
                    unsatisfied: null,
                    satisfied: null
                };

                // Preload unsatisfied banner image
                if (bannerImages.unsatisfied) {
                    const unsatisfiedUrl = `/api/project/${projectName}/images/${bannerImages.unsatisfied}`;
                    const unsatisfiedImg = new Image();
                    unsatisfiedImg.onload = function() {
                        gameState.bannerImages.unsatisfied = unsatisfiedUrl;
                        console.log('[Banner] Unsatisfied banner image loaded');
                        // Set initial banner (unsatisfied by default)
                        updateBannerDisplay();
                    };
                    unsatisfiedImg.onerror = function() {
                        console.warn('[Banner] Failed to load unsatisfied banner image');
                    };
                    unsatisfiedImg.src = unsatisfiedUrl;
                }

                // Preload satisfied banner image
                if (bannerImages.satisfied) {
                    const satisfiedUrl = `/api/project/${projectName}/images/${bannerImages.satisfied}`;
                    const satisfiedImg = new Image();
                    satisfiedImg.onload = function() {
                        gameState.bannerImages.satisfied = satisfiedUrl;
                        console.log('[Banner] Satisfied banner image loaded');
                    };
                    satisfiedImg.onerror = function() {
                        console.warn('[Banner] Failed to load satisfied banner image');
                    };
                    satisfiedImg.src = satisfiedUrl;
                }
            } else {
                console.log('[Banner] No banner images found');
            }
        }

        // Load game data for selected project
        // Load game data with curtain transition
        async function loadGameWithCurtain(projectName) {
            if (!projectName) return;

            gameState.currentProject = projectName;
            gameState.currentProjectName = projectName;
            
            // Update song name display in SVG cloud
            const selectedOption = elements.projectSelect.querySelector(`option[value="${projectName}"]`);
            const displayName = selectedOption ? selectedOption.dataset.displayName : projectName;
            if (elements.songNameText) {
                elements.songNameText.textContent = displayName;
            }

            try {
                // Load project images
                const imagesResponse = await fetch(`/api/project/${projectName}/images`);
                let projectImages = null;
                if (imagesResponse.ok) {
                    const imagesData = await imagesResponse.json();
                    if (imagesData.status === 'success') {
                        projectImages = imagesData.images;
                        console.log('Loaded project images:', projectImages);
                    }
                }

                // Load score data (beatmap)
                const scoreResponse = await fetch(`/api/score/${projectName}`);
                const scoreData = await scoreResponse.json();
                
                let notes = [];
                if (scoreData.status === 'success' && scoreData.score) {
                    if (Array.isArray(scoreData.score)) {
                        notes = scoreData.score;
                    } else if (scoreData.score.notes) {
                        notes = scoreData.score.notes;
                    }
                }

                // Generate uniform beat grid from BPM data
                let beatGrid = null;
                try {
                    const metadataResponse = await fetch(`/api/metadata/${projectName}`);
                    const metadataData = await metadataResponse.json();
                    console.log('Metadata response:', metadataData);
                    
                    if (metadataData.metadata && metadataData.metadata.bpm_data) {
                        gameState.metadata = metadataData.metadata;
                        
                        // Get BPM and offset from metadata
                        const bpm = metadataData.metadata.bpm_data.bpm;
                        gameState.audioOffset = metadataData.metadata.bpm_data.offset || 0.0;
                        console.log(`[Beat Grid] Using BPM: ${bpm}, Offset: ${gameState.audioOffset.toFixed(3)}s`);
                        
                        if (bpm && gameState.duration) {
                            // Generate uniform beat grid based on BPM
                            const beatInterval = 60 / bpm; // seconds per beat
                            const beats = [];
                            const downbeats = [];
                            
                            // Generate beats from 0 to duration
                            for (let time = 0; time < gameState.duration; time += beatInterval) {
                                beats.push(time);
                                
                                // Every 4th beat is a downbeat (measure line)
                                const beatIndex = Math.round(time / beatInterval);
                                if (beatIndex % 4 === 0) {
                                    downbeats.push(time);
                                }
                            }
                            
                            beatGrid = { 
                                beats, 
                                downbeats,
                                beat_interval: beatInterval 
                            };
                            console.log(`[Beat Grid] Generated uniform grid: ${beats.length} beats, ${downbeats.length} measures`);
                        }
                    }
                } catch (metaError) {
                    console.warn('Could not load beat grid data:', metaError);
                }

                // Load audio - use original song instead of backing track
                const audioPath = `data/${projectName}/${projectName}.mp3`;
                gameState.audio = new Audio(audioPath);
                
                await new Promise((resolve, reject) => {
                    gameState.audio.onloadeddata = resolve;
                    gameState.audio.onerror = reject;
                });

                gameState.duration = gameState.audio.duration;
                gameState.notes = notes.sort((a, b) => a.time - b.time);
                gameState.totalNotes = notes.length;

                generateNoteElements();
                
                // Now generate beat grid with available duration
                generateUniformBeatGrid();
                
                // Load project images (background and character)
                loadProjectImages(projectName, projectImages);
                
                console.log(`Loaded ${notes.length} notes for ${projectName}`);
                
                // Wait a moment then hide curtain and start game
                setTimeout(() => {
                    hideCurtain();
                    setTimeout(() => {
                        startGame();
                    }, 200); // Start game just after curtain starts opening
                }, 800);
                
            } catch (error) {
                console.error('Failed to load game:', error);
                setTimeout(() => {
                    hideCurtain();
                    setTimeout(() => {
                        alert('加载游戏失败: ' + error.message);
                        showSongSelectionScreen();
                    }, 500);
                }, 1000);
            }
        }

        // Keep original loadGame for backward compatibility
        async function loadGame(projectName) {
            if (!projectName) return;

            elements.loadingScreen.style.display = 'flex';
            
            try {
                await loadGameWithCurtain(projectName);
                elements.loadingScreen.style.display = 'none';
            } catch (error) {
                elements.loadingScreen.style.display = 'none';
                throw error;
            }
        }

        // Generate visual note elements
        function generateNoteElements() {
            elements.notesContainer.innerHTML = '';
            
            gameState.notes.forEach((note, index) => {
                const noteElement = document.createElement('div');
                noteElement.className = `beat-note ${note.type}`;
                // Create SVG icon instead of text
                noteElement.innerHTML = note.type === 'don' ? createDonSVG() : createKaSVG();
                noteElement.dataset.noteIndex = index;
                noteElement.dataset.time = note.time;
                noteElement.dataset.hit = 'false';
                
                // Position note based on time
                const initialX = settings.noteSpawnX + (note.time * settings.scrollSpeed);
                noteElement.style.left = `${initialX}px`;
                
                elements.notesContainer.appendChild(noteElement);
            });
        }

        // Beat grid optimization
        let beatGridData = null;
        let activeBeatLines = new Map(); // Track active beat lines
        let beatLinePool = []; // Pool of reusable beat line elements
        
        // Initialize beat grid data without rendering
        function initializeBeatGrid(beatGrid) {
            console.log('initializeBeatGrid called with:', beatGrid);
            
            if (!beatGrid || !gameState.duration) {
                console.log('No beatGrid data or duration, skipping grid initialization');
                beatGridData = null;
                return;
            }

            // Store beat data for lazy loading
            beatGridData = {
                beats: beatGrid.beats || [],
                downbeats: beatGrid.downbeats || []
            };
            
            console.log('Beat grid initialized with', beatGridData.beats.length, 'beats and', beatGridData.downbeats.length, 'downbeats');
            console.log('Beat grid optimization: using viewport rendering instead of creating', (beatGridData.beats.length + beatGridData.downbeats.length), 'DOM elements at once');
        }

        // Create or reuse a beat line element
        function createBeatLine(time, isMeasure = false) {
            let beatLine;
            
            if (beatLinePool.length > 0) {
                beatLine = beatLinePool.pop();
            } else {
                beatLine = document.createElement('div');
            }
            
            beatLine.className = isMeasure ? 'beat-line measure' : 'beat-line';
            beatLine.dataset.time = time;
            beatLine.style.display = 'block';
            
            return beatLine;
        }

        // Return beat line to pool
        function recycleBeatLine(beatLine) {
            beatLine.style.display = 'none';
            beatLinePool.push(beatLine);
        }

        // Update visible beat lines based on current viewport
        function updateBeatGridViewport() {
            if (!beatGridData || !elements.beatGrid) return;
            
            const currentTime = gameState.currentTime;
            const viewportStart = currentTime - 2; // Show 2 seconds before current time
            const viewportEnd = currentTime + 10;  // Show 10 seconds ahead
            
            // Remove lines that are outside viewport
            for (const [timeKey, beatLine] of activeBeatLines) {
                const lineTime = parseFloat(timeKey);
                if (lineTime < viewportStart || lineTime > viewportEnd) {
                    elements.beatGrid.removeChild(beatLine);
                    recycleBeatLine(beatLine);
                    activeBeatLines.delete(timeKey);
                }
            }
            
            // Add lines that should be visible
            const linesToAdd = [];
            
            // Check downbeats (measures)
            beatGridData.downbeats.forEach(time => {
                if (time >= viewportStart && time <= viewportEnd && !activeBeatLines.has(time.toString())) {
                    linesToAdd.push({ time, isMeasure: true });
                }
            });
            
            // Check regular beats
            beatGridData.beats.forEach(time => {
                if (time >= viewportStart && time <= viewportEnd && 
                    !activeBeatLines.has(time.toString()) && 
                    !beatGridData.downbeats.includes(time)) {
                    linesToAdd.push({ time, isMeasure: false });
                }
            });
            
            // Add new lines in batches to avoid blocking
            if (linesToAdd.length > 0) {
                const batchSize = 10;
                for (let i = 0; i < Math.min(batchSize, linesToAdd.length); i++) {
                    const { time, isMeasure } = linesToAdd[i];
                    const beatLine = createBeatLine(time, isMeasure);
                    
                    // Position based on time with offset for alignment
                    const offsetTime = time + gameState.audioOffset;
                    const timeDiff = offsetTime - currentTime;
                    const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                    beatLine.style.left = `${x}px`;
                    
                    elements.beatGrid.appendChild(beatLine);
                    activeBeatLines.set(time.toString(), beatLine);
                }
            }
        }

        // Update beat grid positions and viewport
        function updateBeatGrid() {
            if (!beatGridData) return;
            
            // Update viewport every few frames to avoid excessive computation
            if (gameState.currentTime % 0.1 < 0.05) { // Approximately every 100ms
                updateBeatGridViewport();
            }
            
            // Update positions of active beat lines
            for (const [timeKey, beatLine] of activeBeatLines) {
                const lineTime = parseFloat(timeKey);
                const offsetTime = lineTime + gameState.audioOffset;
                const timeDiff = offsetTime - gameState.currentTime;
                const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                beatLine.style.left = `${x}px`;
            }
        }

        // Generate uniform beat grid from metadata BPM
        function generateUniformBeatGrid() {
            if (!gameState.metadata || !gameState.metadata.bpm_data || !gameState.duration) {
                console.log('[Beat Grid] Cannot generate: missing metadata or duration');
                return;
            }
            
            const bpm = gameState.metadata.bpm_data.bpm;
            console.log(`[Beat Grid] Generating uniform grid: BPM=${bpm}, Duration=${gameState.duration.toFixed(2)}s`);
            
            // Generate uniform beat grid based on BPM
            const beatInterval = 60 / bpm; // seconds per beat
            const beats = [];
            const downbeats = [];
            
            // Generate beats from 0 to duration
            for (let time = 0; time < gameState.duration; time += beatInterval) {
                beats.push(time);
                
                // Every 4th beat is a downbeat (measure line)
                const beatIndex = Math.round(time / beatInterval);
                if (beatIndex % 4 === 0) {
                    downbeats.push(time);
                }
            }
            
            const beatGrid = { 
                beats, 
                downbeats,
                beat_interval: beatInterval 
            };
            
            console.log(`[Beat Grid] Generated: ${beats.length} beats, ${downbeats.length} measures (interval: ${beatInterval.toFixed(6)}s)`);
            initializeBeatGrid(beatGrid);
        }

        // Clear beat grid
        function clearBeatGrid() {
            // Return all active beat lines to pool
            for (const [timeKey, beatLine] of activeBeatLines) {
                elements.beatGrid.removeChild(beatLine);
                recycleBeatLine(beatLine);
            }
            activeBeatLines.clear();
        }

        // Start game
        function startGame() {
            if (!gameState.currentProject || !gameState.audio) return;

            resetGameState();
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.startTime = performance.now();
            
            // Show title with cloud decoration
            if (elements.songNameSimple) {
                elements.songNameSimple.classList.add('loaded');
            }
            
            gameState.audio.currentTime = 0;
            gameState.audio.play();
            
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            if (!gameState.isPlaying || gameState.isPaused) return;

            const now = performance.now();
            gameState.currentTime = (now - gameState.startTime) / 1000;
            
            // Update audio sync
            if (Math.abs(gameState.audio.currentTime - gameState.currentTime) > 0.1) {
                gameState.currentTime = gameState.audio.currentTime;
            }

            updateNotePositions();
            updateBeatGrid();
            checkMissedNotes();
            updateUI();
            updateParticles();

            // Check if song finished
            if (gameState.currentTime >= gameState.duration) {
                endGame();
                return;
            }

            gameState.animationId = requestAnimationFrame(gameLoop);
        }

        // Update note positions
        function updateNotePositions() {
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            
            notes.forEach(noteElement => {
                // Skip notes that are already hit but still animating
                if (noteElement.dataset.hit === 'true' && !noteElement.classList.contains('hit')) {
                    return;
                }
                
                const noteTime = parseFloat(noteElement.dataset.time);
                const timeDiff = noteTime - gameState.currentTime;
                const x = settings.hitTargetX + (timeDiff * settings.scrollSpeed);
                
                noteElement.style.left = `${x}px`;
                
                // Remove notes that are too far off screen (left side)
                if (x < -100) {
                    noteElement.remove();
                }
            });
        }

        // Check for missed notes
        function checkMissedNotes() {
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            
            notes.forEach(noteElement => {
                if (noteElement.dataset.hit === 'true') return;
                
                const noteTime = parseFloat(noteElement.dataset.time);
                
                if (gameState.currentTime > noteTime + settings.hitWindow.miss) {
                    // Note missed
                    noteElement.dataset.hit = 'true';
                    gameState.missedHits++;
                    gameState.combo = 0;
                    showJudgment('miss');
                    
                    // Update Spirit system for miss
                    updateSpiritValue('miss');
                    
                    // Remove missed note after brief delay
                    setTimeout(() => {
                        if (noteElement.parentNode) {
                            noteElement.remove();
                        }
                    }, 500);
                }
            });
        }

        // Handle drum hits
        function hitDrum(type) {
            // Update Don character display
            updateDonDisplay(type);
            
            const notes = elements.notesContainer.querySelectorAll('.beat-note');
            let bestNote = null;
            let bestTimeDiff = Infinity;
            
            // Find the closest note of matching type
            notes.forEach(noteElement => {
                if (noteElement.dataset.hit === 'true') return;
                if (!noteElement.classList.contains(type)) return;
                
                const noteTime = parseFloat(noteElement.dataset.time);
                const timeDiff = Math.abs(noteTime - gameState.currentTime);
                
                if (timeDiff <= settings.hitWindow.miss && timeDiff < bestTimeDiff) {
                    bestNote = noteElement;
                    bestTimeDiff = timeDiff;
                }
            });
            
            if (bestNote) {
                // Hit successful
                bestNote.dataset.hit = 'true';
                bestNote.classList.add('hit');
                
                let judgment, points;
                if (bestTimeDiff <= settings.hitWindow.perfect) {
                    judgment = 'perfect';
                    points = settings.scoring.perfect;
                    gameState.perfectHits++;
                } else if (bestTimeDiff <= settings.hitWindow.good) {
                    judgment = 'good';
                    points = settings.scoring.good;
                    gameState.goodHits++;
                } else {
                    judgment = 'miss';
                    points = settings.scoring.miss;
                    gameState.missedHits++;
                }
                
                if (judgment !== 'miss') {
                    gameState.combo++;
                    gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                    gameState.hitNotes++;
                } else {
                    gameState.combo = 0;
                }
                
                // Track separate scores for detailed statistics
                const comboBonus = gameState.combo * 10;
                if (judgment === 'perfect') {
                    gameState.perfectScore += points + comboBonus;
                } else if (judgment === 'good') {
                    gameState.goodScore += points + comboBonus;
                }
                gameState.comboScore += comboBonus;
                
                gameState.score += points + comboBonus;
                showJudgment(judgment);
                createHitEffect(type);
                
                // Update Spirit system
                updateSpiritValue(judgment);
                
                // Add hit effect for successful hits with different colors
                if (judgment === 'perfect') {
                    createHitEffect_Golden();
                } else if (judgment === 'good') {
                    createHitEffect_White();
                }
                
                // Remove note immediately if hit successfully, otherwise after animation
                if (judgment === 'perfect' || judgment === 'good') {
                    // Immediately remove successful hits
                    if (bestNote.parentNode) {
                        bestNote.remove();
                    }
                } else {
                    // Keep original delay for miss
                    setTimeout(() => {
                        if (bestNote.parentNode) {
                            bestNote.remove();
                        }
                    }, 300);
                }
            }
            
            // Visual drum feedback - updated for separate elements
            if (type === 'don') {
                elements.drumDon.classList.add('hit');
                setTimeout(() => {
                    elements.drumDon.classList.remove('hit');
                }, 150);
            } else {
                elements.unifiedDrum.classList.add('hit-ka');
                setTimeout(() => {
                    elements.unifiedDrum.classList.remove('hit-ka');
                }, 150);
            }
        }

        // Show judgment text
        function showJudgment(type) {
            // Remove existing judgment
            const existingJudgment = document.querySelector('.judgment');
            if (existingJudgment) {
                existingJudgment.remove();
            }
            
            const judgment = document.createElement('div');
            judgment.className = `judgment ${type}`;
            
            switch (type) {
                case 'perfect':
                    judgment.textContent = '优';
                    break;
                case 'good':
                    judgment.textContent = '良';
                    break;
                case 'miss':
                    judgment.textContent = '不可';
                    break;
            }
            
            // Add judgment text directly to target drum
            const targetDrum = document.getElementById('targetDrum');
            if (targetDrum) {
                targetDrum.appendChild(judgment);
            }
        }

        // Create hit effect
        function createHitEffect(type) {
            const effect = document.createElement('div');
            effect.className = type === 'ka' ? 'hit-effect ka' : 'hit-effect';
            
            // Position exactly at target drum center
            const targetDrum = document.querySelector('.target-drum');
            const drumRect = targetDrum.getBoundingClientRect();
            const beatTrackRect = document.querySelector('.beat-track').getBoundingClientRect();
            
            // Calculate relative position within beat-track
            const relativeLeft = drumRect.left + drumRect.width/2 - beatTrackRect.left;
            const relativeTop = drumRect.top + drumRect.height/2 - beatTrackRect.top;
            
            effect.style.left = `${relativeLeft}px`;
            effect.style.top = `${relativeTop}px`;
            effect.style.transform = 'translate(-50%, -50%)';
            
            document.querySelector('.beat-track').appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 300);
        }

        // Create particles for hit effects with Chinese elements
        function createParticles(type, count = 8) {
            const targetDrum = document.querySelector('.target-drum');
            const drumRect = targetDrum.getBoundingClientRect();
            const beatTrack = document.querySelector('.beat-track');
            const beatTrackRect = beatTrack.getBoundingClientRect();
            
            // Calculate center position within beat-track
            const centerX = drumRect.left + drumRect.width/2 - beatTrackRect.left;
            const centerY = drumRect.top + drumRect.height/2 - beatTrackRect.top;
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                
                // Create different particle types for Chinese elements
                const chineseElements = ['lotus-petal', 'cloud-wisp', 'bamboo-leaf'];
                const randomElement = chineseElements[Math.floor(Math.random() * chineseElements.length)];
                
                if (type === 'golden' && Math.random() < 0.6) {
                    // Golden hits spawn more lotus petals and cloud wisps
                    particle.className = `hit-particle particle-chinese particle-${randomElement} particle-golden`;
                    particle.innerHTML = createChineseParticleSVG(randomElement, 'golden');
                } else if (type === 'white' && Math.random() < 0.4) {
                    // White hits spawn some Chinese elements too
                    particle.className = `hit-particle particle-chinese particle-${randomElement} particle-white`;
                    particle.innerHTML = createChineseParticleSVG(randomElement, 'white');
                } else {
                    // Fallback to original particle system
                    particle.className = `hit-particle particle-${type}`;
                }
                
                // Random initial position around the center (slight spread)
                const spread = 15;
                const startX = centerX + (Math.random() - 0.5) * spread;
                const startY = centerY + (Math.random() - 0.5) * spread;
                
                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;
                
                beatTrack.appendChild(particle);
                
                // Create particle object for animation
                const particleObj = {
                    element: particle,
                    startX: startX,
                    startY: startY,
                    // Random velocity components (overall rightward)
                    velocityX: 2 + Math.random() * 4, // 2-6 rightward base speed
                    velocityY: (Math.random() - 0.5) * 3, // -1.5 to 1.5 vertical speed
                    // Random wave parameters for sin/cos motion
                    waveAmplitude: 20 + Math.random() * 30, // 20-50 wave height
                    waveFrequency: 0.05 + Math.random() * 0.1, // wave frequency
                    // Lifecycle
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.015, // 0.015-0.03 decay per frame
                    startTime: performance.now()
                };
                
                particles.push(particleObj);
            }
        }
        
        // Create Chinese particle SVG elements
        function createChineseParticleSVG(elementType, colorType) {
            const goldColor = colorType === 'golden' ? '#FFD700' : '#FFFFFF';
            const accentColor = colorType === 'golden' ? '#FFA500' : '#E0E0E0';
            
            switch (elementType) {
                case 'lotus-petal':
                    return `
                        <svg width="12" height="12" viewBox="0 0 20 20" style="pointer-events: none;">
                            <path d="M 10,18 Q 5,10 2,2 Q 10,5 18,2 Q 15,10 10,18 Z" 
                                  fill="${goldColor}" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.9"/>
                            <path d="M 10,15 Q 7,10 5,5 Q 10,7 15,5 Q 13,10 10,15 Z" 
                                  fill="${accentColor}" 
                                  opacity="0.6"/>
                        </svg>
                    `;
                
                case 'cloud-wisp':
                    return `
                        <svg width="16" height="8" viewBox="0 0 32 16" style="pointer-events: none;">
                            <path d="M 2,8 Q 0,4 4,4 Q 8,2 12,4 Q 16,2 20,4 Q 24,2 28,4 Q 32,4 30,8 Q 28,12 24,10 Q 20,12 16,10 Q 12,12 8,10 Q 4,12 2,8 Z" 
                                  fill="${goldColor}" 
                                  opacity="0.7"/>
                            <path d="M 6,7 Q 4,5 6,5 Q 10,4 14,5 Q 18,4 22,5 Q 26,4 28,7 Q 26,9 22,8 Q 18,9 14,8 Q 10,9 6,7 Z" 
                                  fill="${accentColor}" 
                                  opacity="0.5"/>
                        </svg>
                    `;
                
                case 'bamboo-leaf':
                    return `
                        <svg width="8" height="16" viewBox="0 0 16 32" style="pointer-events: none;">
                            <path d="M 8,30 Q 4,20 2,10 Q 4,5 8,2 Q 12,5 14,10 Q 12,20 8,30 Z" 
                                  fill="${goldColor}" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.8"/>
                            <line x1="8" y1="4" x2="8" y2="28" 
                                  stroke="${accentColor}" 
                                  stroke-width="1" 
                                  opacity="0.6"/>
                        </svg>
                    `;
                
                default:
                    return '';
            }
        }

        // Update all particles
        function updateParticles() {
            const currentTime = performance.now();
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                const elapsed = (currentTime - particle.startTime) / 1000; // seconds
                
                // Update position using sin/cos for wave motion
                const baseX = particle.startX + particle.velocityX * elapsed * 60; // 60fps base
                const baseY = particle.startY + particle.velocityY * elapsed * 60;
                const waveY = Math.sin(elapsed * particle.waveFrequency * Math.PI * 2) * particle.waveAmplitude * particle.life;
                
                const finalX = baseX;
                const finalY = baseY + waveY;
                
                // Update particle position
                particle.element.style.left = `${finalX}px`;
                particle.element.style.top = `${finalY}px`;
                
                // Update life and opacity
                particle.life -= particle.decay;
                particle.element.style.opacity = Math.max(0, particle.life);
                particle.element.style.transform = `scale(${0.5 + particle.life * 0.5})`;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                }
            }
        }

        // Create golden hit effect for perfect hits
        function createHitEffect_Golden() {
            const targetDrum = document.querySelector('.target-drum');
            
            // Add golden effect only to target drum
            targetDrum.classList.add('golden-hit');
            
            // Create golden particles
            createParticles('golden', 12);
            
            // Remove effects after animation
            setTimeout(() => {
                targetDrum.classList.remove('golden-hit');
            }, 800);
        }

        // Create white hit effect for good hits
        function createHitEffect_White() {
            const targetDrum = document.querySelector('.target-drum');
            
            // Add white effect only to target drum
            targetDrum.classList.add('white-hit');
            
            // Create white particles
            createParticles('white', 8);
            
            // Remove effects after animation
            setTimeout(() => {
                targetDrum.classList.remove('white-hit');
            }, 800);
        }

        // Update Don character display
        function updateDonDisplay(type) {
            if (!donElements.donFace) return;
            
            // 根据击打类型亮起对应区域
            if (type === 'don') {
                // Don - 内圈亮红
                donElements.donFace.classList.remove('hit-ka');
                donElements.donFace.classList.add('hit-don');
            } else if (type === 'ka') {
                // Ka - 外圈亮蓝  
                donElements.donFace.classList.remove('hit-don');
                donElements.donFace.classList.add('hit-ka');
            }
            
            // Reset after animation
            setTimeout(() => {
                donElements.donFace.classList.remove('hit-don', 'hit-ka');
            }, 200);
        }

        // Update UI
        function updateUI() {
            // Update score bar
            elements.scoreBar.textContent = `得分: ${gameState.score.toLocaleString()}`;
            
            // Update Don combo display
            if (donElements.donCombo) {
                donElements.donCombo.textContent = gameState.combo;
            }
        }


        // Reset game state
        function resetGameState() {
            gameState.score = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.hitNotes = 0;
            gameState.perfectHits = 0;
            gameState.goodHits = 0;
            gameState.missedHits = 0;
            gameState.perfectScore = 0;
            gameState.goodScore = 0;
            gameState.comboScore = 0;
            gameState.currentTime = 0;
            
            // Reset Spirit system
            resetSpiritSystem();
            
            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }
            
            // Clear beat grid
            clearBeatGrid();
            
            // Clear all particles
            particles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            particles = [];
            
            generateNoteElements();
            
            // Regenerate uniform beat grid
            generateUniformBeatGrid();
        }

        // Update character display based on spirit value
        function updateCharacterDisplay() {
            if (!elements.characterImage) {
                return;
            }

            // Always use the cute Chinese drum SVG
            elements.characterImage.src = '/static/ghost-drum.svg';
            elements.characterDisplay.classList.add('loaded');
            
            // Set ghost float animation duration based on BPM
            setGhostFloatBPM();
            
            console.log(`[Character] Using cute Chinese drum SVG (spirit: ${Math.round(gameState.spiritValue)}%)`);
        }

        // Set ghost float animation duration based on current BPM
        function setGhostFloatBPM() {
            // Set duration for game character
            if (elements.characterImage) {
                const duration = calculateGhostFloatDuration();
                elements.characterImage.style.animationDuration = `${duration.toFixed(2)}s`;
                console.log(`[Character] Set game ghost float duration to ${duration.toFixed(2)}s`);
            }

            // Set duration for selection character
            if (elements.selectionCharacter) {
                const duration = calculateGhostFloatDuration();
                elements.selectionCharacter.style.animationDuration = `${duration.toFixed(2)}s`;
                console.log(`[Character] Set selection ghost float duration to ${duration.toFixed(2)}s`);
            }
        }

        // Calculate ghost float duration based on BPM
        function calculateGhostFloatDuration() {
            if (!gameState.metadata || !gameState.metadata.bpm_data) {
                console.log('[Character] Using default 3s float duration (no BPM data)');
                return 3.0; // Default 3 seconds
            }

            const bpm = gameState.metadata.bpm_data.bpm;
            if (!bpm || bpm <= 0) {
                console.log('[Character] Using default 3s float duration (invalid BPM)');
                return 3.0; // Default 3 seconds
            }

            // Calculate duration: (60/bpm)*4 seconds
            const duration = (60 / bpm) * 4;
            console.log(`[Character] Calculated ghost float duration: ${duration.toFixed(2)}s (BPM: ${bpm})`);
            return duration;
        }

        // Load metadata and stats for selected song
        async function loadSelectedSongMetadata(projectName) {
            try {
                // Load metadata for BPM
                const metadataResponse = await fetch(`/api/metadata/${projectName}`);
                const metadataData = await metadataResponse.json();
                
                if (metadataResponse.ok && metadataData.metadata && metadataData.metadata.bpm_data) {
                    gameState.metadata = metadataData.metadata;
                    
                    const bpm = gameState.metadata.bpm_data.bpm;
                    console.log(`[Selection] Loaded metadata for ${projectName}, BPM: ${bpm}`);
                    
                    // Update ghost float animation for selection character
                    setGhostFloatBPM();
                } else {
                    console.warn(`[Selection] No BPM data found for ${projectName}`);
                    gameState.metadata = null;
                    setGhostFloatBPM(); // Use default duration
                }

                // Load song-specific statistics
                await loadSongStats(projectName);
                
            } catch (error) {
                console.error(`[Selection] Failed to load metadata for ${projectName}:`, error);
                gameState.metadata = null;
                setGhostFloatBPM(); // Use default duration
                // Clear stats display on error
                updateStatsDisplay(null);
            }
        }

        // Load statistics for specific song
        async function loadSongStats(songName) {
            try {
                const response = await fetch(`/api/song-stats/${encodeURIComponent(songName)}`);
                const statsData = await response.json();
                
                if (response.ok) {
                    console.log(`[Selection] Loaded stats for ${songName}:`, statsData);
                    updateStatsDisplay(statsData.stats);
                } else {
                    console.warn(`[Selection] No stats found for ${songName}`);
                    updateStatsDisplay(null); // Show default values
                }
            } catch (error) {
                console.error(`[Selection] Failed to load stats for ${songName}:`, error);
                updateStatsDisplay(null); // Show default values
            }
        }

        // Update stats panel display with song-specific data
        function updateStatsDisplay(stats) {
            if (stats && stats.total_games > 0) {
                // Show song-specific stats
                document.getElementById('bestScore').textContent = stats.best_score ? stats.best_score.toLocaleString() + '点' : '0点';
                document.getElementById('bestAccuracy').textContent = stats.best_accuracy ? stats.best_accuracy + '%' : '0%';
                document.getElementById('bestCombo').textContent = stats.best_combo ? stats.best_combo + '回' : '0回';
                document.getElementById('bestSpirit').textContent = stats.best_spirit ? stats.best_spirit + '%' : '0%';
                document.getElementById('totalGames').textContent = stats.total_games ? stats.total_games + '次' : '0次';
            } else {
                // Show default values when no stats available
                document.getElementById('bestScore').textContent = '-';
                document.getElementById('bestAccuracy').textContent = '-';
                document.getElementById('bestCombo').textContent = '-';
                document.getElementById('bestSpirit').textContent = '-';
                document.getElementById('totalGames').textContent = '0次';
            }
        }

        // Update banner display based on spirit value
        function updateBannerDisplay() {
            if (!settings.showBanner || !elements.topBanner || !gameState.bannerImages) {
                return;
            }

            const isSatisfied = gameState.spiritValue >= 60; // Spirit >= 60% is satisfied
            const imageUrl = isSatisfied ? 
                gameState.bannerImages.satisfied : 
                gameState.bannerImages.unsatisfied;

            if (imageUrl) {
                elements.topBanner.style.backgroundImage = `url('${imageUrl}')`;
                elements.topBanner.classList.add('loaded');
                
                console.log(`[Banner] Updated to ${isSatisfied ? 'satisfied' : 'unsatisfied'} (spirit: ${Math.round(gameState.spiritValue)}%)`);
            }
        }

        // Clear project images
        function clearProjectImages() {
            // Clear background image
            if (elements.gameBackground) {
                elements.gameBackground.style.backgroundImage = '';
                elements.gameBackground.classList.remove('loaded');
            }
            
            // Clear character image
            if (elements.characterImage) {
                elements.characterImage.src = '';
                elements.characterDisplay.classList.remove('loaded');
            }
            
            // Clear banner image
            if (elements.topBanner) {
                elements.topBanner.style.backgroundImage = '';
                elements.topBanner.classList.remove('loaded');
            }
            
            // Clear title with cloud decoration
            if (elements.songNameSimple) {
                elements.songNameSimple.classList.remove('loaded');
            }
            
            // Clear stored image URLs
            if (gameState.characterImages) {
                gameState.characterImages = null;
            }
            if (gameState.bannerImages) {
                gameState.bannerImages = null;
            }
        }

        // End game
        function endGame() {
            gameState.isPlaying = false;
            if (gameState.audio) {
                gameState.audio.pause();
            }
            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }
            
            // Hide title with cloud decoration when game ends
            if (elements.songNameSimple) {
                elements.songNameSimple.classList.remove('loaded');
            }
            
            showGameOverScreen();
        }

        // Send game result to backend
        async function sendGameResult() {
            if (!gameState.currentProject) {
                console.warn('No current project - cannot send game result');
                return;
            }
            
            const accuracy = gameState.totalNotes > 0 ? 
                Math.round((gameState.hitNotes / Math.max(gameState.hitNotes + gameState.missedHits, 1)) * 100) : 100;
            
            // Calculate play time (actual time spent playing)
            const playTime = gameState.currentTime;
            
            const gameResult = {
                song_name: gameState.currentProject,
                final_score: gameState.score,
                max_combo: gameState.maxCombo,
                accuracy: accuracy,
                final_spirit: Math.round(gameState.spiritValue),
                perfect_hits: gameState.perfectHits,
                good_hits: gameState.goodHits,
                miss_hits: gameState.missedHits,
                total_notes: gameState.totalNotes,
                duration_seconds: Math.round(playTime)
            };
            
            try {
                const response = await fetch('/api/save-game-result', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(gameResult)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('游戏结果已保存到数据库:', result);
                } else {
                    console.error('保存游戏结果失败:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('发送游戏结果时出错:', error);
            }
        }
        
        // Show game over screen
        function showGameOverScreen() {
            const accuracy = gameState.totalNotes > 0 ? 
                Math.round((gameState.hitNotes / Math.max(gameState.hitNotes + gameState.missedHits, 1)) * 100) : 100;
            
            // Basic stats
            elements.finalScore.textContent = gameState.score.toLocaleString();
            elements.maxCombo.textContent = gameState.maxCombo;
            elements.finalAccuracy.textContent = `${accuracy}%`;
            elements.finalSpirit.textContent = `${Math.round(gameState.spiritValue)}%`;
            
            // Detailed hit statistics
            elements.finalPerfectHits.textContent = gameState.perfectHits;
            elements.finalGoodHits.textContent = gameState.goodHits;
            elements.finalMissedHits.textContent = gameState.missedHits;
            
            // Individual scores (approximated since we track combined scores)
            const perfectBaseScore = gameState.perfectHits * settings.scoring.perfect;
            const goodBaseScore = gameState.goodHits * settings.scoring.good;
            
            elements.perfectScore.textContent = `${perfectBaseScore.toLocaleString()}分`;
            elements.goodScore.textContent = `${goodBaseScore.toLocaleString()}分`;
            elements.missScore.textContent = '0分';
            
            // Send game result to backend
            sendGameResult();
            
            elements.gameOverScreen.style.display = 'flex';
        }

        // Song Selection Screen Functions
        function showSongSelectionScreen() {
            elements.songSelectionScreen.style.display = 'flex';
            populateSongList();
            console.log('[SongSelection] Song selection screen shown');
        }

        function hideSongSelectionScreen() {
            elements.songSelectionScreen.style.display = 'none';
            console.log('[SongSelection] Song selection screen hidden');
        }


        async function populateSongList() {
            if (!elements.songList) return;
            
            // Clear only song items, not navigation buttons
            const songItems = elements.songList.querySelectorAll('.song-item');
            songItems.forEach(item => item.remove());
            
            try {
                const response = await fetch('/api/projects');
                const data = await response.json();
                
                if (data.status === 'success' && data.projects) {
                    // Create navigation button to right (if not already exists)
                    let navButtonRight = document.getElementById('navButtonRight');
                    if (!navButtonRight) {
                        navButtonRight = document.createElement('div');
                        navButtonRight.className = 'nav-button nav-button-left';
                        navButtonRight.id = 'navButtonRight';
                        navButtonRight.innerHTML = '<div class="nav-button-content">来到最右侧</div>';
                        elements.songList.appendChild(navButtonRight);
                    }
                    
                    // Filter projects by selected category
                    const filteredProjects = await filterProjectsByCategory(data.projects);
                    
                    // Create real song items
                    for (const project of filteredProjects) {
                        const songItem = await createSongItem(project, true);
                        elements.songList.appendChild(songItem);
                    }
                    
                    // Create navigation button to left (if not already exists)
                    let navButtonLeft = document.getElementById('navButtonLeft');
                    if (!navButtonLeft) {
                        navButtonLeft = document.createElement('div');
                        navButtonLeft.className = 'nav-button nav-button-right';
                        navButtonLeft.id = 'navButtonLeft';
                        navButtonLeft.innerHTML = '<div class="nav-button-content">来到最左侧</div>';
                        elements.songList.appendChild(navButtonLeft);
                    }
                }
                
                // Initialize center selection after populating
                initializeCenterSelection();
                
                // Setup navigation button listeners after songs are populated
                setupNavigationButtons();
                
            } catch (error) {
                console.error('Failed to populate song list:', error);
            }
        }

        // Create a song item element
        async function createSongItem(project, isReal) {
            const songItem = document.createElement('div');
            songItem.className = 'song-item';
            songItem.dataset.projectName = project.folder_name;
            songItem.dataset.displayName = project.display_name;
            songItem.dataset.isReal = isReal ? 'true' : 'false';
            
            const songName = document.createElement('div');
            songName.className = 'song-item-name';
            songName.textContent = project.display_name;
            
            songItem.appendChild(songName);
            
            // Set song item colors based on category
            await setSongItemColors(songItem, project, isReal);
            
            // Add click handler
            songItem.addEventListener('click', () => {
                selectSong(songItem, project);
            });
            
            return songItem;
        }

        // Set song item colors based on project category
        async function setSongItemColors(songItem, project, isReal) {
            // Default color for demo/test songs
            if (!isReal || !project.folder_name || project.folder_name.includes('_test')) {
                songItem.style.background = 'linear-gradient(45deg, #FF006E, #8338EC)';
                songItem.style.borderColor = '#FFFFFF';
                return;
            }
            
            try {
                const response = await fetch(`/api/metadata/${project.folder_name}`);
                const metadata = await response.json();
                
                if (response.ok && metadata) {
                    const category = metadata.category || 'Pop';
                    
                    // Get category colors
                    let categoryConfig;
                    if (gameState.categoryColors && gameState.categoryColors.categories[category]) {
                        categoryConfig = gameState.categoryColors.categories[category];
                    } else {
                        // Fallback colors
                        const fallbackColors = {
                            'Pop': { primary: '#FF6B9D', secondary: '#FFE1EC', accent: '#FF1F6A' },
                            'Trance': { primary: '#00D4FF', secondary: '#E0F7FF', accent: '#0099CC' },
                            'Brutal': { primary: '#FF4444', secondary: '#FFE6E6', accent: '#CC0000' },
                            'Softcore': { primary: '#90EE90', secondary: '#F0FFF0', accent: '#32CD32' }
                        };
                        categoryConfig = fallbackColors[category] || fallbackColors['Pop'];
                    }
                    
                    // Apply category colors
                    songItem.style.background = `linear-gradient(45deg, ${categoryConfig.primary}, ${categoryConfig.secondary})`;
                    songItem.style.borderColor = categoryConfig.accent;
                    
                } else {
                    // Fallback to Pop colors
                    songItem.style.background = 'linear-gradient(45deg, #FF6B9D, #FFE1EC)';
                    songItem.style.borderColor = '#FF1F6A';
                }
            } catch (error) {
                console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                // Fallback to Pop colors
                songItem.style.background = 'linear-gradient(45deg, #FF6B9D, #FFE1EC)';
                songItem.style.borderColor = '#FF1F6A';
            }
        }


        function selectSong(songItem, project) {
            // Remove selection from all songs
            document.querySelectorAll('.song-item').forEach(item => {
                item.classList.remove('selected');
                item.classList.remove('center-focus');
            });
            
            // Select this song and add center focus
            songItem.classList.add('selected');
            songItem.classList.add('center-focus');
            
            // Update song info display
            elements.selectedSongName.textContent = project.display_name;
            
            // Update song genre display and colors based on project metadata
            updateSongGenreDisplay(project);
            
            // Load metadata and set BPM animation for selected song
            if (songItem.dataset.isReal === 'true') {
                loadSelectedSongMetadata(project.folder_name);
                gameState.selectedProject = project.folder_name;
            } else {
                gameState.selectedProject = null; // Dummy song can't be played
                // Reset to default animation for dummy songs
                gameState.metadata = null;
                setGhostFloatBPM();
            }
            
            // Show or hide start button based on selection
            showStartButton();
            
            // Mark that this is a click-initiated scroll with longer protection
            gameState.isClickScrolling = true;
            gameState.clickScrollStartTime = performance.now();
            
            // Center the clicked song with smooth animation
            centerSongItem(songItem);
            
            // Extend the click scrolling protection time for longer animations
            setTimeout(() => {
                gameState.isClickScrolling = false;
                gameState.clickScrollStartTime = null;
                
                // Final state cleanup: ensure the clicked song is properly centered and focused
                setTimeout(() => {
                    // Re-run center selection to ensure final state is correct
                    const finalUpdate = () => {
                        const containerRect = elements.songList.getBoundingClientRect();
                        const containerCenter = containerRect.left + containerRect.width / 2;
                        
                        let finalClosestItem = null;
                        let finalClosestDistance = Infinity;
                        
                        document.querySelectorAll('.song-item').forEach(item => {
                            const itemRect = item.getBoundingClientRect();
                            const itemCenter = itemRect.left + itemRect.width / 2;
                            const distance = Math.abs(itemCenter - containerCenter);
                            
                            if (distance < finalClosestDistance) {
                                finalClosestDistance = distance;
                                finalClosestItem = item;
                            }
                        });
                        
                        if (finalClosestItem) {
                            // Clean final state
                            document.querySelectorAll('.song-item').forEach(item => {
                                item.classList.remove('center-focus');
                            });
                            finalClosestItem.classList.add('center-focus');
                        }
                    };
                    
                    finalUpdate();
                }, 100); // Small delay to ensure scroll animation is complete
            }, 800); // Increased from 500ms to 800ms
            
            console.log('[SongSelection] Selected song:', project.display_name);
        }

        // Initialize center selection functionality with auto-snap
        function initializeCenterSelection() {
            const container = elements.songList;
            let scrollTimeout;
            let isScrolling = false;
            let isUserScrolling = false; // Track if user is manually scrolling
            
            function updateCenterSelection() {
                const containerRect = container.getBoundingClientRect();
                const containerCenter = containerRect.left + containerRect.width / 2;
                
                let closestItem = null;
                let closestDistance = Infinity;
                
                // Find the song item closest to center
                document.querySelectorAll('.song-item').forEach(item => {
                    const itemRect = item.getBoundingClientRect();
                    const itemCenter = itemRect.left + itemRect.width / 2;
                    const distance = Math.abs(itemCenter - containerCenter);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItem = item;
                    }
                });
                
                if (closestItem) {
                    // During click scrolling, don't change the visual states to prevent flicker
                    if (gameState.isClickScrolling) {
                        // Only update the song info but don't change visual classes
                        const project = {
                            folder_name: closestItem.dataset.projectName,
                            display_name: closestItem.dataset.displayName
                        };
                        
                        elements.selectedSongName.textContent = project.display_name;
                        
                        // Update song genre display and colors
                        updateSongGenreDisplay(project);
                        
                        // Store selected project (only if it's a real song)
                        if (closestItem.dataset.isReal === 'true') {
                            gameState.selectedProject = project.folder_name;
                            // Load stats for real songs during click scrolling
                            loadSongStats(project.folder_name);
                        } else {
                            gameState.selectedProject = null;
                            // Clear stats for dummy songs
                            updateStatsDisplay(null);
                        }
                        
                        return closestItem;
                    }
                    
                    // Normal scroll behavior - update visual states
                    document.querySelectorAll('.song-item').forEach(item => {
                        item.classList.remove('center-focus');
                        // If user is scrolling, also remove selected state to avoid conflicts
                        if (isUserScrolling) {
                            item.classList.remove('selected');
                        }
                    });
                    
                    // Add center focus to closest item
                    closestItem.classList.add('center-focus');
                    
                    // Update song info display automatically
                    const project = {
                        folder_name: closestItem.dataset.projectName,
                        display_name: closestItem.dataset.displayName
                    };
                    
                    elements.selectedSongName.textContent = project.display_name;
                    
                    // Update song genre display and colors
                    updateSongGenreDisplay(project);
                    
                    // Store selected project (only if it's a real song)
                    if (closestItem.dataset.isReal === 'true') {
                        gameState.selectedProject = project.folder_name;
                        // Load stats for real songs during normal scrolling
                        loadSongStats(project.folder_name);
                    } else {
                        gameState.selectedProject = null;
                        // Clear stats for dummy songs
                        updateStatsDisplay(null);
                    }
                    
                    // Update start button visibility
                    showStartButton();
                    
                    return closestItem;
                }
                return null;
            }
            
            function handleScrollEnd() {
                isScrolling = false;
                isUserScrolling = false; // Reset user scrolling flag
                
                // Don't auto-snap if we're still in click scrolling mode
                if (gameState.isClickScrolling) {
                    return;
                }
                
                // Additional protection: don't auto-snap if click was recent
                if (gameState.clickScrollStartTime && 
                    (performance.now() - gameState.clickScrollStartTime) < 1000) {
                    return;
                }
                
                // Find center item and snap to it
                const centerItem = updateCenterSelection();
                if (centerItem) {
                    centerSongItem(centerItem);
                }
            }
            
            // Update center selection on scroll
            container.addEventListener('scroll', () => {
                // Only set user scrolling flag if this is not programmatic scrolling
                if (!isScrolling && !gameState.isClickScrolling) {
                    isUserScrolling = true;
                }
                isScrolling = true;
                
                // Update center focus immediately for visual feedback
                updateCenterSelection();
                
                // Clear existing timeout
                clearTimeout(scrollTimeout);
                
                // Set timeout to snap to center after scrolling stops (increased delay)
                scrollTimeout = setTimeout(handleScrollEnd, 300); // Increased from 150ms to 300ms
            });
            
            // Initial center selection
            setTimeout(() => {
                const centerItem = updateCenterSelection();
                if (centerItem) {
                    // Center the first item without smooth animation initially
                    container.style.scrollBehavior = 'auto';
                    centerSongItem(centerItem);
                    container.style.scrollBehavior = 'smooth';
                }
            }, 100);
        }

        // Center a specific song item in view
        function centerSongItem(songItem) {
            const container = elements.songList;
            const containerRect = container.getBoundingClientRect();
            const itemRect = songItem.getBoundingClientRect();
            
            const scrollLeft = container.scrollLeft;
            const itemCenter = itemRect.left + itemRect.width / 2;
            const containerCenter = containerRect.left + containerRect.width / 2;
            const offset = itemCenter - containerCenter;
            
            // Increased tolerance to reduce micro-adjustments and oscillation
            if (Math.abs(offset) > 15) { // Increased from 5px to 15px tolerance
                // Temporarily disable scroll-behavior for more precise control
                const originalBehavior = container.style.scrollBehavior;
                container.style.scrollBehavior = 'smooth';
                
                container.scrollTo({
                    left: scrollLeft + offset,
                    behavior: 'smooth'
                });
                
                // Restore original scroll behavior after a delay
                setTimeout(() => {
                    container.style.scrollBehavior = originalBehavior;
                }, 100);
            }
        }


        function setupSongSelectionListeners() {
            // Start performance button (no longer inside song info frame)
            elements.startPerformanceBtn.addEventListener('click', () => {
                if (gameState.selectedProject) {
                    startPerformance();
                }
            });

            // Category selection button event listeners
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategoryDropdown();
                });
            }

            if (elements.categoryDropdown) {
                elements.categoryDropdown.addEventListener('click', (e) => {
                    const categoryItem = e.target.closest('.category-dropdown-item');
                    if (categoryItem) {
                        const selectedCategory = categoryItem.dataset.category;
                        selectCategory(selectedCategory);
                        hideCategoryDropdown();
                    }
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#categorySelectBtn') && !e.target.closest('#categoryDropdown')) {
                    hideCategoryDropdown();
                }
            });

        }

        // Toggle category dropdown visibility
        function toggleCategoryDropdown() {
            if (elements.categoryDropdown.classList.contains('show')) {
                hideCategoryDropdown();
            } else {
                showCategoryDropdown();
            }
        }

        // Show category dropdown
        function showCategoryDropdown() {
            elements.categoryDropdown.classList.add('show');
        }

        // Hide category dropdown
        function hideCategoryDropdown() {
            elements.categoryDropdown.classList.remove('show');
        }

        // Category selection functionality
        function selectCategory(category) {
            // Update visual state of dropdown items
            document.querySelectorAll('.category-dropdown-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.category === category) {
                    item.classList.add('active');
                }
            });

            // Update category button text
            const categoryDisplayNames = {
                'All': '全部',
                'Pop': 'Pop',
                'Trance': 'Trance',  
                'Brutal': 'Brutal',
                'Softcore': 'Softcore'
            };
            
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.textContent = categoryDisplayNames[category] || category;
            }

            // Update game state
            gameState.selectedCategory = category;

            // Apply category colors
            applyCategoryColors(category);

            // Re-populate song list with filtered results
            populateSongList();

            console.log('[Category] Selected category:', category);
        }

        // Filter projects by selected category
        async function filterProjectsByCategory(projects) {
            if (gameState.selectedCategory === 'All') {
                return projects;
            }

            const filteredProjects = [];
            
            for (const project of projects) {
                try {
                    const response = await fetch(`/api/project/${project.folder_name}/metadata`);
                    const response = await fetch(`/api/metadata/${project.folder_name}`);
                    const metadata = await response.json();
                    
                    if (response.ok && metadata) {
                        // Check if project matches selected category (default to 'Pop' if no category set)
                        const projectCategory = metadata.category || 'Pop';
                        if (projectCategory === gameState.selectedCategory) {
                            filteredProjects.push(project);
                        }
                    } else {
                        // If can't load metadata, include in 'Pop' category by default
                        if (gameState.selectedCategory === 'Pop') {
                            filteredProjects.push(project);
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                    // If error loading metadata, include in 'Pop' category by default
                    if (gameState.selectedCategory === 'Pop') {
                        filteredProjects.push(project);
                    }
                }
            }
            
            return filteredProjects;
        }

        // Load category colors configuration
        async function loadCategoryColors() {
            try {
                const response = await fetch('/category-colors.json');
                const colorConfig = await response.json();
                gameState.categoryColors = colorConfig;
                console.log('[Colors] Category colors loaded:', colorConfig);
                return colorConfig;
            } catch (error) {
                console.warn('[Colors] Failed to load category colors configuration:', error);
                // Return default color configuration
                return {
                    categories: {
                        Pop: { primary: '#FF6B9D', secondary: '#FFE1EC', accent: '#FF1F6A' },
                        Trance: { primary: '#00D4FF', secondary: '#E0F7FF', accent: '#0099CC' },
                        Brutal: { primary: '#FF4444', secondary: '#FFE6E6', accent: '#CC0000' },
                        Softcore: { primary: '#90EE90', secondary: '#F0FFF0', accent: '#32CD32' }
                    }
                };
            }
        }

        // Apply category colors to UI elements
        function applyCategoryColors(category) {
            if (!gameState.categoryColors || category === 'All') {
                // Reset to default colors if no category selected or colors not loaded
                document.documentElement.style.removeProperty('--category-primary');
                document.documentElement.style.removeProperty('--category-secondary');
                document.documentElement.style.removeProperty('--category-accent');
                
                // Reset category button styling
                if (elements.categorySelectBtn) {
                    elements.categorySelectBtn.classList.remove('active');
                }
                return;
            }

            const categoryConfig = gameState.categoryColors.categories[category];
            if (!categoryConfig) {
                console.warn(`[Colors] No color configuration found for category: ${category}`);
                return;
            }

            // Update CSS custom properties for dynamic theming
            document.documentElement.style.setProperty('--category-primary', categoryConfig.primary);
            document.documentElement.style.setProperty('--category-secondary', categoryConfig.secondary);
            document.documentElement.style.setProperty('--category-accent', categoryConfig.accent);

            // Apply colors to specific UI elements
            const activeCategory = document.querySelector('.category-dropdown-item.active');
            if (activeCategory) {
                activeCategory.style.borderColor = categoryConfig.accent;
                activeCategory.style.background = `rgba(${hexToRgb(categoryConfig.primary)}, 0.2)`;
                activeCategory.style.color = categoryConfig.accent;
            }

            // Update category select button colors
            if (elements.categorySelectBtn) {
                elements.categorySelectBtn.classList.add('active');
            }

            // Apply accent color to selected song items
            document.querySelectorAll('.song-item.selected').forEach(item => {
                item.style.borderColor = categoryConfig.accent;
                item.style.background = `linear-gradient(45deg, ${categoryConfig.primary}, ${categoryConfig.secondary})`;
            });

            console.log(`[Colors] Applied colors for category: ${category}`, categoryConfig);
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                '255, 255, 255';
        }

        // Update song genre display based on project metadata
        async function updateSongGenreDisplay(project) {
            if (!elements.songGenre) return;
            
            // Default values for dummy songs
            if (!project.folder_name || project.folder_name.includes('_test')) {
                elements.songGenre.textContent = 'Demo';
                elements.songGenre.style.background = '#FF006E'; // Default color
                return;
            }
            
            try {
                const response = await fetch(`/api/metadata/${project.folder_name}`);
                const metadata = await response.json();
                
                if (response.ok && metadata) {
                    const category = metadata.category || 'Pop';
                    
                    // Update genre text
                    elements.songGenre.textContent = category;
                    
                    // Update genre color based on category
                    if (gameState.categoryColors && gameState.categoryColors.categories[category]) {
                        const categoryConfig = gameState.categoryColors.categories[category];
                        elements.songGenre.style.background = categoryConfig.primary;
                    } else {
                        // Fallback colors for each category
                        const fallbackColors = {
                            'Pop': '#FF6B9D',
                            'Trance': '#00D4FF', 
                            'Brutal': '#FF4444',
                            'Softcore': '#90EE90'
                        };
                        elements.songGenre.style.background = fallbackColors[category] || '#FF006E';
                    }
                } else {
                    // Fallback to default
                    elements.songGenre.textContent = 'Pop';
                    elements.songGenre.style.background = '#FF6B9D';
                }
            } catch (error) {
                console.warn(`Failed to load metadata for ${project.folder_name}:`, error);
                // Fallback to default
                elements.songGenre.textContent = 'Pop';
                elements.songGenre.style.background = '#FF6B9D';
            }
        }

        // Setup navigation buttons - called after songs are populated
        function setupNavigationButtons() {
            // Navigation buttons - with null checks and debugging
            const navButtonRight = document.getElementById('navButtonRight');
            const navButtonLeft = document.getElementById('navButtonLeft');

            console.log('[Navigation] Setting up navigation buttons...');
            console.log('[Navigation] Right button found:', !!navButtonRight);
            console.log('[Navigation] Left button found:', !!navButtonLeft);

            if (navButtonRight) {
                navButtonRight.addEventListener('click', () => {
                    console.log('[Navigation] Right button clicked');
                    goToRightmost();
                });
            } else {
                console.warn('[Navigation] Right button not found');
            }

            if (navButtonLeft) {
                navButtonLeft.addEventListener('click', () => {
                    console.log('[Navigation] Left button clicked');
                    goToLeftmost();
                });
            } else {
                console.warn('[Navigation] Left button not found');
            }
        }

        // Navigate to rightmost song
        function goToRightmost() {
            const songs = document.querySelectorAll('.song-item');
            if (songs.length > 0) {
                const rightmostSong = songs[songs.length - 1];
                const project = {
                    folder_name: rightmostSong.dataset.projectName,
                    display_name: rightmostSong.dataset.displayName
                };
                selectSong(rightmostSong, project);
            }
        }

        // Navigate to leftmost song
        function goToLeftmost() {
            const songs = document.querySelectorAll('.song-item');
            if (songs.length > 0) {
                const leftmostSong = songs[0];
                const project = {
                    folder_name: leftmostSong.dataset.projectName,
                    display_name: leftmostSong.dataset.displayName
                };
                selectSong(leftmostSong, project);
            }
        }

        function showStartButton() {
            // Show floating start button if a real song is selected
            if (gameState.selectedProject) {
                elements.startPerformanceBtn.classList.add('visible');
                console.log('[SongSelection] Start button shown');
            } else {
                elements.startPerformanceBtn.classList.remove('visible');
                console.log('[SongSelection] Start button hidden - no real song selected');
            }
        }

        function hideStartButton() {
            elements.startPerformanceBtn.classList.remove('visible');
            console.log('[SongSelection] Start button hidden');
        }

        // Curtain transition functions
        function showCurtain() {
            elements.curtain.classList.add('active');
            setTimeout(() => {
                elements.curtain.classList.add('closing');
            }, 50);
        }

        function hideCurtain() {
            elements.curtain.classList.remove('closing');
            elements.curtain.classList.add('opening');
            
            setTimeout(() => {
                elements.curtain.classList.remove('active', 'opening');
            }, 800);
        }


        function startPerformance() {
            if (gameState.selectedProject) {
                console.log('[SongSelection] Starting performance for:', gameState.selectedProject);
                
                // Show curtain
                showCurtain();
                
                // Hide song selection screen after curtain starts
                setTimeout(() => {
                    hideSongSelectionScreen();
                    // Start loading game behind curtain
                    loadGameWithCurtain(gameState.selectedProject);
                }, 400);
            } else {
                console.log('[SongSelection] Cannot start performance - no real song selected');
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Project loading
            // Game controls in pause menu
            elements.pauseBtn.addEventListener('click', () => {
                if (gameState.isPlaying && gameState.isPaused) {
                    // Resume
                    gameState.isPaused = false;
                    gameState.startTime = performance.now() - (gameState.currentTime * 1000);
                    gameState.audio.play();
                    gameLoop();
                } else {
                    // Start new game if not playing
                    if (!gameState.isPlaying) {
                        startGame();
                    }
                }
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.restartBtn.addEventListener('click', () => {
                if (gameState.currentProject) {
                    elements.gameOverScreen.style.display = 'none';
                    startGame();
                }
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.selectSongBtn.addEventListener('click', () => {
                // Show song selector
                elements.songSelector.classList.add('show');
                // Hide pause menu
                elements.pauseMenu.classList.remove('show');
            });
            
            elements.exitBtn.addEventListener('click', () => {
                if (confirm('确定要退出游戏吗？')) {
                    location.href = '/daw';
                }
            });
            
            // Don区域点击 - 简单直接
            elements.drumDon.addEventListener('click', (e) => {
                console.log('Don被点击了');
                e.stopPropagation(); // 防止冒泡到Ka区域
                hitDrum('don');
            });
            
            // Don区域触控
            elements.drumDon.addEventListener('touchstart', (e) => {
                console.log('Don被触控了');
                e.preventDefault();
                e.stopPropagation();
                hitDrum('don');
            });
            
            // Ka区域点击（整个鼓面减去Don区域）
            elements.unifiedDrum.addEventListener('click', (e) => {
                console.log('Ka被点击了');
                hitDrum('ka');
            });
            
            // Ka区域触控
            elements.unifiedDrum.addEventListener('touchstart', (e) => {
                console.log('Ka被触控了');
                e.preventDefault();
                hitDrum('ka');
            });
            
            // Game over screen
            elements.playAgainBtn.addEventListener('click', () => {
                elements.gameOverScreen.style.display = 'none';
                startGame();
            });
            
            elements.backToSelectionBtn.addEventListener('click', () => {
                elements.gameOverScreen.style.display = 'none';
                showSongSelectionScreen();
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                
                const key = e.key.toLowerCase();
                
                // Space bar for Don (咚)
                if (key === ' ') {
                    e.preventDefault();
                    hitDrum('don');
                    return;
                }
                
                // Enter for pause menu
                if (key === 'enter') {
                    e.preventDefault();
                    if (gameState.isPlaying) {
                        // Pause game and show menu
                        gameState.isPaused = true;
                        gameState.audio.pause();
                        elements.pauseMenu.classList.add('show');
                    } else {
                        // Show song selector if no game running
                        elements.songSelector.classList.add('show');
                    }
                    return;
                }
                
                // Letter keys for Ka (咔)
                const kaKeys = ['s', 'd', 'f', 'j', 'k', 'l', 'a', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'z', 'x', 'c', 'v', 'b', 'n', 'm'];
                if (kaKeys.includes(key)) {
                    e.preventDefault();
                    hitDrum('ka');
                    return;
                }
                
                // Special shortcuts
                if (key === 'escape') {
                    e.preventDefault();
                    // Hide any open menus
                    elements.pauseMenu.classList.remove('show');
                    elements.songSelector.classList.remove('show');
                }
            });
            
            // Prevent context menu on drum
            elements.unifiedDrum.addEventListener('contextmenu', e => e.preventDefault());
            
            // Setup song selection screen listeners
            setupSongSelectionListeners();
        }

        // Create SVG icons for don and ka notes
        function createDonSVG() {
            return `<img src="/static/user-crocodile.svg" alt="Don" style="width: 40px; height: 40px; pointer-events: none; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));" />`;
        }

        function createKaSVG() {
            return `<img src="/static/user-bird.svg" alt="Ka" style="width: 40px; height: 40px; pointer-events: none; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));" />`;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>