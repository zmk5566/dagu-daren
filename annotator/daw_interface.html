<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大鼓达人 - DAW 专业标注工具</title>
    <style>
        /* Modern DAW-style CSS */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --accent-primary: #0078d4;
            --accent-secondary: #106ebe;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #999999;
            --border-color: #444444;
            --success-color: #107c10;
            --warning-color: #ff8c00;
            --error-color: #d13438;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Header */
        .daw-header {
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .daw-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .daw-version {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: 10px;
        }

        /* Main Layout */
        .daw-layout {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* Sidebar */
        .daw-sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            height: 100%;
            scroll-behavior: smooth;
        }

        /* Custom scrollbar for sidebar */
        .daw-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .daw-sidebar::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .daw-sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .daw-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .daw-panel {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .daw-panel-header {
            background: var(--bg-tertiary);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .daw-panel-content {
            padding: 16px;
            overflow-y: auto;
        }

        .daw-panel.collapsed .daw-panel-content {
            display: none;
        }

        /* Individual panel max heights to prevent any one panel from taking all space */
        #project-panel .daw-panel-content {
            max-height: 150px;
        }

        #bpm-panel .daw-panel-content {
            max-height: 250px;
        }

        #align-panel .daw-panel-content {
            max-height: 350px;
        }

        #annotations-panel .daw-panel-content {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Make panels more compact when needed */
        .daw-panel-content .form-group {
            margin-bottom: 12px;
        }

        .daw-panel-content .btn {
            margin-bottom: 8px;
        }

        /* Ensure content is always accessible */
        .daw-panel-content {
            min-height: 0; /* Allow flexbox to shrink */
        }

        /* Add visual hint when content is scrollable */
        .daw-panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .daw-panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .daw-panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .daw-panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .panel-toggle {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Main Content */
        .daw-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .daw-toolbar {
            height: 50px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
        }

        /* Transport Controls */
        .transport-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 20px;
            padding-right: 20px;
            border-right: 1px solid var(--border-color);
        }

        .transport-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .transport-btn:hover {
            background: var(--accent-primary);
        }

        .transport-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .transport-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        /* Snap Precision Dropdown */
        .snap-precision-container {
            display: flex;
            align-items: center;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border-color);
        }

        .snap-precision-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 4px 8px;
            min-width: 140px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .snap-precision-select:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-secondary);
        }

        .snap-precision-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
        }

        /* BPM Display */
        .bpm-display {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 8px;
            border-right: 1px solid var(--border-color);
            white-space: nowrap;
            min-width: 60px;
        }

        .bpm-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .bpm-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            min-width: 24px;
            text-align: left;
        }

        /* Timeline Container */
        .timeline-container {
            flex: 1;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        /* Timeline Header */
        .timeline-header {
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .timeline-ruler {
            height: 100%;
            position: relative;
            background: linear-gradient(to right, var(--border-color) 0px, transparent 1px);
            background-size: 50px 100%;
            cursor: ns-resize;
        }

        .timeline-ruler:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        /* Waveform Area */
        .waveform-area {
            height: 150px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
            z-index: 2;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        /* Beat Grid Overlay */
        .beat-grid-overlay {
            position: absolute;
            top: 40px; /* Below timeline-header */
            left: 0;
            width: 100%;
            height: calc(100% - 40px); /* Fill remaining space */
            pointer-events: none;
            z-index: 1; /* Behind tracks */
            overflow: hidden;
        }

        .beat-line {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
        }

        .beat-line.downbeat {
            background: rgba(0, 0, 0, 0.4);
            width: 2px;
        }

        .beat-line.subdivision {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Annotation Track */
        .annotation-track {
            height: 60px;
            background: transparent; /* Make it transparent to see grid lines behind */
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2; /* Put it above the grid */
        }

        /* Score Track */
        .score-track {
            height: 60px;
            background: transparent;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2;
        }

        .annotation-marker {
            position: absolute;
            top: 5px;
            height: 50px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }

        .annotation-marker.don {
            background: #ff6347;
        }

        .annotation-marker.ka {
            background: #4169e1;
        }

        .annotation-marker:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .annotation-marker.selected {
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 10px var(--accent-primary);
        }

        /* Score Markers */
        .score-marker {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.2s;
            transform: translateY(-50%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        .score-marker.don {
            background: rgba(255, 99, 71, 0.7);
            box-shadow: 0 2px 8px rgba(255, 99, 71, 0.4);
        }

        .score-marker.ka {
            background: rgba(65, 105, 225, 0.7);
            box-shadow: 0 2px 8px rgba(65, 105, 225, 0.4);
        }

        .score-marker:hover {
            transform: translateY(-50%) scale(1.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }

        .score-marker.selected {
            border: 3px solid var(--warning-color);
            box-shadow: 0 0 15px var(--warning-color);
            transform: translateY(-50%) scale(1.1);
        }

        .score-marker.dragging {
            opacity: 0.7;
            transform: translateY(-50%) scale(1.3);
            z-index: 1000;
            cursor: grabbing !important;
        }

        /* Drop target indicator */
        .drop-target-indicator {
            position: absolute;
            top: 50%;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.2s;
            transform: translateY(-50%);
            border: 3px dashed rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            z-index: 999;
            pointer-events: none;
        }

        /* Score Context Menu */
        .score-context-menu {
            position: fixed !important;
            background: #2d2d2d !important;
            border: 2px solid #666666 !important;
            border-radius: 8px !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8) !important;
            z-index: 10000 !important;
            min-width: 140px !important;
            padding: 8px 0 !important;
            backdrop-filter: blur(8px) !important;
            /* Make sure it's visible */
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }

        .context-menu-item {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            padding: 10px 16px !important;
            color: #ffffff !important;
            cursor: pointer !important;
            transition: background-color 0.2s !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            white-space: nowrap !important;
        }

        .context-menu-item:hover {
            background: #3d3d3d !important;
        }

        .context-menu-item.danger:hover {
            background: #d13438 !important;
            color: white !important;
        }

        .context-menu-item .menu-icon {
            width: 16px;
            text-align: center;
            font-size: 14px;
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Hover indicator line */
        .hover-indicator-line {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: var(--accent-primary);
            opacity: 0.7;
            z-index: 100;
            pointer-events: none;
            transition: left 0.1s ease-out;
            box-shadow: 0 0 4px rgba(0, 123, 255, 0.5);
        }

        .hover-indicator-line::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -3px;
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0, 123, 255, 0.8);
        }

        /* Selected time indicator (more prominent when menu is open) */
        .hover-indicator-line.selected {
            background: var(--warning-color);
            opacity: 0.9;
            width: 3px;
            box-shadow: 0 0 8px rgba(255, 140, 0, 0.7);
        }

        .hover-indicator-line.selected::before {
            background: var(--warning-color);
            width: 10px;
            height: 10px;
            left: -4px;
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.9);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 14px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-error {
            background: var(--error-color);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .btn-block {
            width: 100%;
            justify-content: center;
        }

        /* Status Display */
        .status-message {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 8px;
        }

        .status-success {
            background: rgba(16, 124, 16, 0.2);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-warning {
            background: rgba(255, 140, 0, 0.2);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }

        .status-error {
            background: rgba(209, 52, 56, 0.2);
            color: var(--error-color);
            border: 1px solid var(--error-color);
        }

        /* Annotations List */
        .annotations-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
        }

        .annotation-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .annotation-item:hover {
            background: var(--bg-tertiary);
        }

        .annotation-item.selected {
            background: var(--accent-primary);
        }

        .annotation-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .annotation-type {
            font-weight: 600;
            text-transform: uppercase;
        }

        .annotation-type.don {
            color: #ff6347;
        }

        .annotation-type.ka {
            color: #4169e1;
        }

        .annotation-time {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 30, 30, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            z-index: 1000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-size: 14px;
        }


        /* Range Slider */
        .range-slider {
            width: 100%;
            margin: 10px 0;
        }

        .range-input {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        .range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
        }

        .range-input::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .daw-sidebar {
                width: 250px;
            }
        }

        @media (max-width: 768px) {
            .daw-sidebar {
                position: absolute;
                left: -300px;
                top: 0;
                height: 100%;
                z-index: 1000;
                transition: left 0.3s;
            }

            .daw-sidebar.open {
                left: 0;
            }

            .daw-header {
                padding: 0 10px;
            }

            .daw-toolbar {
                padding: 0 10px;
                flex-wrap: wrap;
                height: auto;
                min-height: 50px;
            }
        }

        /* Tracks Wrapper */
        .tracks-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Track Labels Panel */
        .daw-track-labels {
            width: 120px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            transition: width 0.3s ease;
            overflow: hidden;
        }

        .daw-track-labels.collapsed {
            width: 30px; /* Keep enough space for the toggle button */
        }

        .daw-track-labels.collapsed .track-labels-content {
            display: none;
        }

        .track-label-header {
            height: 40px; /* Match timeline-header */
            display: flex;
            align-items: center;
            justify-content: center; /* Center the button */
            border-bottom: 1px solid var(--border-color);
        }

        .track-label-toggle {
            width: 24px;
            height: 24px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: transform 0.3s ease;
        }
        
        .daw-track-labels.collapsed .track-label-toggle {
            transform: rotate(-180deg);
        }

        .track-label-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
            overflow: hidden;
            white-space: nowrap;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: flex-start;
            gap: 10px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            position: relative;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.hide {
            opacity: 0;
            transform: translateX(100%);
        }

        .toast-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .toast.success .toast-icon {
            background: var(--success-color);
            color: white;
        }

        .toast.error .toast-icon {
            background: var(--error-color);
            color: white;
        }

        .toast.warning .toast-icon {
            background: var(--warning-color);
            color: white;
        }

        .toast.info .toast-icon {
            background: var(--accent-primary);
            color: white;
        }

        .toast-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .toast-close {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .toast-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--accent-primary);
            border-radius: 0 0 8px 8px;
            transition: width 0.1s linear;
        }

        .toast.success .toast-progress {
            background: var(--success-color);
        }

        .toast.error .toast-progress {
            background: var(--error-color);
        }

        .toast.warning .toast-progress {
            background: var(--warning-color);
        }

        /* Export Popup Menu */
        .export-popup-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 160px;
            margin-top: 4px;
        }

        .popup-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid var(--border-color);
        }

        .popup-menu-item:last-child {
            border-bottom: none;
        }

        .popup-menu-item:hover {
            background: var(--bg-tertiary);
        }

        .popup-menu-item:active {
            background: var(--accent-primary);
        }

        .menu-icon {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        .menu-text {
            font-size: 13px;
            font-weight: 500;
        }

        /* Audio Source Selector */
        .audio-source-container {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 12px;
            border-right: 1px solid var(--border-color);
            white-space: nowrap;
        }

        .audio-source-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .audio-source-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 4px 6px;
            min-width: 80px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .audio-source-select:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-secondary);
        }

        .audio-source-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
        }

        /* Project Info Display */
        .form-display {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        /* Image Summary Styles */
        .image-summary {
            margin-top: 10px;
        }

        .image-summary-preview {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .image-summary-count {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-align: center;
        }

        .image-summary-thumbs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            min-height: 40px;
            align-items: center;
        }

        .image-summary-thumb {
            width: 32px;
            height: 24px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .image-summary-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-summary-thumb:empty::before {
            content: '📷';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Image Editor Modal Styles */
        .image-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-editor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .image-editor-container {
            position: relative;
            width: 90%;
            max-width: 800px;
            max-height: 90%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .image-editor-header {
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .image-editor-title {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .image-editor-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .image-editor-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .image-editor-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .image-editor-footer {
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Modal Image Category Styles */
        .image-editor-modal .image-category {
            margin-bottom: 24px;
            padding: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .image-editor-modal .image-category-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 16px 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .image-editor-modal .image-slots {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .image-editor-modal .image-slot {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 16px;
            text-align: center;
        }

        .image-slot-info {
            margin-bottom: 12px;
        }

        .image-editor-modal .image-slot-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .image-slot-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .image-editor-modal .image-preview {
            width: 120px;
            height: 90px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: 4px;
            margin: 0 auto 12px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 24px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .image-editor-modal .image-preview:empty::before {
            content: '📷';
        }

        .image-editor-modal .image-preview.has-image {
            border-style: solid;
            border-color: var(--accent-primary);
        }

        .image-editor-modal .image-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 2px;
        }

        .image-input {
            display: none;
        }

        .image-editor-modal .image-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .upload-btn {
            background: var(--accent-primary);
            color: var(--text-white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .upload-btn:hover {
            background: var(--accent-secondary);
        }

        .remove-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .remove-btn:hover {
            background: var(--error-color);
            color: var(--text-white);
            border-color: var(--error-color);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="daw-header">
        <div>
            <span class="daw-title">大鼓达人</span>
            <span class="daw-version">DAW 专业标注工具 v1.0</span>
        </div>
        <div>
            <button class="btn btn-primary btn-small" onclick="window.open('/game', '_blank')" title="开始游戏">
                🎮 演奏模式
            </button>
            <button class="btn btn-secondary btn-small" id="sidebar-toggle">
                <span>☰</span>
            </button>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="daw-layout">
        <!-- Sidebar -->
        <div class="daw-sidebar" id="sidebar">
            <!-- Project Panel -->
            <div class="daw-panel" id="project-panel">
                <div class="daw-panel-header" onclick="togglePanel('project-panel')">
                    <span>项目</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="form-group">
                        <label class="form-label">选择项目</label>
                        <select class="form-select" id="project-selector">
                            <option value="">-- 请选择项目 --</option>
                        </select>
                    </div>
                    <button class="btn btn-primary btn-block" id="load-project-btn">
                        加载项目
                    </button>
                </div>
            </div>

            <!-- Project Info Panel -->
            <div class="daw-panel" id="project-info-panel" style="display: none;">
                <div class="daw-panel-header" onclick="togglePanel('project-info-panel')">
                    <span>项目信息</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="form-group">
                        <label class="form-label">当前项目</label>
                        <div class="form-display" id="current-project-display">未加载项目</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">项目显示名称</label>
                        <div style="display: flex; gap: 5px;">
                            <input type="text" class="form-control" id="project-display-name-input" placeholder="输入友好的项目名称">
                            <button class="btn btn-secondary" id="update-display-name-btn" style="width: auto; padding: 0 12px;">
                                更新
                            </button>
                        </div>
                        <div id="display-name-status" style="margin-top: 5px; font-size: 12px;"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">歌曲类别</label>
                        <div style="display: flex; gap: 5px;">
                            <select class="form-select" id="project-category-select">
                                <option value="Pop">Pop</option>
                                <option value="Trance">Trance</option>
                                <option value="Brutal">Brutal</option>
                                <option value="Softcore">Softcore</option>
                            </select>
                            <button class="btn btn-secondary" id="update-category-btn" style="width: auto; padding: 0 12px;">
                                更新
                            </button>
                        </div>
                        <div id="category-status" style="margin-top: 5px; font-size: 12px;"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">难度等级</label>
                        <div style="display: flex; gap: 5px;">
                            <input type="number" class="form-input" id="project-difficulty-input" min="1" max="9" step="1" placeholder="1-9">
                            <button class="btn btn-secondary" id="update-difficulty-btn" style="width: auto; padding: 0 12px;">
                                更新
                            </button>
                        </div>
                        <div id="difficulty-status" style="margin-top: 5px; font-size: 12px;"></div>
                    </div>
                    <!-- 游戏图片资源简洁预览 -->
                    <div class="form-group">
                        <label class="form-label">游戏图片资源</label>
                        <div class="image-summary">
                            <div class="image-summary-preview" id="image-summary-preview">
                                <div class="image-summary-count">0/6 已上传</div>
                                <div class="image-summary-thumbs" id="image-summary-thumbs">
                                    <!-- 缩略图将在这里显示 -->
                                </div>
                            </div>
                            <button type="button" class="btn btn-primary btn-block" id="edit-images-btn">
                                编辑图片
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- BPM Analysis Panel -->
            <div class="daw-panel" id="bpm-panel">
                <div class="daw-panel-header" onclick="togglePanel('bpm-panel')">
                    <span>BPM 分析</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="form-group">
                        <label class="form-label">BPM 检测音源</label>
                        <select class="form-select" id="bpm-source-select">
                            <option value="drums">鼓轨 (drums.mp3)</option>
                            <option value="original">原曲 (更准确)</option>
                        </select>
                    </div>
                    <button class="btn btn-secondary btn-block" id="detect-bpm-btn" disabled>
                        检测 BPM
                    </button>
                    <div class="form-group">
                        <label class="form-label">手动 BPM</label>
                        <input type="number" class="form-input" id="manual-bpm" placeholder="120.0" step="0.1" min="60" max="200">
                    </div>
                    <button class="btn btn-secondary btn-block" id="generate-beats-btn" disabled>
                        生成节拍网格
                    </button>
                    <button class="btn btn-primary btn-block" id="generate-score-btn" disabled style="margin-top: 8px;">
                        生成曲谱
                    </button>
                </div>
            </div>


            <!-- Annotations Panel -->
            <div class="daw-panel" id="annotations-panel">
                <div class="daw-panel-header" onclick="togglePanel('annotations-panel')">
                    <span>标注列表</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="annotations-list" id="annotations-list">
                        <div style="text-align: center; color: var(--text-muted); padding: 20px;">
                            暂无标注
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="daw-main">
            <!-- Toolbar -->
            <div class="daw-toolbar">
                <!-- BPM Display -->
                <div class="bpm-display">
                    <span class="bpm-label">BPM:</span>
                    <span class="bpm-value" id="bpm-value">--</span>
                </div>

                <!-- Audio Source Selector -->
                <div class="audio-source-container">
                    <label class="audio-source-label">音源:</label>
                    <select class="audio-source-select" id="audio-source-select" title="选择音频源">
                        <option value="drums">🥁 单鼓</option>
                        <option value="backing">🎵 无鼓</option>
                        <option value="original">🎶 原曲</option>
                    </select>
                </div>

                <!-- Transport Controls -->
                <div class="transport-controls">
                    <button class="transport-btn" id="play-btn" disabled title="播放/暂停 (空格键)">
                        <span>▶</span>
                    </button>
                    <button class="transport-btn" id="stop-btn" disabled title="停止">
                        <span>⏹</span>
                    </button>
                    <button class="transport-btn" id="loop-btn" disabled title="循环播放">
                        <span>🔁</span>
                    </button>
                </div>

                <!-- Zoom Controls -->
                <div class="transport-controls">
                    <button class="transport-btn" id="zoom-out-btn" disabled title="缩小 (Ctrl+滚轮)">
                        <span>-</span>
                    </button>
                    <button class="transport-btn" id="zoom-in-btn" disabled title="放大 (Ctrl+滚轮)">
                        <span>+</span>
                    </button>
                </div>

                <!-- Tool Selection -->
                <div class="transport-controls">
                    <button class="transport-btn" id="tool-select" title="选择工具">
                        <span>🔍</span>
                    </button>
                    <button class="transport-btn" id="tool-don" title="Don 工具 (D键)">
                        <span>咚</span>
                    </button>
                    <button class="transport-btn" id="tool-ka" title="Ka 工具 (K键)">
                        <span>咔</span>
                    </button>
                    
                    <!-- Snap Precision Dropdown -->
                    <div class="snap-precision-container">
                        <label for="snap-precision-select" style="font-size: 11px; color: var(--text-secondary); margin-right: 4px;">吸附:</label>
                        <select class="snap-precision-select" id="snap-precision-select" title="选择吸附精度">
                            <option value="1/4">1/4 - 四分音符</option>
                            <option value="1/8">1/8 - 八分音符</option>
                            <option value="1/16" selected>1/16 - 十六分音符</option>
                            <option value="1/8T">1/8T - 八分三连音</option>
                            <option value="1/16T">1/16T - 十六分三连音</option>
                            <option value="1/32">1/32 - 三十二分音符</option>
                        </select>
                        
                        <!-- Export Button with Popup Menu -->
                        <div class="export-menu-container" style="position: relative; margin-left: 8px;">
                            <button class="transport-btn" id="export-menu-btn" disabled title="导出选项" style="padding: 6px 12px; font-size: 12px;">
                                导出
                            </button>
                            <div class="export-popup-menu" id="export-popup-menu" style="display: none;">
                                <div class="popup-menu-item" id="save-annotations-menu">
                                    <span class="menu-icon">💾</span>
                                    <span class="menu-text">保存标注</span>
                                </div>
                                <div class="popup-menu-item" id="export-audio-samples-menu">
                                    <span class="menu-icon">🎵</span>
                                    <span class="menu-text">导出音频样本</span>
                                </div>
                                <div class="popup-menu-item" id="save-score-menu">
                                    <span class="menu-icon">🎼</span>
                                    <span class="menu-text">保存曲谱</span>
                                </div>
                                <div class="popup-menu-item" id="save-all-menu">
                                    <span class="menu-icon">📋</span>
                                    <span class="menu-text">全部保存</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tracks Wrapper -->
            <div class="tracks-wrapper">
                <!-- Track Labels Panel -->
                <div class="daw-track-labels" id="track-labels">
                    <div class="track-label-header">
                        <button class="track-label-toggle" id="toggle-track-labels" title="收起/展开轨道列表">‹</button>
                    </div>
                    <div class="track-labels-content">
                        <div class="track-label-item" style="height: 151px;"> <!-- 150px height + 1px border -->
                            <span>音频轨道</span>
                        </div>
                        <div class="track-label-item" style="height: 61px;"> <!-- 60px height + 1px border -->
                            <span>标记 Track</span>
                        </div>
                        <div class="track-label-item" style="height: 61px;"> <!-- 60px height + 1px border -->
                            <span>曲谱 Track</span>
                        </div>
                    </div>
                </div>

                <!-- Timeline Container -->
                <div class="timeline-container" id="timeline-container">
                    <div class="beat-grid-overlay" id="beat-grid-overlay"></div>
                    <!-- Timeline Header with Ruler -->
                    <div class="timeline-header">
                        <div class="timeline-ruler" id="timeline-ruler"></div>
                    </div>

                    <!-- Waveform Area -->
                    <div class="waveform-area">
                        <div id="waveform"></div>
                    </div>

                    <!-- Annotation Track -->
                    <div class="annotation-track" id="annotation-track">
                        <!-- Annotation markers will be placed here -->
                    </div>

                    <!-- Score Track -->
                    <div class="score-track" id="score-track">
                        <!-- Score markers will be placed here -->
                    </div>

                    <!-- Loading Overlay -->
                    <div class="loading-overlay" id="loading-overlay" style="display: none;">
                        <div class="loading-spinner"></div>
                        <div class="loading-text" id="loading-text">加载中...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- Include WaveSurfer.js -->
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>

    <script>
        // Toast Notification System
        class ToastManager {
            constructor() {
                this.container = document.getElementById('toast-container');
                this.toasts = new Map();
                this.nextId = 1;
            }

            show(message, type = 'info', title = null, duration = 5000) {
                const id = this.nextId++;
                const toast = this.createToast(id, message, type, title, duration);
                
                this.container.appendChild(toast);
                this.toasts.set(id, { element: toast, timer: null });

                // Trigger animation
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });

                // Auto-dismiss if duration is set
                if (duration > 0) {
                    this.startAutoClose(id, duration);
                }

                return id;
            }

            createToast(id, message, type, title, duration) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.dataset.id = id;

                const iconMap = {
                    success: '✓',
                    error: '✕',
                    warning: '⚠',
                    info: 'ℹ'
                };

                toast.innerHTML = `
                    <div class="toast-icon">${iconMap[type] || 'ℹ'}</div>
                    <div class="toast-content">
                        ${title ? `<div class="toast-title">${title}</div>` : ''}
                        <div class="toast-message">${message}</div>
                    </div>
                    <button class="toast-close" onclick="toastManager.close(${id})">&times;</button>
                    ${duration > 0 ? '<div class="toast-progress"></div>' : ''}
                `;

                return toast;
            }

            startAutoClose(id, duration) {
                const toastData = this.toasts.get(id);
                if (!toastData) return;

                const progressBar = toastData.element.querySelector('.toast-progress');
                let elapsed = 0;
                const interval = 50;

                const timer = setInterval(() => {
                    elapsed += interval;
                    const progress = (elapsed / duration) * 100;
                    
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(progress, 100)}%`;
                    }

                    if (elapsed >= duration) {
                        clearInterval(timer);
                        this.close(id);
                    }
                }, interval);

                toastData.timer = timer;
            }

            close(id) {
                const toastData = this.toasts.get(id);
                if (!toastData) return;

                if (toastData.timer) {
                    clearInterval(toastData.timer);
                }

                toastData.element.classList.remove('show');
                toastData.element.classList.add('hide');

                setTimeout(() => {
                    if (toastData.element.parentNode) {
                        toastData.element.parentNode.removeChild(toastData.element);
                    }
                    this.toasts.delete(id);
                }, 300);
            }

            success(message, title = null, duration = 5000) {
                return this.show(message, 'success', title, duration);
            }

            error(message, title = null, duration = 8000) {
                return this.show(message, 'error', title, duration);
            }

            warning(message, title = null, duration = 6000) {
                return this.show(message, 'warning', title, duration);
            }

            info(message, title = null, duration = 5000) {
                return this.show(message, 'info', title, duration);
            }

            loading(message, title = '处理中...') {
                return this.show(message, 'info', title, 0); // No auto-close for loading
            }
        }

        // Initialize toast manager
        const toastManager = new ToastManager();

        // DAW Interface JavaScript
        document.addEventListener('DOMContentLoaded', () => {
            // Global state
            let currentProject = '';
            let annotations = [];
            let score = [];
            let beatGrid = null;
            let bpmData = null;
            let selectedAnnotation = null;
            let currentTool = 'select';
            let isLooping = false;
            let quantizeMode = '1/16';  // Default snap precision
            let audioOffset = 0.0;  // Keep for backward compatibility (unused)
            let scoreOffset = 0.0;  // Keep for backward compatibility (unused)
            let currentAudioSource = 'drums';  // Current audio source: drums, backing, original
            let isSwitchingAudio = false;  // Flag to prevent auto-zoom during audio switching
            
            // Drag and drop state
            let isDragging = false;
            let draggedScoreItem = null;
            let draggedElement = null;
            let dropTargetIndicator = null;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragStartTime = 0;
            let dragThreshold = 5; // Pixels threshold to distinguish between click and drag
            
            // Context menu state
            let currentContextMenu = null;
            let contextMenuScoreItem = null;
            
            // Track hover state
            let hoverIndicatorLine = null;
            let currentHoverTime = 0;
            let selectedTime = 0; // Persistent selected time for insertion
            let isMenuOpen = false; // Track if context menu is open

            // DOM elements
            const elements = {
                projectSelector: document.getElementById('project-selector'),
                loadProjectBtn: document.getElementById('load-project-btn'),
                projectInfoPanel: document.getElementById('project-info-panel'),
                currentProjectDisplay: document.getElementById('current-project-display'),
                projectDisplayNameInput: document.getElementById('project-display-name-input'),
                updateDisplayNameBtn: document.getElementById('update-display-name-btn'),
                displayNameStatus: document.getElementById('display-name-status'),
                projectCategorySelect: document.getElementById('project-category-select'),
                updateCategoryBtn: document.getElementById('update-category-btn'),
                categoryStatus: document.getElementById('category-status'),
                projectDifficultyInput: document.getElementById('project-difficulty-input'),
                updateDifficultyBtn: document.getElementById('update-difficulty-btn'),
                difficultyStatus: document.getElementById('difficulty-status'),
                // Image summary elements
                imageSummaryPreview: document.getElementById('image-summary-preview'),
                imageSummaryThumbs: document.getElementById('image-summary-thumbs'),
                editImagesBtn: document.getElementById('edit-images-btn'),
                // Image editor modal elements
                imageEditorModal: document.getElementById('image-editor-modal'),
                imageEditorOverlay: document.getElementById('image-editor-overlay'),
                imageEditorClose: document.getElementById('image-editor-close'),
                imageEditorCancel: document.getElementById('image-editor-cancel'),
                imageEditorSave: document.getElementById('image-editor-save'),
                bpmSourceSelect: document.getElementById('bpm-source-select'),
                detectBpmBtn: document.getElementById('detect-bpm-btn'),
                manualBpm: document.getElementById('manual-bpm'),
                generateBeatsBtn: document.getElementById('generate-beats-btn'),
                generateScoreBtn: document.getElementById('generate-score-btn'),
                annotationsList: document.getElementById('annotations-list'),
                playBtn: document.getElementById('play-btn'),
                stopBtn: document.getElementById('stop-btn'),
                loopBtn: document.getElementById('loop-btn'),
                zoomInBtn: document.getElementById('zoom-in-btn'),
                zoomOutBtn: document.getElementById('zoom-out-btn'),
                toolSelect: document.getElementById('tool-select'),
                toolDon: document.getElementById('tool-don'),
                toolKa: document.getElementById('tool-ka'),
                bpmValue: document.getElementById('bpm-value'),
                beatGridOverlay: document.getElementById('beat-grid-overlay'),
                annotationTrack: document.getElementById('annotation-track'),
                scoreTrack: document.getElementById('score-track'),
                timelineRuler: document.getElementById('timeline-ruler'),
                loadingOverlay: document.getElementById('loading-overlay'),
                loadingText: document.getElementById('loading-text'),
                sidebarToggle: document.getElementById('sidebar-toggle'),
                sidebar: document.getElementById('sidebar'),
                trackLabels: document.getElementById('track-labels'),
                toggleTrackLabelsBtn: document.getElementById('toggle-track-labels'),
                snapPrecisionSelect: document.getElementById('snap-precision-select'),
                exportMenuBtn: document.getElementById('export-menu-btn'),
                exportPopupMenu: document.getElementById('export-popup-menu'),
                saveAnnotationsMenuBtn: document.getElementById('save-annotations-menu'),
                exportAudioSamplesMenuBtn: document.getElementById('export-audio-samples-menu'),
                saveScoreMenuBtn: document.getElementById('save-score-menu'),
                saveAllMenuBtn: document.getElementById('save-all-menu'),
                audioSourceSelect: document.getElementById('audio-source-select')
            };


            // Initialize WaveSurfer
            const wavesurfer = WaveSurfer.create({
                container: document.getElementById('waveform'),
                waveColor: '#4a4a4a',
                progressColor: '#0078d4',
                cursorWidth: 2,
                cursorColor: '#ffffff',
                barWidth: 2,
                barGap: 1,
                responsive: true,
                height: 150,
                backend: 'WebAudio'
            });

            // Initialize regions plugin
            const wsRegions = wavesurfer.registerPlugin(WaveSurfer.Regions.create());

            // Utility functions
            let currentLoadingToast = null;

            function showLoading(text) {
                // Close previous loading toast if exists
                if (currentLoadingToast !== null) {
                    toastManager.close(currentLoadingToast);
                }
                currentLoadingToast = toastManager.loading(text);
            }

            function hideLoading() {
                if (currentLoadingToast !== null) {
                    toastManager.close(currentLoadingToast);
                    currentLoadingToast = null;
                }
            }

            function showStatus(element, message, type = 'info') {
                // Use toast instead of inline status
                switch (type) {
                    case 'success':
                        toastManager.success(message);
                        break;
                    case 'error':
                        toastManager.error(message);
                        break;
                    case 'warning':
                        toastManager.warning(message);
                        break;
                    default:
                        toastManager.info(message);
                }
            }

            // Make togglePanel globally accessible
            window.togglePanel = function(panelId) {
                const panel = document.getElementById(panelId);
                const toggle = panel.querySelector('.panel-toggle');
                panel.classList.toggle('collapsed');
                toggle.textContent = panel.classList.contains('collapsed') ? '▶' : '▼';
            };

            // Load projects
            async function loadProjects() {
                try {
                    const response = await fetch('/api/projects');
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        elements.projectSelector.innerHTML = '<option value="">-- 请选择项目 --</option>';
                        data.projects.forEach(project => {
                            const option = document.createElement('option');
                            // Use folder_name as value for backend compatibility
                            option.value = project.folder_name;
                            // Display the friendly display_name to user
                            option.textContent = project.display_name;
                            // Store both values for potential future use
                            option.dataset.folderName = project.folder_name;
                            option.dataset.displayName = project.display_name;
                            elements.projectSelector.appendChild(option);
                        });
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `加载项目列表失败: ${error.message}`, 'error');
                }
            }

            // Load project metadata
            async function loadProjectMetadata(projectName) {
                try {
                    const response = await fetch(`/api/metadata/${projectName}`);
                    
                    if (response.status === 404) {
                        // Metadata doesn't exist, need to auto-detect BPM
                        console.log('Metadata not found, auto-detecting BPM...');
                        await detectBPM(); // This will create metadata.json
                        
                        // Try loading metadata again
                        const retryResponse = await fetch(`/api/metadata/${projectName}`);
                        if (retryResponse.ok) {
                            const retryData = await retryResponse.json();
                            return retryData.metadata;
                        }
                        return null;
                    }
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.metadata;
                    }
                    
                    return null;
                } catch (error) {
                    console.warn('Failed to load metadata:', error);
                    return null;
                }
            }

            // Get audio path based on current source and project
            function getAudioPath(projectName, source = currentAudioSource) {
                const basePath = `data/${projectName}`;
                switch (source) {
                    case 'drums':
                        return `${basePath}/generated_audio/drums.mp3`;
                    case 'backing':
                        return `${basePath}/generated_audio/backing_track_no_drums.mp3`;
                    case 'original':
                        return `${basePath}/${projectName}.mp3`;
                    default:
                        return `${basePath}/generated_audio/drums.mp3`;
                }
            }

            // Switch audio source
            async function switchAudioSource(source) {
                if (!currentProject) {
                    toastManager.warning('请先加载项目');
                    return;
                }

                if (source === currentAudioSource) {
                    return; // Already using this source
                }

                showLoading(`切换到${getSourceDisplayName(source)}...`);
                isSwitchingAudio = true;  // 标记正在切换音频

                try {
                    // 1. 停止当前音频
                    wavesurfer.stop();

                    const audioPath = getAudioPath(currentProject, source);
                    const response = await fetch(audioPath);
                    
                    if (!response.ok) {
                        throw new Error(`音频文件不存在: ${audioPath}`);
                    }

                    const audioBlob = await response.blob();
                    await wavesurfer.load(URL.createObjectURL(audioBlob));

                    // 2. 保持当前缩放比例或使用较小的默认缩放
                    if (currentPxPerSec === 100) {
                        // 如果还是默认值，设置一个较小的缩放比例（显示更多内容）
                        currentPxPerSec = Math.max(minPxPerSec, 80);
                    }
                    // 否则保持用户设置的缩放比例
                    
                    wavesurfer.zoom(currentPxPerSec);
                    
                    // Re-render all overlays with current zoom level
                    renderBeatGrid();
                    renderTimelineRuler();
                    renderAnnotations();
                    renderScore();
                    syncTimelineScroll();

                    // 3. 再次触发停止，确保光标移动到最前方
                    wavesurfer.stop();

                    currentAudioSource = source;
                    updateAudioSourceDisplay();
                    toastManager.success(`已切换到${getSourceDisplayName(source)}`);

                } catch (error) {
                    toastManager.error(`切换音频源失败: ${error.message}`);
                    console.error('Failed to switch audio source:', error);
                } finally {
                    isSwitchingAudio = false;  // 重置标记
                    hideLoading();
                }
            }

            // Get display name for audio source
            function getSourceDisplayName(source) {
                switch (source) {
                    case 'drums': return '单鼓';
                    case 'backing': return '无鼓';
                    case 'original': return '原曲';
                    default: return '单鼓';
                }
            }

            // Update audio source display
            function updateAudioSourceDisplay() {
                elements.audioSourceSelect.value = currentAudioSource;
            }

            // Load project
            async function loadProject(projectName) {
                currentProject = projectName;
                showLoading('加载项目音频...');

                try {
                    const audioPath = getAudioPath(projectName, currentAudioSource);
                    const response = await fetch(audioPath);
                    
                    if (!response.ok) {
                        throw new Error(`音频文件不存在: ${audioPath}`);
                    }

                    const audioBlob = await response.blob();
                    await wavesurfer.load(URL.createObjectURL(audioBlob));
                    
                    // Load existing annotations and score
                    await loadAnnotations(projectName);
                    await loadScore(projectName);
                    
                    // Load project metadata (BPM, etc.)
                    const metadata = await loadProjectMetadata(projectName);
                    if (metadata && metadata.bpm_data) {
                        // Use metadata to populate BPM info
                        bmpData = metadata.bpm_data; // Use existing variable name for consistency
                        elements.bpmValue.textContent = Math.round(metadata.bpm_data.bpm);
                        elements.manualBpm.value = metadata.bpm_data.bpm;
                        elements.generateBeatsBtn.disabled = false;
                        
                        // Apply audio offset for downbeat alignment
                        audioOffset = metadata.bpm_data.offset || 0.0;
                        if (audioOffset !== 0) {
                            console.log(`[Offset] Applied audio offset: ${audioOffset.toFixed(3)}s for downbeat alignment`);
                            // The offset will be applied in all time-related calculations
                        }
                        
                        // Auto-generate beat grid using the BPM from metadata
                        await generateBeatGrid();
                        
                        showStatus(null, `项目 "${projectName}" 加载成功 (BPM: ${metadata.bpm_data.bpm})`, 'success');
                    } else {
                        showStatus(null, `项目 "${projectName}" 加载成功 (需要检测 BPM)`, 'success');
                    }
                    
                    // Show project info panel and update project information
                    showProjectInfo(projectName);
                    
                    // Enable controls
                    enableControls();
                    
                } catch (error) {
                    showStatus(null, `加载项目失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Show project info panel and update project information
            async function showProjectInfo(projectName) {
                // Show the project info panel
                elements.projectInfoPanel.style.display = 'block';
                
                // Get the selected option to show display name
                const selectedOption = elements.projectSelector.selectedOptions[0];
                const displayName = selectedOption ? selectedOption.dataset.displayName : projectName;
                
                // Update current project display
                elements.currentProjectDisplay.textContent = displayName;
                
                // Set current display name in input for editing
                elements.projectDisplayNameInput.value = displayName;
                
                // Clear any previous status messages
                elements.displayNameStatus.textContent = '';
                elements.categoryStatus.textContent = '';
                elements.difficultyStatus.textContent = '';
                
                // Load project metadata to populate category and difficulty
                const metadata = await loadProjectMetadata(projectName);
                if (metadata) {
                    // Set category (default to Pop if not set)
                    const category = metadata.category || 'Pop';
                    elements.projectCategorySelect.value = category;
                    
                    // Set difficulty (default to 1 if not set)
                    const difficulty = metadata.difficulty || 1;
                    elements.projectDifficultyInput.value = difficulty;
                }
                
                // Initialize and load image summary
                loadImageSummary(projectName);
            }

            // Load and update image summary for project info panel
            async function loadImageSummary(projectName) {
                try {
                    const response = await fetch(`/api/project/${projectName}/images`);
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        const images = result.images;
                        let totalCount = 0;
                        
                        // Clear thumbnails
                        elements.imageSummaryThumbs.innerHTML = '';
                        
                        // Count images and create thumbnails
                        const imageOrder = [
                            {category: 'character', type: 'unsatisfied'},
                            {category: 'character', type: 'satisfied'},
                            {category: 'banner', type: 'unsatisfied'},
                            {category: 'banner', type: 'satisfied'},
                            {category: 'scene', type: 'background'},
                            {category: 'scene', type: 'props'}
                        ];
                        
                        imageOrder.forEach(({category, type}) => {
                            const thumb = document.createElement('div');
                            thumb.className = 'image-summary-thumb';
                            
                            if (images[category] && images[category][type]) {
                                const filename = images[category][type];
                                const imageUrl = `/api/project/${projectName}/images/${filename}`;
                                thumb.innerHTML = `<img src="${imageUrl}" alt="${category} ${type}">`;
                                totalCount++;
                            }
                            
                            elements.imageSummaryThumbs.appendChild(thumb);
                        });
                        
                        // Update count
                        const countElement = elements.imageSummaryPreview.querySelector('.image-summary-count');
                        countElement.textContent = `${totalCount}/6 已上传`;
                        
                    }
                } catch (error) {
                    console.error('Failed to load image summary:', error);
                }
            }

            // Open image editor modal
            function openImageEditor() {
                if (!currentProject) {
                    showToast('请先加载一个项目', 'warning');
                    return;
                }
                
                elements.imageEditorModal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                
                // Initialize modal functionality
                initializeImageEditorModal(currentProject);
                loadImageEditorData(currentProject);
            }

            // Close image editor modal
            function closeImageEditor() {
                elements.imageEditorModal.style.display = 'none';
                document.body.style.overflow = '';
                
                // Refresh summary when closing
                if (currentProject) {
                    loadImageSummary(currentProject);
                }
            }

            // Initialize image editor modal functionality
            function initializeImageEditorModal(projectName) {
                const imageSlots = elements.imageEditorModal.querySelectorAll('.image-slot');
                
                imageSlots.forEach(slot => {
                    const uploadBtn = slot.querySelector('.upload-btn');
                    const removeBtn = slot.querySelector('.remove-btn');
                    const fileInput = slot.querySelector('.image-input');
                    const preview = slot.querySelector('.image-preview');
                    const category = slot.dataset.category;
                    const type = slot.dataset.type;
                    
                    // Clear existing listeners
                    const newUploadBtn = uploadBtn.cloneNode(true);
                    const newRemoveBtn = removeBtn.cloneNode(true);
                    const newFileInput = fileInput.cloneNode(true);
                    
                    uploadBtn.parentNode.replaceChild(newUploadBtn, uploadBtn);
                    removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);
                    fileInput.parentNode.replaceChild(newFileInput, fileInput);
                    
                    // Upload button click handler
                    newUploadBtn.addEventListener('click', () => {
                        newFileInput.click();
                    });
                    
                    // File input change handler
                    newFileInput.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            await uploadImageInModal(file, category, type, projectName, preview, newRemoveBtn);
                        }
                    });
                    
                    // Remove button click handler
                    newRemoveBtn.addEventListener('click', async () => {
                        await removeImageInModal(category, type, projectName, preview, newRemoveBtn);
                    });
                });
            }

            // Upload image in modal
            async function uploadImageInModal(file, category, type, projectName, previewElement, removeBtn) {
                try {
                    // Show loading state
                    previewElement.innerHTML = '<div style="font-size: 12px; color: var(--text-muted);">上传中...</div>';
                    
                    const formData = new FormData();
                    formData.append('image', file);
                    formData.append('category', category);
                    formData.append('type', type);
                    
                    const response = await fetch(`/api/project/${projectName}/images/upload`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        // Show image preview
                        const imageUrl = `/api/project/${projectName}/images/${result.filename}`;
                        previewElement.innerHTML = `<img src="${imageUrl}" alt="${category} ${type}">`;
                        previewElement.classList.add('has-image');
                        
                        // Show remove button
                        removeBtn.style.display = 'inline-block';
                        
                        showToast('图片上传成功', 'success');
                    } else {
                        throw new Error(result.message || 'Upload failed');
                    }
                } catch (error) {
                    previewElement.innerHTML = '';
                    previewElement.classList.remove('has-image');
                    showToast(`上传失败: ${error.message}`, 'error');
                }
            }

            // Remove image in modal
            async function removeImageInModal(category, type, projectName, previewElement, removeBtn) {
                try {
                    const response = await fetch(`/api/project/${projectName}/images/${category}/${type}`, {
                        method: 'DELETE'
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        // Clear preview
                        previewElement.innerHTML = '';
                        previewElement.classList.remove('has-image');
                        
                        // Hide remove button
                        removeBtn.style.display = 'none';
                        
                        showToast('图片删除成功', 'success');
                    } else {
                        throw new Error(result.message || 'Delete failed');
                    }
                } catch (error) {
                    showToast(`删除失败: ${error.message}`, 'error');
                }
            }

            // Load image data into editor modal
            async function loadImageEditorData(projectName) {
                try {
                    const response = await fetch(`/api/project/${projectName}/images`);
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        const images = result.images;
                        
                        // Clear all previews first
                        elements.imageEditorModal.querySelectorAll('.image-preview').forEach(preview => {
                            preview.innerHTML = '';
                            preview.classList.remove('has-image');
                        });
                        elements.imageEditorModal.querySelectorAll('.remove-btn').forEach(btn => {
                            btn.style.display = 'none';
                        });
                        
                        // Load existing images
                        Object.keys(images).forEach(category => {
                            Object.keys(images[category]).forEach(type => {
                                const filename = images[category][type];
                                const previewElement = elements.imageEditorModal.querySelector(`#preview-${category}-${type}`);
                                const slot = previewElement?.closest('.image-slot');
                                const removeBtn = slot?.querySelector('.remove-btn');
                                
                                if (previewElement) {
                                    const imageUrl = `/api/project/${projectName}/images/${filename}`;
                                    previewElement.innerHTML = `<img src="${imageUrl}" alt="${category} ${type}">`;
                                    previewElement.classList.add('has-image');
                                    
                                    if (removeBtn) {
                                        removeBtn.style.display = 'inline-block';
                                    }
                                }
                            });
                        });
                    }
                } catch (error) {
                    console.error('Failed to load project images:', error);
                }
            }

            // Simple toast notification function
            function showToast(message, type = 'info') {
                // Create toast element
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    background: ${type === 'error' ? 'var(--error-color)' : type === 'success' ? 'var(--success-color)' : 'var(--accent-primary)'};
                    color: var(--text-white);
                    padding: 12px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                    z-index: 9999;
                    opacity: 0;
                    transform: translateX(100%);
                    transition: all 0.3s ease;
                `;
                toast.textContent = message;
                
                document.body.appendChild(toast);
                
                // Show toast
                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(0)';
                }, 100);
                
                // Hide and remove toast
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            // Load annotations
            async function loadAnnotations(projectName) {
                try {
                    const response = await fetch(`/api/annotations/${projectName}`);
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        annotations = data.annotations || [];
                        renderAnnotations();
                        updateAnnotationsList();
                        
                        if (annotations.length > 0) {
                            showStatus(null, `加载了 ${annotations.length} 个已有标注`, 'success');
                            elements.generateScoreBtn.disabled = false;
                            elements.exportMenuBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.warn('加载标注失败:', error);
                }
            }

            // Load score
            async function loadScore(projectName) {
                try {
                    const response = await fetch(`/api/score/${projectName}`);
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        const scoreData = data.score || [];
                        
                        // Check if score data has metadata with offset
                        if (Array.isArray(scoreData)) {
                            score = scoreData;
                        } else if (scoreData.metadata && Array.isArray(scoreData.notes)) {
                            // New format with metadata
                            score = scoreData.notes;
                        } else {
                            score = [];
                        }
                        
                        renderScore();
                        
                        if (score.length > 0) {
                            showStatus(null, `加载了 ${score.length} 个曲谱音符`, 'success');
                            elements.exportMenuBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.warn('加载曲谱失败:', error);
                }
            }

            // Save score
            async function saveScore() {
                if (!currentProject) return;

                showLoading('保存曲谱...');

                try {
                    // Save score with metadata including score offset
                    const scoreData = {
                        metadata: {
                            scoreOffset: scoreOffset,
                            createdAt: Date.now(),
                            version: "2.0"
                        },
                        notes: score
                    };
                    
                    const response = await fetch(`/api/score/${currentProject}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ score: scoreData })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `保存成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `保存失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Detect BPM
            async function detectBPM() {
                if (!currentProject) return;

                const useOriginal = elements.bpmSourceSelect.value === 'original';
                showLoading(`检测 BPM...${useOriginal ? '(使用原曲)' : '(使用鼓轨)'}`);
                
                try {
                    const response = await fetch('/api/detect_bpm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            useOriginal: useOriginal
                        })
                    });

                    const data = await response.json();
                    console.log('BPM detection response:', data); // 调试信息
                    
                    if (data.status === 'success') {
                        bmpData = data.bpm_data;  // 修复：后端返回的是 bpm_data 不是 bmp_data
                        
                        // 验证数据结构
                        if (!bmpData || typeof bmpData.bpm === 'undefined') {
                            throw new Error('无效的BPM数据结构');
                        }
                        
                        elements.bpmValue.textContent = Math.round(bmpData.bpm);
                        elements.manualBpm.value = bmpData.bpm;
                        
                        // Update offset input with detected offset
                        if (bmpData.offset !== undefined) {
                            audioOffset = bmpData.offset;
                            }
                        
                        const sourceText = bmpData.audio_source === 'original_track' ? '原曲' : 
                                         bmpData.audio_source === 'drums_fallback' ? '鼓轨(原曲未找到)' : '鼓轨';
                        const offsetText = bmpData.offset ? `, offset: ${bmpData.offset.toFixed(3)}s` : '';
                        showStatus(null, `BPM 检测成功: ${bmpData.bpm} (${bmpData.method_used}) - 音源: ${sourceText}${offsetText}`, 'success');
                        elements.generateBeatsBtn.disabled = false;
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `BPM 检测失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Generate beat grid
            async function generateBeatGrid() {
                if (!currentProject) return;

                const bpm = elements.manualBpm.value || (bmpData && bmpData.bpm);
                if (!bpm) {
                    showStatus(null, '请先检测 BPM 或输入手动 BPM', 'warning');
                    return;
                }

                showLoading('生成节拍网格...');

                try {
                    const response = await fetch('/api/analyze_beats', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            bpmOverride: parseFloat(bpm)
                        })
                    });

                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        beatGrid = data.beat_grid;
                        renderBeatGrid();
                        renderTimelineRuler();
                        
                        showStatus(null, 
                            `节拍网格生成成功: ${beatGrid.grid_metadata.total_beats} 个节拍, ${beatGrid.grid_metadata.total_measures} 个小节`, 
                            'success'
                        );
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `节拍网格生成失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Render timeline ruler with beat-aligned markers
            function renderTimelineRuler() {
                const ruler = elements.timelineRuler;
                const duration = wavesurfer.getDuration();
                if (!duration) {
                    ruler.innerHTML = '';
                    return;
                }

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                // If we have beat grid data, use it for alignment
                if (beatGrid && beatGrid.downbeats) {
                    // Add markers at downbeats (measure starts)
                    beatGrid.downbeats.forEach((time, index) => {
                        // Apply audio offset to timeline ruler markers
                        const offsetTime = time + audioOffset;
                        if (offsetTime <= duration && offsetTime >= 0) {
                            const position = offsetTime * currentPxPerSec;
                            const marker = document.createElement('div');
                            marker.style.position = 'absolute';
                            marker.style.left = `${position}px`;
                            marker.style.top = '0';
                            marker.style.height = '100%';
                            marker.style.borderLeft = '2px solid var(--border-color)';
                            marker.style.pointerEvents = 'none';
                            
                            // Add measure number label
                            const label = document.createElement('span');
                            label.textContent = `${index + 1} | ${formatTime(time)}`;
                            label.style.position = 'absolute';
                            label.style.left = '4px';
                            label.style.top = '4px';
                            label.style.fontSize = '11px';
                            label.style.color = 'var(--text-primary)';
                            label.style.backgroundColor = 'var(--bg-secondary)';
                            label.style.padding = '2px 4px';
                            label.style.borderRadius = '3px';
                            label.style.fontWeight = '600';
                            marker.appendChild(label);
                            
                            content.appendChild(marker);
                        }
                    });

                    // Add lighter markers at regular beats if zoom is high enough
                    if (currentPxPerSec > 200 && beatGrid.beats) {
                        beatGrid.beats.forEach(time => {
                            if (time <= duration) {
                                const position = time * currentPxPerSec;
                                const marker = document.createElement('div');
                                marker.style.position = 'absolute';
                                marker.style.left = `${position}px`;
                                marker.style.top = '0';
                                marker.style.height = '100%';
                                marker.style.borderLeft = '1px solid var(--border-color)';
                                marker.style.opacity = '0.5';
                                marker.style.pointerEvents = 'none';
                                
                                content.appendChild(marker);
                            }
                        });
                    }
                } else {
                    // Fallback to time-based markers if no beat grid
                    let interval;
                    if (currentPxPerSec < 100) {
                        interval = 10; // 10 seconds
                    } else if (currentPxPerSec < 200) {
                        interval = 5; // 5 seconds
                    } else if (currentPxPerSec < 500) {
                        interval = 2; // 2 seconds
                    } else {
                        interval = 1; // 1 second
                    }

                    for (let time = 0; time <= duration; time += interval) {
                        const position = time * currentPxPerSec;
                        const marker = document.createElement('div');
                        marker.style.position = 'absolute';
                        marker.style.left = `${position}px`;
                        marker.style.top = '0';
                        marker.style.height = '100%';
                        marker.style.borderLeft = '1px solid var(--border-color)';
                        marker.style.pointerEvents = 'none';
                        
                        const label = document.createElement('span');
                        label.textContent = formatTime(time);
                        label.style.position = 'absolute';
                        label.style.left = '4px';
                        label.style.top = '4px';
                        label.style.fontSize = '11px';
                        label.style.color = 'var(--text-muted)';
                        label.style.backgroundColor = 'var(--bg-secondary)';
                        label.style.padding = '1px 3px';
                        label.style.borderRadius = '2px';
                        marker.appendChild(label);
                        
                        content.appendChild(marker);
                    }
                }

                ruler.innerHTML = '';
                ruler.appendChild(content);
            }

            // Format time in MM:SS format
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            // Render beat grid overlay
            function renderBeatGrid() {
                if (!beatGrid) {
                    elements.beatGridOverlay.innerHTML = '';
                    return;
                }

                const duration = wavesurfer.getDuration();
                if (!duration) return;

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                const addLine = (time, className) => {
                    // Apply audio offset to shift all beat lines
                    const offsetTime = time + audioOffset;
                    const position = offsetTime * currentPxPerSec;
                    const line = document.createElement('div');
                    line.className = `beat-line ${className}`;
                    line.style.left = `${position}px`;
                    content.appendChild(line);
                };

                beatGrid.downbeats.forEach(time => addLine(time, 'downbeat'));
                beatGrid.beats.forEach(time => addLine(time, ''));

                if (beatGrid.subdivisions) {
                    const subdivisions = beatGrid.subdivisions.sixteenth_notes || [];
                    subdivisions.forEach(time => {
                        if (time <= duration) {
                            addLine(time, 'subdivision');
                        }
                    });
                }

                elements.beatGridOverlay.innerHTML = '';
                elements.beatGridOverlay.appendChild(content);
            }


            // Render annotations
            function renderAnnotations() {
                wsRegions.clearRegions();

                const duration = wavesurfer.getDuration();
                if (!duration) {
                    elements.annotationTrack.innerHTML = '';
                    return;
                }

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                annotations.forEach((annotation, index) => {
                    const regionId = annotation.id || `ann-${index}`;
                    
                    const region = wsRegions.addRegion({
                        id: regionId,
                        start: annotation.time,
                        end: annotation.time + (annotation.duration || 0.1),
                        color: annotation.type === 'don' ? 'rgba(255, 99, 71, 0.3)' : 'rgba(65, 105, 225, 0.3)',
                        drag: true,
                        resize: true
                    });

                    const marker = document.createElement('div');
                    marker.className = `annotation-marker ${annotation.type}`;
                    marker.dataset.id = regionId;
                    marker.textContent = annotation.type === 'don' ? '咚' : '咔';
                    
                    const position = annotation.time * currentPxPerSec;
                    const width = (annotation.duration || 0.1) * currentPxPerSec;
                    
                    marker.style.left = `${position}px`;
                    marker.style.width = `${width}px`;
                    
                    marker.addEventListener('click', () => selectAnnotation(annotation, marker, region));
                    
                    content.appendChild(marker);
                });
                
                elements.annotationTrack.innerHTML = '';
                elements.annotationTrack.appendChild(content);
            }

            // Render score (曲谱)
            function renderScore() {
                const duration = wavesurfer.getDuration();
                if (!duration) {
                    elements.scoreTrack.innerHTML = '';
                    return;
                }

                console.log(`[Score] 渲染曲谱: ${score.length} 个音符`);

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                score.forEach((scoreItem, index) => {
                    const marker = document.createElement('div');
                    marker.className = `score-marker ${scoreItem.type}`;
                    marker.dataset.id = scoreItem.id || `score-${index}`;
                    marker.textContent = scoreItem.type === 'don' ? '咚' : '咔';
                    
                    // Direct positioning without any offset
                    const position = scoreItem.time * currentPxPerSec;
                    
                    console.log(`[Score] 音符${index}: 时间=${scoreItem.time.toFixed(3)}s, 位置=${position.toFixed(1)}px`);
                    
                    // Center the circle on the time position (subtract half the width)
                    marker.style.left = `${position - 15}px`; // 15px = half of 30px width
                    
                    marker.addEventListener('click', (e) => {
                        if (!isDragging) {
                            selectScore(scoreItem, marker);
                        }
                    });
                    
                    // Add drag event listeners (left click)
                    marker.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // Left mouse button only
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Hide any existing context menu
                            hideScoreContextMenu();
                            
                            // Record initial position for drag detection
                            draggedScoreItem = scoreItem;
                            draggedElement = marker;
                            dragStartX = e.clientX;
                            dragStartY = e.clientY;
                            dragStartTime = scoreItem.time;
                            
                            // Prevent text selection
                            document.body.style.userSelect = 'none';
                            
                            console.log(`[Interaction] 左键按下音符: ${scoreItem.type} at ${scoreItem.time.toFixed(3)}s`);
                        }
                    });

                    // Add right-click context menu
                    marker.addEventListener('contextmenu', (e) => {
                        e.preventDefault(); // Prevent browser context menu
                        e.stopPropagation();
                        
                        // Hide any existing context menu
                        hideScoreContextMenu();
                        
                        // Select this score item
                        selectScore(scoreItem, marker);
                        
                        // Show context menu at mouse position
                        console.log(`[Context] 右键点击音符: ${scoreItem.type} at ${scoreItem.time.toFixed(3)}s`);
                        showScoreContextMenu(scoreItem, marker, e.clientX, e.clientY);
                    });
                    
                    marker.style.cursor = 'grab';
                    
                    content.appendChild(marker);
                });
                
                elements.scoreTrack.innerHTML = '';
                elements.scoreTrack.appendChild(content);
                
                // Apply current scroll transformation to maintain proper positioning
                const scrollLeft = wavesurfer.getScroll();
                if (scrollLeft !== undefined) {
                    content.style.transform = `translateX(-${scrollLeft}px)`;
                }
                
                // Re-create hover indicator if it existed
                if (currentHoverTime > 0) {
                    hoverIndicatorLine = null; // Reset reference
                    createHoverIndicatorLine(currentHoverTime, isMenuOpen);
                }
            }

            // Select score item
            function selectScore(scoreItem, marker) {
                // Clear previous selection
                document.querySelectorAll('.score-marker.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                // Select new score item
                marker.classList.add('selected');
                
                // Seek to score position
                wavesurfer.seekTo(scoreItem.time / wavesurfer.getDuration());
            }

            // Generate initial score from annotations
            function generateScoreFromAnnotations() {
                score = annotations.map(annotation => ({
                    id: `score-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    time: annotation.time,
                    type: annotation.type
                }));
                
                renderScore();
                elements.exportMenuBtn.disabled = false;
                
                toastManager.success(`从标记生成了 ${score.length} 个曲谱音符`);
            }

            // Select annotation
            function selectAnnotation(annotation, marker, region) {
                // Clear previous selection
                document.querySelectorAll('.annotation-marker.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                document.querySelectorAll('.annotation-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                // Select new annotation
                selectedAnnotation = annotation;
                marker.classList.add('selected');
                
                // Highlight in list
                const listItem = document.querySelector(`[data-id="${annotation.id}"]`);
                if (listItem) {
                    listItem.classList.add('selected');
                }

                // Seek to annotation
                wavesurfer.seekTo(annotation.time / wavesurfer.getDuration());
            }

            // Update annotations list
            function updateAnnotationsList() {
                const list = elements.annotationsList;
                
                if (annotations.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">暂无标注</div>';
                    elements.exportMenuBtn.disabled = true;
                    return;
                }

                // Sort annotations by time
                const sortedAnnotations = [...annotations].sort((a, b) => a.time - b.time);
                
                list.innerHTML = '';
                sortedAnnotations.forEach(annotation => {
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    item.dataset.id = annotation.id;
                    
                    item.innerHTML = `
                        <div class="annotation-info">
                            <div class="annotation-type ${annotation.type}">${annotation.type === 'don' ? '咚' : '咔'}</div>
                            <div class="annotation-time">${annotation.time.toFixed(3)}s (${(annotation.duration || 0.1).toFixed(3)}s)</div>
                        </div>
                        <button class="btn btn-error btn-small" onclick="deleteAnnotation('${annotation.id}')">删除</button>
                    `;
                    
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            const marker = document.querySelector(`.annotation-marker[data-id="${annotation.id}"]`);
                            const region = wsRegions.getRegions().find(r => r.id === annotation.id);
                            if (marker && region) {
                                selectAnnotation(annotation, marker, region);
                            }
                        }
                    });
                    
                    list.appendChild(item);
                });

                elements.exportMenuBtn.disabled = false;
            }

            // Delete annotation
            window.deleteAnnotation = function(annotationId) {
                annotations = annotations.filter(ann => ann.id !== annotationId);
                
                // Remove region
                const region = wsRegions.getRegions().find(r => r.id === annotationId);
                if (region) {
                    region.remove();
                }
                
                // Remove marker
                const marker = document.querySelector(`.annotation-marker[data-id="${annotationId}"]`);
                if (marker) {
                    marker.remove();
                }
                
                updateAnnotationsList();
                
                if (selectedAnnotation && selectedAnnotation.id === annotationId) {
                    selectedAnnotation = null;
                }
            };

            // Add annotation at current time
            function addAnnotation(type) {
                if (!wavesurfer.getDuration()) return;

                const currentTime = wavesurfer.getCurrentTime();
                const newAnnotation = {
                    id: `ann-${Date.now()}`,
                    time: currentTime,
                    duration: 0.1,
                    type: type
                };

                annotations.push(newAnnotation);
                renderAnnotations();
                renderScore();
                updateAnnotationsList();
            }

            // Save annotations
            async function saveAnnotations() {
                if (!currentProject) return;

                showLoading('保存标注...');

                try {
                    const response = await fetch(`/api/annotations/${currentProject}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ annotations: annotations })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `保存成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `保存失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Export audio samples
            async function exportAudioSamples() {
                if (!currentProject) return;

                showLoading('导出音频样本...');

                try {
                    const response = await fetch('/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            annotations: annotations
                        })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `导出成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `导出失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Enable controls after project loads
            function enableControls() {
                elements.playBtn.disabled = false;
                elements.stopBtn.disabled = false;
                elements.loopBtn.disabled = false;
                elements.zoomInBtn.disabled = false;
                elements.zoomOutBtn.disabled = false;
                elements.detectBpmBtn.disabled = false;
                
                // Enable generate score button if we have annotations
                if (annotations.length > 0) {
                    elements.generateScoreBtn.disabled = false;
                    elements.exportMenuBtn.disabled = false;
                }
                
                // Enable export menu if we have score data
                if (score.length > 0) {
                    elements.exportMenuBtn.disabled = false;
                }
                
            }

            // Initialize snap precision dropdown
            function initSnapPrecision() {
                // Add event listener for dropdown changes
                elements.snapPrecisionSelect.addEventListener('change', () => {
                    quantizeMode = elements.snapPrecisionSelect.value;
                    
                    console.log(`[Snap] 吸附精度设置为: ${quantizeMode}`);
                    toastManager.info(`吸附精度: ${elements.snapPrecisionSelect.options[elements.snapPrecisionSelect.selectedIndex].text}`);
                });
            }

            // Event listeners
            elements.loadProjectBtn.addEventListener('click', () => {
                const project = elements.projectSelector.value;
                if (project) {
                    loadProject(project);
                }
            });

            // Clear project info panel when project selector changes
            elements.projectSelector.addEventListener('change', () => {
                const selectedProject = elements.projectSelector.value;
                if (!selectedProject) {
                    // Hide project info panel when no project selected
                    elements.projectInfoPanel.style.display = 'none';
                    elements.currentProjectDisplay.textContent = '未加载项目';
                    elements.projectDisplayNameInput.value = '';
                    elements.displayNameStatus.textContent = '';
                }
            });

            // Update display name functionality
            elements.updateDisplayNameBtn.addEventListener('click', async () => {
                const selectedProject = elements.projectSelector.value;
                const newDisplayName = elements.projectDisplayNameInput.value.trim();

                if (!selectedProject) {
                    elements.displayNameStatus.textContent = '请先选择一个项目';
                    elements.displayNameStatus.style.color = 'var(--error-color)';
                    return;
                }

                if (!newDisplayName) {
                    elements.displayNameStatus.textContent = '显示名称不能为空';
                    elements.displayNameStatus.style.color = 'var(--error-color)';
                    return;
                }

                try {
                    elements.displayNameStatus.textContent = '正在更新...';
                    elements.displayNameStatus.style.color = 'var(--text-muted)';
                    elements.updateDisplayNameBtn.disabled = true;

                    const response = await fetch(`/api/project/${selectedProject}/display_name`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            display_name: newDisplayName
                        })
                    });

                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        elements.displayNameStatus.textContent = '显示名称已更新';
                        elements.displayNameStatus.style.color = 'var(--success-color)';
                        
                        // Update the option text in the selector
                        const selectedOption = elements.projectSelector.selectedOptions[0];
                        if (selectedOption) {
                            selectedOption.textContent = newDisplayName;
                            selectedOption.dataset.displayName = newDisplayName;
                        }
                        
                        // Clear status after 3 seconds
                        setTimeout(() => {
                            elements.displayNameStatus.textContent = '';
                        }, 3000);
                    } else {
                        throw new Error(result.message || 'Failed to update display name');
                    }
                } catch (error) {
                    elements.displayNameStatus.textContent = `更新失败: ${error.message}`;
                    elements.displayNameStatus.style.color = 'var(--error-color)';
                } finally {
                    elements.updateDisplayNameBtn.disabled = false;
                }
            });

            // Allow Enter key to update display name
            elements.projectDisplayNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    elements.updateDisplayNameBtn.click();
                }
            });

            // Update category functionality
            elements.updateCategoryBtn.addEventListener('click', async () => {
                const selectedProject = elements.projectSelector.value;
                const newCategory = elements.projectCategorySelect.value;

                if (!selectedProject) {
                    elements.categoryStatus.textContent = '请先选择一个项目';
                    elements.categoryStatus.style.color = 'var(--error-color)';
                    return;
                }

                try {
                    elements.categoryStatus.textContent = '正在更新...';
                    elements.categoryStatus.style.color = 'var(--text-muted)';
                    elements.updateCategoryBtn.disabled = true;

                    const response = await fetch(`/api/project/${selectedProject}/metadata`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            category: newCategory
                        })
                    });

                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        elements.categoryStatus.textContent = '类别已更新';
                        elements.categoryStatus.style.color = 'var(--success-color)';
                        
                        // Clear status after 3 seconds
                        setTimeout(() => {
                            elements.categoryStatus.textContent = '';
                        }, 3000);
                    } else {
                        throw new Error(result.message || 'Failed to update category');
                    }
                } catch (error) {
                    elements.categoryStatus.textContent = `更新失败: ${error.message}`;
                    elements.categoryStatus.style.color = 'var(--error-color)';
                } finally {
                    elements.updateCategoryBtn.disabled = false;
                }
            });

            // Update difficulty functionality
            elements.updateDifficultyBtn.addEventListener('click', async () => {
                const selectedProject = elements.projectSelector.value;
                const newDifficulty = parseInt(elements.projectDifficultyInput.value);

                if (!selectedProject) {
                    elements.difficultyStatus.textContent = '请先选择一个项目';
                    elements.difficultyStatus.style.color = 'var(--error-color)';
                    return;
                }

                if (!newDifficulty || newDifficulty < 1 || newDifficulty > 9) {
                    elements.difficultyStatus.textContent = '难度必须是1-9之间的整数';
                    elements.difficultyStatus.style.color = 'var(--error-color)';
                    return;
                }

                try {
                    elements.difficultyStatus.textContent = '正在更新...';
                    elements.difficultyStatus.style.color = 'var(--text-muted)';
                    elements.updateDifficultyBtn.disabled = true;

                    const response = await fetch(`/api/project/${selectedProject}/metadata`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            difficulty: newDifficulty
                        })
                    });

                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        elements.difficultyStatus.textContent = '难度已更新';
                        elements.difficultyStatus.style.color = 'var(--success-color)';
                        
                        // Clear status after 3 seconds
                        setTimeout(() => {
                            elements.difficultyStatus.textContent = '';
                        }, 3000);
                    } else {
                        throw new Error(result.message || 'Failed to update difficulty');
                    }
                } catch (error) {
                    elements.difficultyStatus.textContent = `更新失败: ${error.message}`;
                    elements.difficultyStatus.style.color = 'var(--error-color)';
                } finally {
                    elements.updateDifficultyBtn.disabled = false;
                }
            });

            // Allow Enter key to update difficulty
            elements.projectDifficultyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    elements.updateDifficultyBtn.click();
                }
            });

            // Image editor modal event listeners
            elements.editImagesBtn.addEventListener('click', openImageEditor);
            elements.imageEditorClose.addEventListener('click', closeImageEditor);
            elements.imageEditorCancel.addEventListener('click', closeImageEditor);
            elements.imageEditorSave.addEventListener('click', closeImageEditor);
            elements.imageEditorOverlay.addEventListener('click', closeImageEditor);

            // Prevent modal from closing when clicking inside the container
            elements.imageEditorModal.querySelector('.image-editor-container').addEventListener('click', (e) => {
                e.stopPropagation();
            });

            elements.detectBpmBtn.addEventListener('click', detectBPM);
            elements.generateBeatsBtn.addEventListener('click', generateBeatGrid);
            elements.generateScoreBtn.addEventListener('click', generateScoreFromAnnotations);
            
            // Export popup menu functionality
            function toggleExportMenu() {
                const isVisible = elements.exportPopupMenu.style.display !== 'none';
                elements.exportPopupMenu.style.display = isVisible ? 'none' : 'block';
            }
            
            function hideExportMenu() {
                elements.exportPopupMenu.style.display = 'none';
            }
            
            // Export menu button
            elements.exportMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleExportMenu();
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                hideExportMenu();
                
                // Hide context menu if clicking outside of it
                if (currentContextMenu && !currentContextMenu.contains(e.target)) {
                    console.log('[Context] 点击外部区域，隐藏上下文菜单');
                    hideScoreContextMenu();
                }
            });
            
            // Export menu item handlers
            elements.saveAnnotationsMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                saveAnnotations();
            });
            
            elements.exportAudioSamplesMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                exportAudioSamples();
            });
            
            elements.saveScoreMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                saveScore();
            });
            
            elements.saveAllMenuBtn.addEventListener('click', async () => {
                hideExportMenu();
                showLoading('保存全部...');
                try {
                    await saveAnnotations();
                    await saveScore(); 
                    await exportAudioSamples();
                    toastManager.success('全部保存完成！');
                } catch (error) {
                    toastManager.error(`保存失败: ${error.message}`);
                } finally {
                    hideLoading();
                }
            });

            // Audio source select functionality
            elements.audioSourceSelect.addEventListener('change', () => {
                const selectedSource = elements.audioSourceSelect.value;
                switchAudioSource(selectedSource);
            });

            // Transport controls
            elements.playBtn.addEventListener('click', () => {
                // Apply offset when starting playback
                if (!wavesurfer.isPlaying()) {
                    const currentTime = wavesurfer.getCurrentTime();
                    // If starting from beginning, apply offset
                    if (currentTime === 0 && audioOffset !== 0) {
                        const offsetTime = Math.max(0, audioOffset);
                        wavesurfer.seekTo(offsetTime / wavesurfer.getDuration());
                        console.log(`[Offset] 播放时应用offset: ${audioOffset.toFixed(3)}s`);
                    }
                }
                wavesurfer.playPause();
            });
            elements.stopBtn.addEventListener('click', () => wavesurfer.stop());
            elements.loopBtn.addEventListener('click', () => {
                isLooping = !isLooping;
                elements.loopBtn.style.background = isLooping ? 'var(--accent-primary)' : 'var(--bg-tertiary)';
            });

            // Zoom controls - WaveSurfer v7 API
            let minPxPerSec = 50;   // 最小像素每秒
            let maxPxPerSec = 2000; // 最大像素每秒
            let currentPxPerSec = 100; // 当前像素每秒
            
            elements.zoomInBtn.addEventListener('click', () => {
                currentPxPerSec = Math.min(currentPxPerSec * 1.5, maxPxPerSec);
                wavesurfer.zoom(currentPxPerSec);
                // Re-render all overlays with new zoom level and offset
                renderBeatGrid();
                renderTimelineRuler();
                renderScore();
            });
            
            elements.zoomOutBtn.addEventListener('click', () => {
                currentPxPerSec = Math.max(currentPxPerSec / 1.5, minPxPerSec);
                wavesurfer.zoom(currentPxPerSec);
                // Re-render all overlays with new zoom level and offset
                renderBeatGrid();
                renderTimelineRuler();
                renderScore();
            });

            // Tool selection
            elements.toolSelect.addEventListener('click', () => {
                currentTool = 'select';
                updateToolSelection();
            });
            elements.toolDon.addEventListener('click', () => {
                currentTool = 'don';
                updateToolSelection();
            });
            elements.toolKa.addEventListener('click', () => {
                currentTool = 'ka';
                updateToolSelection();
            });

            function updateToolSelection() {
                document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                    btn.style.background = 'var(--bg-tertiary)';
                });
                
                const selectedTool = document.getElementById(`tool-${currentTool}`);
                if (selectedTool) {
                    selectedTool.style.background = 'var(--accent-primary)';
                }
            }



            // Generate snap grid based on quantization mode
            function generateSnapGrid() {
                if (!beatGrid || !beatGrid.beats) {
                    return [];
                }
                
                const beats = beatGrid.beats;
                const beatInterval = beatGrid.beat_interval;
                let snapPoints = [];
                
                console.log(`[Snap] 生成${quantizeMode}精度网格`);
                
                switch (quantizeMode) {
                    case '1/4':
                        // Quarter notes - use main beats
                        snapPoints = beats;
                        break;
                        
                    case '1/8':
                        // Eighth notes - beats + off-beats
                        beats.forEach(beatTime => {
                            snapPoints.push(beatTime);
                            snapPoints.push(beatTime + beatInterval / 2);
                        });
                        break;
                        
                    case '1/16':
                        // Sixteenth notes - 4 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 4; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 4));
                            }
                        });
                        break;
                        
                    case '1/8T':
                        // Eighth triplets - 3 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 3; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 3));
                            }
                        });
                        break;
                        
                    case '1/16T':
                        // Sixteenth note triplets - 6 divisions per beat (2 triplet groups)
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 6; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 6));
                            }
                        });
                        break;
                        
                    case '1/32':
                        // Thirty-second notes - 8 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 8; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 8));
                            }
                        });
                        break;
                        
                    default:
                        snapPoints = beats;
                }
                
                // Sort and remove duplicates
                snapPoints = [...new Set(snapPoints)].sort((a, b) => a - b);
                
                console.log(`[Snap] 生成了${snapPoints.length}个吸附点`);
                return snapPoints;
            }

            // Find nearest snap point for dragging
            function findNearestSnapPoint(timePosition) {
                if (!beatGrid || !beatGrid.beats) {
                    return timePosition; // No snapping if no beat grid
                }
                
                const snapPoints = generateSnapGrid();
                if (snapPoints.length === 0) {
                    return timePosition;
                }
                
                let nearestPoint = snapPoints[0];
                let minDistance = Math.abs(timePosition - nearestPoint);
                
                for (const snapPoint of snapPoints) {
                    const distance = Math.abs(timePosition - snapPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPoint = snapPoint;
                    }
                }
                
                return nearestPoint;
            }

            // Convert pixel position to time
            function pixelToTime(pixelX, trackElement) {
                const rect = trackElement.getBoundingClientRect();
                const relativeX = pixelX - rect.left;
                const scrollLeft = wavesurfer.getScroll();
                const adjustedX = relativeX + scrollLeft;
                return adjustedX / currentPxPerSec;
            }

            // Convert time to pixel position 
            function timeToPixel(time) {
                return time * currentPxPerSec;
            }

            // Create drop target indicator
            function createDropTargetIndicator(time, type) {
                if (dropTargetIndicator) {
                    dropTargetIndicator.remove();
                }
                
                const indicator = document.createElement('div');
                indicator.className = 'drop-target-indicator';
                indicator.textContent = type === 'don' ? '咚' : '咔';
                
                const position = timeToPixel(time);
                indicator.style.left = `${position - 17}px`; // Center the indicator
                
                // Add color based on type
                if (type === 'don') {
                    indicator.style.borderColor = 'rgba(255, 99, 71, 0.8)';
                    indicator.style.background = 'rgba(255, 99, 71, 0.3)';
                } else {
                    indicator.style.borderColor = 'rgba(65, 105, 225, 0.8)';
                    indicator.style.background = 'rgba(65, 105, 225, 0.3)';
                }
                
                dropTargetIndicator = indicator;
                return indicator;
            }

            // Remove drop target indicator
            function removeDropTargetIndicator() {
                if (dropTargetIndicator) {
                    dropTargetIndicator.remove();
                    dropTargetIndicator = null;
                }
            }

            // Create and show context menu (for existing score items or track insertion)
            function showScoreContextMenu(scoreItem, marker, x, y, insertMode = false) {
                hideScoreContextMenu(); // Hide any existing menu
                
                const menu = document.createElement('div');
                menu.className = 'score-context-menu';
                
                // Position the menu relative to the viewport (fixed positioning)
                let menuX = x - 10; // Slightly to the left of cursor
                let menuY = y - 10; // Slightly above the cursor
                
                // Prevent menu from going off-screen
                if (menuX + 150 > window.innerWidth) {
                    menuX = x - 160; // Show to the left if no space on right
                }
                if (menuX < 10) {
                    menuX = 10; // Don't go off left edge
                }
                if (menuY < 10) {
                    menuY = y + 10; // Show below if no space above
                }
                if (menuY + 120 > window.innerHeight) {
                    menuY = y - 130; // Show above if no space below
                }
                
                menu.style.position = 'fixed';
                menu.style.left = `${menuX}px`;
                menu.style.top = `${menuY}px`;
                menu.style.zIndex = '2000';
                
                // Menu items - different for insert mode vs edit mode
                let items;
                if (insertMode) {
                    // Insert mode - add new notes
                    items = [
                        {
                            icon: '🔴',
                            text: '添加咚',
                            action: 'insert-don'
                        },
                        {
                            icon: '🔵',
                            text: '添加咔', 
                            action: 'insert-ka'
                        }
                    ];
                } else {
                    // Edit mode - modify existing notes
                    items = [
                        {
                            icon: '🗑️',
                            text: '删除',
                            action: 'delete',
                            class: 'danger'
                        },
                        { divider: true },
                        {
                            icon: '🔴',
                            text: '改为咚',
                            action: 'change-don',
                            disabled: scoreItem && scoreItem.type === 'don'
                        },
                        {
                            icon: '🔵', 
                            text: '改为咔',
                            action: 'change-ka',
                            disabled: scoreItem && scoreItem.type === 'ka'
                        }
                    ];
                }
                
                items.forEach(item => {
                    if (item.divider) {
                        const divider = document.createElement('div');
                        divider.className = 'context-menu-divider';
                        menu.appendChild(divider);
                    } else {
                        const menuItem = document.createElement('div');
                        menuItem.className = `context-menu-item ${item.class || ''}`;
                        if (item.disabled) {
                            menuItem.style.opacity = '0.5';
                            menuItem.style.cursor = 'not-allowed';
                        }
                        
                        menuItem.innerHTML = `
                            <span class="menu-icon">${item.icon}</span>
                            <span>${item.text}</span>
                        `;
                        
                        if (!item.disabled) {
                            menuItem.addEventListener('click', () => {
                                if (insertMode) {
                                    handleContextMenuAction(item.action, null, null, currentHoverTime);
                                } else {
                                    handleContextMenuAction(item.action, scoreItem, marker);
                                }
                                hideScoreContextMenu();
                            });
                        }
                        
                        menu.appendChild(menuItem);
                    }
                });
                
                document.body.appendChild(menu);
                currentContextMenu = menu;
                contextMenuScoreItem = scoreItem;
                isMenuOpen = true;
                
                // If in insert mode, mark the current hover time as selected
                if (insertMode && hoverIndicatorLine) {
                    hoverIndicatorLine.classList.add('selected');
                    selectedTime = currentHoverTime;
                }
                
                if (insertMode) {
                    console.log(`[Context] 显示插入菜单 at ${currentHoverTime.toFixed(3)}s (位置: ${menuX}, ${menuY})`);
                } else {
                    console.log(`[Context] 显示编辑菜单: ${scoreItem ? scoreItem.type : 'unknown'} at ${scoreItem ? scoreItem.time.toFixed(3) : 0}s (位置: ${menuX}, ${menuY})`);
                }
                console.log(`[Context] 菜单DOM:`, menu);
                console.log(`[Context] 菜单样式:`, menu.style.cssText);
                console.log(`[Context] 菜单子元素数量:`, menu.children.length);
                
                // Force a repaint
                menu.offsetHeight;
                
                // No need for menuJustCreated flag with right-click
                
                console.log(`[Context] 菜单显示在鼠标位置: (${menuX}, ${menuY})`);
            }

            // Hide context menu
            function hideScoreContextMenu() {
                if (currentContextMenu) {
                    console.log('[Context] 隐藏上下文菜单');
                    currentContextMenu.remove();
                    currentContextMenu = null;
                    contextMenuScoreItem = null;
                    isMenuOpen = false;
                    
                    // Remove selected state from hover line
                    if (hoverIndicatorLine) {
                        hoverIndicatorLine.classList.remove('selected');
                    }
                } else {
                    console.log('[Context] 尝试隐藏菜单，但没有活动菜单');
                }
            }

            // Handle context menu actions
            function handleContextMenuAction(action, scoreItem, marker, insertTime = null) {
                switch (action) {
                    case 'delete':
                        deleteScoreItem(scoreItem);
                        toastManager.success(`删除了音符: ${scoreItem.type}`);
                        break;
                        
                    case 'change-don':
                        scoreItem.type = 'don';
                        renderScore();
                        syncTimelineScroll();
                        toastManager.info(`音符改为: 咚`);
                        console.log(`[Context] 音符类型改为: don`);
                        break;
                        
                    case 'change-ka':
                        scoreItem.type = 'ka';
                        renderScore();
                        syncTimelineScroll();
                        toastManager.info(`音符改为: 咔`);
                        console.log(`[Context] 音符类型改为: ka`);
                        break;
                        
                    case 'insert-don':
                        addScoreItem(selectedTime, 'don');
                        break;
                        
                    case 'insert-ka':
                        addScoreItem(selectedTime, 'ka');
                        break;
                }
            }

            // Delete score item
            function deleteScoreItem(scoreItem) {
                const index = score.findIndex(item => item === scoreItem);
                if (index !== -1) {
                    score.splice(index, 1);
                    renderScore();
                    syncTimelineScroll();
                    console.log(`[Context] 删除音符: ${scoreItem.type} at ${scoreItem.time.toFixed(3)}s`);
                }
            }

            // Create hover indicator line
            function createHoverIndicatorLine(time, selected = false) {
                if (!hoverIndicatorLine) {
                    hoverIndicatorLine = document.createElement('div');
                    hoverIndicatorLine.className = 'hover-indicator-line';
                    
                    // Add to the score track content, not the track itself
                    const scoreContent = elements.scoreTrack.firstChild;
                    if (scoreContent) {
                        scoreContent.appendChild(hoverIndicatorLine);
                    } else {
                        elements.scoreTrack.appendChild(hoverIndicatorLine);
                    }
                }
                
                // Update position and style
                const position = timeToPixel(time);
                const lineWidth = selected ? 3 : 2;
                hoverIndicatorLine.style.left = `${position - Math.floor(lineWidth/2)}px`;
                
                // Toggle selected class
                if (selected) {
                    hoverIndicatorLine.classList.add('selected');
                    selectedTime = time;
                } else {
                    hoverIndicatorLine.classList.remove('selected');
                }
                
                currentHoverTime = time;
                
                // console.log(`[Hover] 创建高亮线 at ${time.toFixed(3)}s, 位置: ${position}px, zoom: ${currentPxPerSec}, selected: ${selected}`);
            }

            // Remove hover indicator line
            function removeHoverIndicatorLine() {
                if (hoverIndicatorLine) {
                    hoverIndicatorLine.remove();
                    hoverIndicatorLine = null;
                    currentHoverTime = 0;
                }
            }

            // Add new score item at specified time
            function addScoreItem(time, type) {
                const newScoreItem = {
                    id: `score-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    time: time,
                    type: type
                };
                
                score.push(newScoreItem);
                renderScore();
                syncTimelineScroll();
                
                console.log(`[Insert] 添加音符: ${type} at ${time.toFixed(3)}s`);
                toastManager.success(`添加了 ${type === 'don' ? '咚' : '咔'} 音符`);
            }

            // Simple Snap to Grid functionality
            function snapToGrid() {
                if (!beatGrid || !beatGrid.beats || score.length === 0) {
                    toastManager.warning('需要先生成节拍网格和曲谱');
                    return;
                }

                showLoading(`吸附音符到${quantizeMode}网格...`);

                try {
                    // Generate snap grid based on selected quantization
                    const snapPoints = generateSnapGrid();
                    
                    if (snapPoints.length === 0) {
                        throw new Error('无法生成吸附网格');
                    }
                    
                    let snappedCount = 0;
                    let totalAdjustment = 0;

                    score.forEach((scoreItem, index) => {
                        const originalTime = scoreItem.time;
                        
                        // Find closest snap point
                        let closestSnapPoint = snapPoints[0];
                        let minDistance = Math.abs(originalTime - closestSnapPoint);

                        for (const snapPoint of snapPoints) {
                            const distance = Math.abs(originalTime - snapPoint);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestSnapPoint = snapPoint;
                            }
                        }

                        // Snap to closest point
                        const adjustment = Math.abs(originalTime - closestSnapPoint);
                        scoreItem.time = closestSnapPoint;
                        
                        snappedCount++;
                        totalAdjustment += adjustment;

                        console.log(`[Snap] 音符${index}: ${originalTime.toFixed(3)}s -> ${closestSnapPoint.toFixed(3)}s (调整: ${(adjustment*1000).toFixed(0)}ms)`);
                    });

                    // Re-render score
                    renderScore();

                    const avgAdjustment = totalAdjustment / snappedCount;
                    toastManager.success(`${quantizeMode}网格吸附完成！${snappedCount}个音符，平均调整${(avgAdjustment*1000).toFixed(0)}ms`);
                    console.log(`[Snap] 完成：${snappedCount}个音符吸附到${quantizeMode}网格，平均调整${(avgAdjustment*1000).toFixed(0)}ms`);

                } catch (error) {
                    console.error('[Snap] Error:', error);
                    toastManager.error(`吸附失败: ${error.message}`);
                } finally {
                    hideLoading();
                }
            }


            // Timeline click to add annotations
            elements.annotationTrack.addEventListener('click', (e) => {
                if (currentTool !== 'select' && wavesurfer.getDuration()) {
                    const rect = elements.annotationTrack.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const timePosition = (x / rect.width) * wavesurfer.getDuration();
                    
                    wavesurfer.seekTo(timePosition / wavesurfer.getDuration());
                    addAnnotation(currentTool);
                }
            });

            // Score track mouse events for hover and right-click insertion
            elements.scoreTrack.addEventListener('mousemove', (e) => {
                if (!wavesurfer.getDuration() || isMenuOpen) return; // Don't update when menu is open
                
                // Calculate mouse position in time
                const rect = elements.scoreTrack.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const scrollLeft = wavesurfer.getScroll() || 0;
                const timePosition = Math.max(0, (x + scrollLeft) / currentPxPerSec);
                
                // Ensure we don't exceed duration
                const maxTime = wavesurfer.getDuration();
                const clampedTime = Math.min(timePosition, maxTime);
                
                // Snap to grid
                const snappedTime = findNearestSnapPoint(clampedTime);
                
                // Show hover indicator
                createHoverIndicatorLine(snappedTime);
                
                // Debug log (uncomment for debugging)
                // console.log(`[Hover] 鼠标位置: ${timePosition.toFixed(3)}s, 吸附到: ${snappedTime.toFixed(3)}s, zoom: ${currentPxPerSec}, scroll: ${scrollLeft}`);
            });

            elements.scoreTrack.addEventListener('mouseleave', () => {
                if (!isMenuOpen) { // Don't remove when menu is open
                    removeHoverIndicatorLine();
                }
            });

            elements.scoreTrack.addEventListener('contextmenu', (e) => {
                if (!wavesurfer.getDuration()) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // Only show insert menu if we're not clicking on an existing note
                const target = e.target;
                if (target.classList.contains('score-marker')) {
                    return; // Let the note's own context menu handle this
                }
                
                console.log(`[Insert] 右键点击轨道，准备插入音符 at ${currentHoverTime.toFixed(3)}s`);
                showScoreContextMenu(null, null, e.clientX, e.clientY, true); // insertMode = true
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        wavesurfer.playPause();
                        break;
                    case 'd':
                        e.preventDefault();
                        addAnnotation('don');
                        break;
                    case 'k':
                        e.preventDefault();
                        addAnnotation('ka');
                        break;
                    case 'backspace':
                    case 'delete':
                        e.preventDefault();
                        if (selectedAnnotation) {
                            deleteAnnotation(selectedAnnotation.id);
                        }
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            saveAnnotations();
                        }
                        break;
                }
            });

            // Sidebar toggle for mobile
            elements.sidebarToggle.addEventListener('click', () => {
                elements.sidebar.classList.toggle('open');
            });

            // Track labels toggle
            elements.toggleTrackLabelsBtn.addEventListener('click', () => {
                elements.trackLabels.classList.toggle('collapsed');
                // Use a short timeout to allow the CSS transition to finish before redrawing WaveSurfer
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 300); // This should match the CSS transition duration
            });

            // Sync timeline elements scroll position
            function syncTimelineScroll() {
                const scrollLeft = wavesurfer.getScroll();

                const rulerContent = elements.timelineRuler.firstChild;
                if (rulerContent) {
                    rulerContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const gridContent = elements.beatGridOverlay.firstChild;
                if (gridContent) {
                    gridContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const annotationContent = elements.annotationTrack.firstChild;
                if (annotationContent) {
                    annotationContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const scoreContent = elements.scoreTrack.firstChild;
                if (scoreContent) {
                    scoreContent.style.transform = `translateX(-${scrollLeft}px)`;
                }
            }

            // WaveSurfer events
            wavesurfer.on('ready', () => {
                hideLoading();
                
                // 只有在非音频源切换时才进行自动缩放
                if (!isSwitchingAudio) {
                    const duration = wavesurfer.getDuration();
                    const containerWidth = wavesurfer.getWrapper().clientWidth;
                    if (duration > 0) {
                        const targetViewDuration = Math.min(duration, 15);
                        currentPxPerSec = Math.max(containerWidth / targetViewDuration, minPxPerSec);
                        wavesurfer.zoom(currentPxPerSec);
                    }
                }
                
                // Initial render and sync
                renderBeatGrid();
                renderTimelineRuler();
                renderAnnotations();
                renderScore();
                syncTimelineScroll();
            });

            wavesurfer.on('zoom', () => {
                // In WaveSurfer v7, minPxPerSec option is updated to the current zoom level.
                currentPxPerSec = wavesurfer.options.minPxPerSec;
                renderBeatGrid();
                renderTimelineRuler();
                renderAnnotations();
                renderScore();
                syncTimelineScroll();
                
                // Update hover indicator position if it exists
                if (hoverIndicatorLine && currentHoverTime > 0) {
                    const position = timeToPixel(currentHoverTime);
                    hoverIndicatorLine.style.left = `${position - 1}px`;
                    // console.log(`[Hover] Zoom更新高亮线位置: ${position}px`);
                }
            });

            wavesurfer.on('scroll', () => {
                syncTimelineScroll();
            });

            wavesurfer.on('finish', () => {
                if (isLooping) {
                    wavesurfer.seekTo(0);
                    wavesurfer.play();
                }
            });

            // Region events
            wsRegions.on('region-updated', (region) => {
                const annotation = annotations.find(ann => ann.id === region.id);
                if (annotation) {
                    annotation.time = region.start;
                    annotation.duration = region.end - region.start;
                    updateAnnotationsList();
                    // Re-render markers to reflect the change, then sync scroll
                    renderAnnotations();
                renderScore(); 
                    syncTimelineScroll();
                }
            });

            // Timeline ruler vertical drag zoom
            let isDragZooming = false;
            let timelineRulerDragStartY = 0;
            let dragStartZoom = 0;

            elements.timelineRuler.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    isDragZooming = true;
                    timelineRulerDragStartY = e.clientY;
                    dragStartZoom = currentPxPerSec;
                    
                    // Prevent text selection during drag
                    e.preventDefault();
                    document.body.style.userSelect = 'none';
                    elements.timelineRuler.style.cursor = 'ns-resize';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragZooming) {
                    const deltaY = timelineRulerDragStartY - e.clientY; // Negative for up, positive for down
                    const sensitivity = 0.01; // Adjust zoom sensitivity
                    const zoomFactor = 1 + (deltaY * sensitivity);
                    
                    const newZoom = Math.max(
                        Math.min(dragStartZoom * zoomFactor, maxPxPerSec),
                        minPxPerSec
                    );
                    
                    if (Math.abs(newZoom - currentPxPerSec) > 1) {
                        currentPxPerSec = newZoom;
                        wavesurfer.zoom(currentPxPerSec);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragZooming) {
                    isDragZooming = false;
                    document.body.style.userSelect = '';
                    elements.timelineRuler.style.cursor = '';
                }
            });

            // Mouse wheel zoom (like in professional DAWs)
            document.getElementById('timeline-container').addEventListener('wheel', (e) => {
                if (e.ctrlKey || e.metaKey) { // Ctrl/Cmd + wheel for zoom
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;
                    currentPxPerSec = Math.max(
                        Math.min(currentPxPerSec * zoomFactor, maxPxPerSec),
                        minPxPerSec
                    );
                    wavesurfer.zoom(currentPxPerSec);
                }
            });

            // Global mouse move handler for dragging
            document.addEventListener('mousemove', (e) => {
                if (draggedScoreItem && draggedElement) {
                    // Calculate movement distance
                    const deltaX = Math.abs(e.clientX - dragStartX);
                    const deltaY = Math.abs(e.clientY - dragStartY);
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Check if we should start dragging (lower threshold for immediate drag)
                    if (!isDragging && distance >= dragThreshold) {
                        isDragging = true;
                        draggedElement.classList.add('dragging');
                        draggedElement.style.cursor = 'grabbing';
                        console.log(`[Drag] 开始拖拽音符: ${draggedScoreItem.type}`);
                    }
                    
                    if (isDragging) {
                        e.preventDefault();
                        
                        // Calculate new time position based on mouse movement
                        const timeX = e.clientX - dragStartX;
                        const deltaTime = timeX / currentPxPerSec;
                        const newTime = Math.max(0, dragStartTime + deltaTime);
                        
                        // Find nearest snap point
                        const snappedTime = findNearestSnapPoint(newTime);
                        
                        // Update dragged element position 
                        const newPosition = timeToPixel(snappedTime);
                        draggedElement.style.left = `${newPosition - 15}px`;
                        
                        // Show drop target indicator
                        const indicator = createDropTargetIndicator(snappedTime, draggedScoreItem.type);
                        elements.scoreTrack.appendChild(indicator);
                        
                        console.log(`[Drag] 移动到: ${snappedTime.toFixed(3)}s (吸附: ${(newTime - snappedTime).toFixed(3)}s)`);
                    }
                }
            });

            // Global mouse up handler for dropping
            document.addEventListener('mouseup', (e) => {
                if (draggedScoreItem && draggedElement) {
                    e.preventDefault();
                    
                    if (isDragging) {
                        // Handle drag completion
                        const deltaX = e.clientX - dragStartX;
                        const deltaTime = deltaX / currentPxPerSec;
                        const newTime = Math.max(0, dragStartTime + deltaTime);
                        const finalTime = findNearestSnapPoint(newTime);
                        
                        // Update the score data model
                        draggedScoreItem.time = finalTime;
                        
                        // Clean up drag state
                        draggedElement.classList.remove('dragging');
                        draggedElement.style.cursor = 'grab';
                        removeDropTargetIndicator();
                        
                        // Re-render score to ensure correct positioning
                        renderScore();
                        syncTimelineScroll();
                        
                        console.log(`[Drag] 音符移动完成: ${draggedScoreItem.type} -> ${finalTime.toFixed(3)}s`);
                        toastManager.info(`音符移动到 ${finalTime.toFixed(3)}s`);
                        
                    } else {
                        // Handle simple click - just select the score item
                        console.log(`[Click] 左键点击选中音符: ${draggedScoreItem.type} at ${draggedScoreItem.time.toFixed(3)}s`);
                        selectScore(draggedScoreItem, draggedElement);
                    }
                    
                    // Clean up common state
                    document.body.style.userSelect = '';
                    
                    // Reset drag state
                    isDragging = false;
                    draggedScoreItem = null;
                    draggedElement = null;
                    dragStartX = 0;
                    dragStartY = 0;
                    dragStartTime = 0;
                }
            });

            // Window resize handler
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    renderBeatGrid();
                    renderTimelineRuler();
                    renderAnnotations();
                renderScore();
                    syncTimelineScroll();
                }, 100);
            });

            // Initialize
            initSnapPrecision();
            loadProjects();
            updateToolSelection();
            updateAudioSourceDisplay();
        });
    </script>

    <!-- Image Editor Modal -->
    <div class="image-editor-modal" id="image-editor-modal" style="display: none;">
        <div class="image-editor-overlay" id="image-editor-overlay"></div>
        <div class="image-editor-container">
            <div class="image-editor-header">
                <h2 class="image-editor-title">游戏图片资源编辑</h2>
                <button class="image-editor-close" id="image-editor-close">×</button>
            </div>
            <div class="image-editor-content">
                <!-- Character 角色 -->
                <div class="image-category">
                    <h3 class="image-category-title">角色</h3>
                    <div class="image-slots">
                        <div class="image-slot" data-category="character" data-type="unsatisfied">
                            <div class="image-slot-info">
                                <label class="image-slot-label">灵不满</label>
                                <div class="image-slot-description">角色在灵力不足时的显示图片</div>
                            </div>
                            <div class="image-preview" id="preview-character-unsatisfied"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="character" data-type="unsatisfied">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                        <div class="image-slot" data-category="character" data-type="satisfied">
                            <div class="image-slot-info">
                                <label class="image-slot-label">灵满</label>
                                <div class="image-slot-description">角色在灵力充满时的显示图片</div>
                            </div>
                            <div class="image-preview" id="preview-character-satisfied"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="character" data-type="satisfied">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Banner 顶部横幅 -->
                <div class="image-category">
                    <h3 class="image-category-title">顶部横幅</h3>
                    <div class="image-slots">
                        <div class="image-slot" data-category="banner" data-type="unsatisfied">
                            <div class="image-slot-info">
                                <label class="image-slot-label">灵不满</label>
                                <div class="image-slot-description">游戏顶部横幅在灵力不足时的显示</div>
                            </div>
                            <div class="image-preview" id="preview-banner-unsatisfied"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="banner" data-type="unsatisfied">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                        <div class="image-slot" data-category="banner" data-type="satisfied">
                            <div class="image-slot-info">
                                <label class="image-slot-label">灵满</label>
                                <div class="image-slot-description">游戏顶部横幅在灵力充满时的显示</div>
                            </div>
                            <div class="image-preview" id="preview-banner-satisfied"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="banner" data-type="satisfied">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Scene 场景 -->
                <div class="image-category">
                    <h3 class="image-category-title">场景</h3>
                    <div class="image-slots">
                        <div class="image-slot" data-category="scene" data-type="background">
                            <div class="image-slot-info">
                                <label class="image-slot-label">背景图</label>
                                <div class="image-slot-description">游戏主背景图片</div>
                            </div>
                            <div class="image-preview" id="preview-scene-background"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="scene" data-type="background">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                        <div class="image-slot" data-category="scene" data-type="props">
                            <div class="image-slot-info">
                                <label class="image-slot-label">动态现场小道具</label>
                                <div class="image-slot-description">游戏中的动态装饰元素</div>
                            </div>
                            <div class="image-preview" id="preview-scene-props"></div>
                            <input type="file" class="image-input" accept="image/png,image/jpg,image/jpeg,image/gif" data-category="scene" data-type="props">
                            <div class="image-actions">
                                <button type="button" class="btn btn-primary upload-btn">选择文件</button>
                                <button type="button" class="btn btn-secondary remove-btn" style="display: none;">删除</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="image-editor-footer">
                <button type="button" class="btn btn-secondary" id="image-editor-cancel">取消</button>
                <button type="button" class="btn btn-primary" id="image-editor-save">保存并关闭</button>
            </div>
        </div>
    </div>

</body>
</html>