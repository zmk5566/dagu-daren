<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大鼓达人 - DAW 专业标注工具</title>
    <style>
        /* Modern DAW-style CSS */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --accent-primary: #0078d4;
            --accent-secondary: #106ebe;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #999999;
            --border-color: #444444;
            --success-color: #107c10;
            --warning-color: #ff8c00;
            --error-color: #d13438;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Header */
        .daw-header {
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .daw-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .daw-version {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: 10px;
        }

        /* Main Layout */
        .daw-layout {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* Sidebar */
        .daw-sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            height: 100%;
            scroll-behavior: smooth;
        }

        /* Custom scrollbar for sidebar */
        .daw-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .daw-sidebar::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .daw-sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .daw-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .daw-panel {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .daw-panel-header {
            background: var(--bg-tertiary);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .daw-panel-content {
            padding: 16px;
            overflow-y: auto;
        }

        .daw-panel.collapsed .daw-panel-content {
            display: none;
        }

        /* Individual panel max heights to prevent any one panel from taking all space */
        #project-panel .daw-panel-content {
            max-height: 150px;
        }

        #bpm-panel .daw-panel-content {
            max-height: 250px;
        }

        #align-panel .daw-panel-content {
            max-height: 350px;
        }

        #annotations-panel .daw-panel-content {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Make panels more compact when needed */
        .daw-panel-content .form-group {
            margin-bottom: 12px;
        }

        .daw-panel-content .btn {
            margin-bottom: 8px;
        }

        /* Ensure content is always accessible */
        .daw-panel-content {
            min-height: 0; /* Allow flexbox to shrink */
        }

        /* Add visual hint when content is scrollable */
        .daw-panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .daw-panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .daw-panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .daw-panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .panel-toggle {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Main Content */
        .daw-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .daw-toolbar {
            height: 50px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
        }

        /* Transport Controls */
        .transport-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 20px;
            padding-right: 20px;
            border-right: 1px solid var(--border-color);
        }

        .transport-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .transport-btn:hover {
            background: var(--accent-primary);
        }

        .transport-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .transport-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        /* Snap Precision Dropdown */
        .snap-precision-container {
            display: flex;
            align-items: center;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border-color);
        }

        .snap-precision-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 4px 8px;
            min-width: 140px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .snap-precision-select:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-secondary);
        }

        .snap-precision-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
        }

        /* BPM Display */
        .bpm-display {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 8px;
            border-right: 1px solid var(--border-color);
            white-space: nowrap;
            min-width: 60px;
        }

        .bpm-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .bpm-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            min-width: 24px;
            text-align: left;
        }

        /* Timeline Container */
        .timeline-container {
            flex: 1;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        /* Timeline Header */
        .timeline-header {
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .timeline-ruler {
            height: 100%;
            position: relative;
            background: linear-gradient(to right, var(--border-color) 0px, transparent 1px);
            background-size: 50px 100%;
            cursor: ns-resize;
        }

        .timeline-ruler:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        /* Waveform Area */
        .waveform-area {
            height: 150px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
            z-index: 2;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        /* Beat Grid Overlay */
        .beat-grid-overlay {
            position: absolute;
            top: 40px; /* Below timeline-header */
            left: 0;
            width: 100%;
            height: calc(100% - 40px); /* Fill remaining space */
            pointer-events: none;
            z-index: 1; /* Behind tracks */
            overflow: hidden;
        }

        .beat-line {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
        }

        .beat-line.downbeat {
            background: rgba(0, 0, 0, 0.4);
            width: 2px;
        }

        .beat-line.subdivision {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Annotation Track */
        .annotation-track {
            height: 60px;
            background: transparent; /* Make it transparent to see grid lines behind */
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2; /* Put it above the grid */
        }

        /* Score Track */
        .score-track {
            height: 60px;
            background: transparent;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2;
        }

        .annotation-marker {
            position: absolute;
            top: 5px;
            height: 50px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }

        .annotation-marker.don {
            background: #ff6347;
        }

        .annotation-marker.ka {
            background: #4169e1;
        }

        .annotation-marker:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .annotation-marker.selected {
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 10px var(--accent-primary);
        }

        /* Score Markers */
        .score-marker {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.2s;
            transform: translateY(-50%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        .score-marker.don {
            background: rgba(255, 99, 71, 0.7);
            box-shadow: 0 2px 8px rgba(255, 99, 71, 0.4);
        }

        .score-marker.ka {
            background: rgba(65, 105, 225, 0.7);
            box-shadow: 0 2px 8px rgba(65, 105, 225, 0.4);
        }

        .score-marker:hover {
            transform: translateY(-50%) scale(1.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }

        .score-marker.selected {
            border: 3px solid var(--warning-color);
            box-shadow: 0 0 15px var(--warning-color);
            transform: translateY(-50%) scale(1.1);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 14px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-error {
            background: var(--error-color);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .btn-block {
            width: 100%;
            justify-content: center;
        }

        /* Status Display */
        .status-message {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 8px;
        }

        .status-success {
            background: rgba(16, 124, 16, 0.2);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-warning {
            background: rgba(255, 140, 0, 0.2);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }

        .status-error {
            background: rgba(209, 52, 56, 0.2);
            color: var(--error-color);
            border: 1px solid var(--error-color);
        }

        /* Annotations List */
        .annotations-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
        }

        .annotation-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .annotation-item:hover {
            background: var(--bg-tertiary);
        }

        .annotation-item.selected {
            background: var(--accent-primary);
        }

        .annotation-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .annotation-type {
            font-weight: 600;
            text-transform: uppercase;
        }

        .annotation-type.don {
            color: #ff6347;
        }

        .annotation-type.ka {
            color: #4169e1;
        }

        .annotation-time {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 30, 30, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            z-index: 1000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-size: 14px;
        }


        /* Range Slider */
        .range-slider {
            width: 100%;
            margin: 10px 0;
        }

        .range-input {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        .range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
        }

        .range-input::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .daw-sidebar {
                width: 250px;
            }
        }

        @media (max-width: 768px) {
            .daw-sidebar {
                position: absolute;
                left: -300px;
                top: 0;
                height: 100%;
                z-index: 1000;
                transition: left 0.3s;
            }

            .daw-sidebar.open {
                left: 0;
            }

            .daw-header {
                padding: 0 10px;
            }

            .daw-toolbar {
                padding: 0 10px;
                flex-wrap: wrap;
                height: auto;
                min-height: 50px;
            }
        }

        /* Tracks Wrapper */
        .tracks-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Track Labels Panel */
        .daw-track-labels {
            width: 120px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            transition: width 0.3s ease;
            overflow: hidden;
        }

        .daw-track-labels.collapsed {
            width: 30px; /* Keep enough space for the toggle button */
        }

        .daw-track-labels.collapsed .track-labels-content {
            display: none;
        }

        .track-label-header {
            height: 40px; /* Match timeline-header */
            display: flex;
            align-items: center;
            justify-content: center; /* Center the button */
            border-bottom: 1px solid var(--border-color);
        }

        .track-label-toggle {
            width: 24px;
            height: 24px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: transform 0.3s ease;
        }
        
        .daw-track-labels.collapsed .track-label-toggle {
            transform: rotate(-180deg);
        }

        .track-label-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
            overflow: hidden;
            white-space: nowrap;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: flex-start;
            gap: 10px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            position: relative;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.hide {
            opacity: 0;
            transform: translateX(100%);
        }

        .toast-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 1px;
        }

        .toast.success .toast-icon {
            background: var(--success-color);
            color: white;
        }

        .toast.error .toast-icon {
            background: var(--error-color);
            color: white;
        }

        .toast.warning .toast-icon {
            background: var(--warning-color);
            color: white;
        }

        .toast.info .toast-icon {
            background: var(--accent-primary);
            color: white;
        }

        .toast-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .toast-close {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .toast-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--accent-primary);
            border-radius: 0 0 8px 8px;
            transition: width 0.1s linear;
        }

        .toast.success .toast-progress {
            background: var(--success-color);
        }

        .toast.error .toast-progress {
            background: var(--error-color);
        }

        .toast.warning .toast-progress {
            background: var(--warning-color);
        }

        /* Export Popup Menu */
        .export-popup-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 160px;
            margin-top: 4px;
        }

        .popup-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid var(--border-color);
        }

        .popup-menu-item:last-child {
            border-bottom: none;
        }

        .popup-menu-item:hover {
            background: var(--bg-tertiary);
        }

        .popup-menu-item:active {
            background: var(--accent-primary);
        }

        .menu-icon {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        .menu-text {
            font-size: 13px;
            font-weight: 500;
        }

        /* Audio Source Selector */
        .audio-source-container {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 12px;
            border-right: 1px solid var(--border-color);
            white-space: nowrap;
        }

        .audio-source-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .audio-source-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 4px 6px;
            min-width: 80px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .audio-source-select:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-secondary);
        }

        .audio-source-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="daw-header">
        <div>
            <span class="daw-title">大鼓达人</span>
            <span class="daw-version">DAW 专业标注工具 v1.0</span>
        </div>
        <div>
            <button class="btn btn-primary btn-small" onclick="window.open('/game', '_blank')" title="开始游戏">
                🎮 演奏模式
            </button>
            <button class="btn btn-secondary btn-small" id="sidebar-toggle">
                <span>☰</span>
            </button>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="daw-layout">
        <!-- Sidebar -->
        <div class="daw-sidebar" id="sidebar">
            <!-- Project Panel -->
            <div class="daw-panel" id="project-panel">
                <div class="daw-panel-header" onclick="togglePanel('project-panel')">
                    <span>项目</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="form-group">
                        <label class="form-label">选择项目</label>
                        <select class="form-select" id="project-selector">
                            <option value="">-- 请选择项目 --</option>
                        </select>
                    </div>
                    <button class="btn btn-primary btn-block" id="load-project-btn">
                        加载项目
                    </button>
                </div>
            </div>

            <!-- BPM Analysis Panel -->
            <div class="daw-panel" id="bpm-panel">
                <div class="daw-panel-header" onclick="togglePanel('bpm-panel')">
                    <span>BPM 分析</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="form-group">
                        <label class="form-label">BPM 检测音源</label>
                        <select class="form-select" id="bpm-source-select">
                            <option value="drums">鼓轨 (drums.mp3)</option>
                            <option value="original">原曲 (更准确)</option>
                        </select>
                    </div>
                    <button class="btn btn-secondary btn-block" id="detect-bpm-btn" disabled>
                        检测 BPM
                    </button>
                    <div class="form-group">
                        <label class="form-label">手动 BPM</label>
                        <input type="number" class="form-input" id="manual-bpm" placeholder="120.0" step="0.1" min="60" max="200">
                    </div>
                    <button class="btn btn-secondary btn-block" id="generate-beats-btn" disabled>
                        生成节拍网格
                    </button>
                    <button class="btn btn-primary btn-block" id="generate-score-btn" disabled style="margin-top: 8px;">
                        生成曲谱
                    </button>
                </div>
            </div>


            <!-- Annotations Panel -->
            <div class="daw-panel" id="annotations-panel">
                <div class="daw-panel-header" onclick="togglePanel('annotations-panel')">
                    <span>标注列表</span>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="daw-panel-content">
                    <div class="annotations-list" id="annotations-list">
                        <div style="text-align: center; color: var(--text-muted); padding: 20px;">
                            暂无标注
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="daw-main">
            <!-- Toolbar -->
            <div class="daw-toolbar">
                <!-- BPM Display -->
                <div class="bpm-display">
                    <span class="bpm-label">BPM:</span>
                    <span class="bpm-value" id="bpm-value">--</span>
                </div>

                <!-- Audio Source Selector -->
                <div class="audio-source-container">
                    <label class="audio-source-label">音源:</label>
                    <select class="audio-source-select" id="audio-source-select" title="选择音频源">
                        <option value="drums">🥁 单鼓</option>
                        <option value="backing">🎵 无鼓</option>
                        <option value="original">🎶 原曲</option>
                    </select>
                </div>

                <!-- Transport Controls -->
                <div class="transport-controls">
                    <button class="transport-btn" id="play-btn" disabled title="播放/暂停 (空格键)">
                        <span>▶</span>
                    </button>
                    <button class="transport-btn" id="stop-btn" disabled title="停止">
                        <span>⏹</span>
                    </button>
                    <button class="transport-btn" id="loop-btn" disabled title="循环播放">
                        <span>🔁</span>
                    </button>
                </div>

                <!-- Zoom Controls -->
                <div class="transport-controls">
                    <button class="transport-btn" id="zoom-out-btn" disabled title="缩小 (Ctrl+滚轮)">
                        <span>-</span>
                    </button>
                    <button class="transport-btn" id="zoom-in-btn" disabled title="放大 (Ctrl+滚轮)">
                        <span>+</span>
                    </button>
                </div>

                <!-- Tool Selection -->
                <div class="transport-controls">
                    <button class="transport-btn" id="tool-select" title="选择工具">
                        <span>🔍</span>
                    </button>
                    <button class="transport-btn" id="tool-don" title="Don 工具 (D键)">
                        <span>咚</span>
                    </button>
                    <button class="transport-btn" id="tool-ka" title="Ka 工具 (K键)">
                        <span>咔</span>
                    </button>
                    
                    <!-- Snap Precision Dropdown -->
                    <div class="snap-precision-container">
                        <label for="snap-precision-select" style="font-size: 11px; color: var(--text-secondary); margin-right: 4px;">吸附:</label>
                        <select class="snap-precision-select" id="snap-precision-select" title="选择吸附精度">
                            <option value="1/4">1/4 - 四分音符</option>
                            <option value="1/8">1/8 - 八分音符</option>
                            <option value="1/16" selected>1/16 - 十六分音符</option>
                            <option value="1/8T">1/8T - 八分三连音</option>
                            <option value="1/16T">1/16T - 十六分三连音</option>
                            <option value="1/32">1/32 - 三十二分音符</option>
                        </select>
                        
                        <!-- Export Button with Popup Menu -->
                        <div class="export-menu-container" style="position: relative; margin-left: 8px;">
                            <button class="transport-btn" id="export-menu-btn" disabled title="导出选项" style="padding: 6px 12px; font-size: 12px;">
                                导出
                            </button>
                            <div class="export-popup-menu" id="export-popup-menu" style="display: none;">
                                <div class="popup-menu-item" id="save-annotations-menu">
                                    <span class="menu-icon">💾</span>
                                    <span class="menu-text">保存标注</span>
                                </div>
                                <div class="popup-menu-item" id="export-audio-samples-menu">
                                    <span class="menu-icon">🎵</span>
                                    <span class="menu-text">导出音频样本</span>
                                </div>
                                <div class="popup-menu-item" id="save-score-menu">
                                    <span class="menu-icon">🎼</span>
                                    <span class="menu-text">保存曲谱</span>
                                </div>
                                <div class="popup-menu-item" id="save-all-menu">
                                    <span class="menu-icon">📋</span>
                                    <span class="menu-text">全部保存</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tracks Wrapper -->
            <div class="tracks-wrapper">
                <!-- Track Labels Panel -->
                <div class="daw-track-labels" id="track-labels">
                    <div class="track-label-header">
                        <button class="track-label-toggle" id="toggle-track-labels" title="收起/展开轨道列表">‹</button>
                    </div>
                    <div class="track-labels-content">
                        <div class="track-label-item" style="height: 151px;"> <!-- 150px height + 1px border -->
                            <span>音频轨道</span>
                        </div>
                        <div class="track-label-item" style="height: 61px;"> <!-- 60px height + 1px border -->
                            <span>标记 Track</span>
                        </div>
                        <div class="track-label-item" style="height: 61px;"> <!-- 60px height + 1px border -->
                            <span>曲谱 Track</span>
                        </div>
                    </div>
                </div>

                <!-- Timeline Container -->
                <div class="timeline-container" id="timeline-container">
                    <div class="beat-grid-overlay" id="beat-grid-overlay"></div>
                    <!-- Timeline Header with Ruler -->
                    <div class="timeline-header">
                        <div class="timeline-ruler" id="timeline-ruler"></div>
                    </div>

                    <!-- Waveform Area -->
                    <div class="waveform-area">
                        <div id="waveform"></div>
                    </div>

                    <!-- Annotation Track -->
                    <div class="annotation-track" id="annotation-track">
                        <!-- Annotation markers will be placed here -->
                    </div>

                    <!-- Score Track -->
                    <div class="score-track" id="score-track">
                        <!-- Score markers will be placed here -->
                    </div>

                    <!-- Loading Overlay -->
                    <div class="loading-overlay" id="loading-overlay" style="display: none;">
                        <div class="loading-spinner"></div>
                        <div class="loading-text" id="loading-text">加载中...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- Include WaveSurfer.js -->
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>

    <script>
        // Toast Notification System
        class ToastManager {
            constructor() {
                this.container = document.getElementById('toast-container');
                this.toasts = new Map();
                this.nextId = 1;
            }

            show(message, type = 'info', title = null, duration = 5000) {
                const id = this.nextId++;
                const toast = this.createToast(id, message, type, title, duration);
                
                this.container.appendChild(toast);
                this.toasts.set(id, { element: toast, timer: null });

                // Trigger animation
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });

                // Auto-dismiss if duration is set
                if (duration > 0) {
                    this.startAutoClose(id, duration);
                }

                return id;
            }

            createToast(id, message, type, title, duration) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.dataset.id = id;

                const iconMap = {
                    success: '✓',
                    error: '✕',
                    warning: '⚠',
                    info: 'ℹ'
                };

                toast.innerHTML = `
                    <div class="toast-icon">${iconMap[type] || 'ℹ'}</div>
                    <div class="toast-content">
                        ${title ? `<div class="toast-title">${title}</div>` : ''}
                        <div class="toast-message">${message}</div>
                    </div>
                    <button class="toast-close" onclick="toastManager.close(${id})">&times;</button>
                    ${duration > 0 ? '<div class="toast-progress"></div>' : ''}
                `;

                return toast;
            }

            startAutoClose(id, duration) {
                const toastData = this.toasts.get(id);
                if (!toastData) return;

                const progressBar = toastData.element.querySelector('.toast-progress');
                let elapsed = 0;
                const interval = 50;

                const timer = setInterval(() => {
                    elapsed += interval;
                    const progress = (elapsed / duration) * 100;
                    
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(progress, 100)}%`;
                    }

                    if (elapsed >= duration) {
                        clearInterval(timer);
                        this.close(id);
                    }
                }, interval);

                toastData.timer = timer;
            }

            close(id) {
                const toastData = this.toasts.get(id);
                if (!toastData) return;

                if (toastData.timer) {
                    clearInterval(toastData.timer);
                }

                toastData.element.classList.remove('show');
                toastData.element.classList.add('hide');

                setTimeout(() => {
                    if (toastData.element.parentNode) {
                        toastData.element.parentNode.removeChild(toastData.element);
                    }
                    this.toasts.delete(id);
                }, 300);
            }

            success(message, title = null, duration = 5000) {
                return this.show(message, 'success', title, duration);
            }

            error(message, title = null, duration = 8000) {
                return this.show(message, 'error', title, duration);
            }

            warning(message, title = null, duration = 6000) {
                return this.show(message, 'warning', title, duration);
            }

            info(message, title = null, duration = 5000) {
                return this.show(message, 'info', title, duration);
            }

            loading(message, title = '处理中...') {
                return this.show(message, 'info', title, 0); // No auto-close for loading
            }
        }

        // Initialize toast manager
        const toastManager = new ToastManager();

        // DAW Interface JavaScript
        document.addEventListener('DOMContentLoaded', () => {
            // Global state
            let currentProject = '';
            let annotations = [];
            let score = [];
            let beatGrid = null;
            let bpmData = null;
            let selectedAnnotation = null;
            let currentTool = 'select';
            let isLooping = false;
            let quantizeMode = '1/16';  // Default snap precision
            let audioOffset = 0.0;  // Keep for backward compatibility (unused)
            let scoreOffset = 0.0;  // Keep for backward compatibility (unused)
            let currentAudioSource = 'drums';  // Current audio source: drums, backing, original
            let isSwitchingAudio = false;  // Flag to prevent auto-zoom during audio switching

            // DOM elements
            const elements = {
                projectSelector: document.getElementById('project-selector'),
                loadProjectBtn: document.getElementById('load-project-btn'),
                bpmSourceSelect: document.getElementById('bpm-source-select'),
                detectBpmBtn: document.getElementById('detect-bpm-btn'),
                manualBpm: document.getElementById('manual-bpm'),
                generateBeatsBtn: document.getElementById('generate-beats-btn'),
                generateScoreBtn: document.getElementById('generate-score-btn'),
                annotationsList: document.getElementById('annotations-list'),
                playBtn: document.getElementById('play-btn'),
                stopBtn: document.getElementById('stop-btn'),
                loopBtn: document.getElementById('loop-btn'),
                zoomInBtn: document.getElementById('zoom-in-btn'),
                zoomOutBtn: document.getElementById('zoom-out-btn'),
                toolSelect: document.getElementById('tool-select'),
                toolDon: document.getElementById('tool-don'),
                toolKa: document.getElementById('tool-ka'),
                bpmValue: document.getElementById('bpm-value'),
                beatGridOverlay: document.getElementById('beat-grid-overlay'),
                annotationTrack: document.getElementById('annotation-track'),
                scoreTrack: document.getElementById('score-track'),
                timelineRuler: document.getElementById('timeline-ruler'),
                loadingOverlay: document.getElementById('loading-overlay'),
                loadingText: document.getElementById('loading-text'),
                sidebarToggle: document.getElementById('sidebar-toggle'),
                sidebar: document.getElementById('sidebar'),
                trackLabels: document.getElementById('track-labels'),
                toggleTrackLabelsBtn: document.getElementById('toggle-track-labels'),
                snapPrecisionSelect: document.getElementById('snap-precision-select'),
                exportMenuBtn: document.getElementById('export-menu-btn'),
                exportPopupMenu: document.getElementById('export-popup-menu'),
                saveAnnotationsMenuBtn: document.getElementById('save-annotations-menu'),
                exportAudioSamplesMenuBtn: document.getElementById('export-audio-samples-menu'),
                saveScoreMenuBtn: document.getElementById('save-score-menu'),
                saveAllMenuBtn: document.getElementById('save-all-menu'),
                audioSourceSelect: document.getElementById('audio-source-select')
            };


            // Initialize WaveSurfer
            const wavesurfer = WaveSurfer.create({
                container: document.getElementById('waveform'),
                waveColor: '#4a4a4a',
                progressColor: '#0078d4',
                cursorWidth: 2,
                cursorColor: '#ffffff',
                barWidth: 2,
                barGap: 1,
                responsive: true,
                height: 150,
                backend: 'WebAudio'
            });

            // Initialize regions plugin
            const wsRegions = wavesurfer.registerPlugin(WaveSurfer.Regions.create());

            // Utility functions
            let currentLoadingToast = null;

            function showLoading(text) {
                // Close previous loading toast if exists
                if (currentLoadingToast !== null) {
                    toastManager.close(currentLoadingToast);
                }
                currentLoadingToast = toastManager.loading(text);
            }

            function hideLoading() {
                if (currentLoadingToast !== null) {
                    toastManager.close(currentLoadingToast);
                    currentLoadingToast = null;
                }
            }

            function showStatus(element, message, type = 'info') {
                // Use toast instead of inline status
                switch (type) {
                    case 'success':
                        toastManager.success(message);
                        break;
                    case 'error':
                        toastManager.error(message);
                        break;
                    case 'warning':
                        toastManager.warning(message);
                        break;
                    default:
                        toastManager.info(message);
                }
            }

            // Make togglePanel globally accessible
            window.togglePanel = function(panelId) {
                const panel = document.getElementById(panelId);
                const toggle = panel.querySelector('.panel-toggle');
                panel.classList.toggle('collapsed');
                toggle.textContent = panel.classList.contains('collapsed') ? '▶' : '▼';
            };

            // Load projects
            async function loadProjects() {
                try {
                    const response = await fetch('/api/projects');
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        elements.projectSelector.innerHTML = '<option value="">-- 请选择项目 --</option>';
                        data.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project;
                            option.textContent = project;
                            elements.projectSelector.appendChild(option);
                        });
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `加载项目列表失败: ${error.message}`, 'error');
                }
            }

            // Load project metadata
            async function loadProjectMetadata(projectName) {
                try {
                    const response = await fetch(`/api/metadata/${projectName}`);
                    
                    if (response.status === 404) {
                        // Metadata doesn't exist, need to auto-detect BPM
                        console.log('Metadata not found, auto-detecting BPM...');
                        await detectBPM(); // This will create metadata.json
                        
                        // Try loading metadata again
                        const retryResponse = await fetch(`/api/metadata/${projectName}`);
                        if (retryResponse.ok) {
                            const retryData = await retryResponse.json();
                            return retryData.metadata;
                        }
                        return null;
                    }
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.metadata;
                    }
                    
                    return null;
                } catch (error) {
                    console.warn('Failed to load metadata:', error);
                    return null;
                }
            }

            // Get audio path based on current source and project
            function getAudioPath(projectName, source = currentAudioSource) {
                const basePath = `data/${projectName}`;
                switch (source) {
                    case 'drums':
                        return `${basePath}/generated_audio/drums.mp3`;
                    case 'backing':
                        return `${basePath}/generated_audio/backing_track_no_drums.mp3`;
                    case 'original':
                        return `${basePath}/${projectName}.mp3`;
                    default:
                        return `${basePath}/generated_audio/drums.mp3`;
                }
            }

            // Switch audio source
            async function switchAudioSource(source) {
                if (!currentProject) {
                    toastManager.warning('请先加载项目');
                    return;
                }

                if (source === currentAudioSource) {
                    return; // Already using this source
                }

                showLoading(`切换到${getSourceDisplayName(source)}...`);
                isSwitchingAudio = true;  // 标记正在切换音频

                try {
                    // 1. 停止当前音频
                    wavesurfer.stop();

                    const audioPath = getAudioPath(currentProject, source);
                    const response = await fetch(audioPath);
                    
                    if (!response.ok) {
                        throw new Error(`音频文件不存在: ${audioPath}`);
                    }

                    const audioBlob = await response.blob();
                    await wavesurfer.load(URL.createObjectURL(audioBlob));

                    // 2. 保持当前缩放比例或使用较小的默认缩放
                    if (currentPxPerSec === 100) {
                        // 如果还是默认值，设置一个较小的缩放比例（显示更多内容）
                        currentPxPerSec = Math.max(minPxPerSec, 80);
                    }
                    // 否则保持用户设置的缩放比例
                    
                    wavesurfer.zoom(currentPxPerSec);
                    
                    // Re-render all overlays with current zoom level
                    renderBeatGrid();
                    renderTimelineRuler();
                    renderAnnotations();
                    renderScore();
                    syncTimelineScroll();

                    // 3. 再次触发停止，确保光标移动到最前方
                    wavesurfer.stop();

                    currentAudioSource = source;
                    updateAudioSourceDisplay();
                    toastManager.success(`已切换到${getSourceDisplayName(source)}`);

                } catch (error) {
                    toastManager.error(`切换音频源失败: ${error.message}`);
                    console.error('Failed to switch audio source:', error);
                } finally {
                    isSwitchingAudio = false;  // 重置标记
                    hideLoading();
                }
            }

            // Get display name for audio source
            function getSourceDisplayName(source) {
                switch (source) {
                    case 'drums': return '单鼓';
                    case 'backing': return '无鼓';
                    case 'original': return '原曲';
                    default: return '单鼓';
                }
            }

            // Update audio source display
            function updateAudioSourceDisplay() {
                elements.audioSourceSelect.value = currentAudioSource;
            }

            // Load project
            async function loadProject(projectName) {
                currentProject = projectName;
                showLoading('加载项目音频...');

                try {
                    const audioPath = getAudioPath(projectName, currentAudioSource);
                    const response = await fetch(audioPath);
                    
                    if (!response.ok) {
                        throw new Error(`音频文件不存在: ${audioPath}`);
                    }

                    const audioBlob = await response.blob();
                    await wavesurfer.load(URL.createObjectURL(audioBlob));
                    
                    // Load existing annotations and score
                    await loadAnnotations(projectName);
                    await loadScore(projectName);
                    
                    // Load project metadata (BPM, etc.)
                    const metadata = await loadProjectMetadata(projectName);
                    if (metadata && metadata.bpm_data) {
                        // Use metadata to populate BPM info
                        bmpData = metadata.bpm_data; // Use existing variable name for consistency
                        elements.bpmValue.textContent = Math.round(metadata.bpm_data.bpm);
                        elements.manualBpm.value = metadata.bpm_data.bpm;
                        elements.generateBeatsBtn.disabled = false;
                        
                        // Apply audio offset for downbeat alignment
                        audioOffset = metadata.bpm_data.offset || 0.0;
                        if (audioOffset !== 0) {
                            console.log(`[Offset] Applied audio offset: ${audioOffset.toFixed(3)}s for downbeat alignment`);
                            // The offset will be applied in all time-related calculations
                        }
                        
                        // Auto-generate beat grid using the BPM from metadata
                        await generateBeatGrid();
                        
                        showStatus(null, `项目 "${projectName}" 加载成功 (BPM: ${metadata.bpm_data.bpm})`, 'success');
                    } else {
                        showStatus(null, `项目 "${projectName}" 加载成功 (需要检测 BPM)`, 'success');
                    }
                    
                    
                    // Enable controls
                    enableControls();
                    
                } catch (error) {
                    showStatus(null, `加载项目失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Load annotations
            async function loadAnnotations(projectName) {
                try {
                    const response = await fetch(`/api/annotations/${projectName}`);
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        annotations = data.annotations || [];
                        renderAnnotations();
                        updateAnnotationsList();
                        
                        if (annotations.length > 0) {
                            showStatus(null, `加载了 ${annotations.length} 个已有标注`, 'success');
                            elements.generateScoreBtn.disabled = false;
                            elements.exportMenuBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.warn('加载标注失败:', error);
                }
            }

            // Load score
            async function loadScore(projectName) {
                try {
                    const response = await fetch(`/api/score/${projectName}`);
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        const scoreData = data.score || [];
                        
                        // Check if score data has metadata with offset
                        if (Array.isArray(scoreData)) {
                            score = scoreData;
                        } else if (scoreData.metadata && Array.isArray(scoreData.notes)) {
                            // New format with metadata
                            score = scoreData.notes;
                        } else {
                            score = [];
                        }
                        
                        renderScore();
                        
                        if (score.length > 0) {
                            showStatus(null, `加载了 ${score.length} 个曲谱音符`, 'success');
                            elements.exportMenuBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.warn('加载曲谱失败:', error);
                }
            }

            // Save score
            async function saveScore() {
                if (!currentProject) return;

                showLoading('保存曲谱...');

                try {
                    // Save score with metadata including score offset
                    const scoreData = {
                        metadata: {
                            scoreOffset: scoreOffset,
                            createdAt: Date.now(),
                            version: "2.0"
                        },
                        notes: score
                    };
                    
                    const response = await fetch(`/api/score/${currentProject}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ score: scoreData })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `保存成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `保存失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Detect BPM
            async function detectBPM() {
                if (!currentProject) return;

                const useOriginal = elements.bpmSourceSelect.value === 'original';
                showLoading(`检测 BPM...${useOriginal ? '(使用原曲)' : '(使用鼓轨)'}`);
                
                try {
                    const response = await fetch('/api/detect_bpm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            useOriginal: useOriginal
                        })
                    });

                    const data = await response.json();
                    console.log('BPM detection response:', data); // 调试信息
                    
                    if (data.status === 'success') {
                        bmpData = data.bpm_data;  // 修复：后端返回的是 bpm_data 不是 bmp_data
                        
                        // 验证数据结构
                        if (!bmpData || typeof bmpData.bpm === 'undefined') {
                            throw new Error('无效的BPM数据结构');
                        }
                        
                        elements.bpmValue.textContent = Math.round(bmpData.bpm);
                        elements.manualBpm.value = bmpData.bpm;
                        
                        // Update offset input with detected offset
                        if (bmpData.offset !== undefined) {
                            audioOffset = bmpData.offset;
                            }
                        
                        const sourceText = bmpData.audio_source === 'original_track' ? '原曲' : 
                                         bmpData.audio_source === 'drums_fallback' ? '鼓轨(原曲未找到)' : '鼓轨';
                        const offsetText = bmpData.offset ? `, offset: ${bmpData.offset.toFixed(3)}s` : '';
                        showStatus(null, `BPM 检测成功: ${bmpData.bpm} (${bmpData.method_used}) - 音源: ${sourceText}${offsetText}`, 'success');
                        elements.generateBeatsBtn.disabled = false;
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `BPM 检测失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Generate beat grid
            async function generateBeatGrid() {
                if (!currentProject) return;

                const bpm = elements.manualBpm.value || (bmpData && bmpData.bpm);
                if (!bpm) {
                    showStatus(null, '请先检测 BPM 或输入手动 BPM', 'warning');
                    return;
                }

                showLoading('生成节拍网格...');

                try {
                    const response = await fetch('/api/analyze_beats', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            bpmOverride: parseFloat(bpm)
                        })
                    });

                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        beatGrid = data.beat_grid;
                        renderBeatGrid();
                        renderTimelineRuler();
                        
                        showStatus(null, 
                            `节拍网格生成成功: ${beatGrid.grid_metadata.total_beats} 个节拍, ${beatGrid.grid_metadata.total_measures} 个小节`, 
                            'success'
                        );
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `节拍网格生成失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Render timeline ruler with beat-aligned markers
            function renderTimelineRuler() {
                const ruler = elements.timelineRuler;
                const duration = wavesurfer.getDuration();
                if (!duration) {
                    ruler.innerHTML = '';
                    return;
                }

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                // If we have beat grid data, use it for alignment
                if (beatGrid && beatGrid.downbeats) {
                    // Add markers at downbeats (measure starts)
                    beatGrid.downbeats.forEach((time, index) => {
                        // Apply audio offset to timeline ruler markers
                        const offsetTime = time + audioOffset;
                        if (offsetTime <= duration && offsetTime >= 0) {
                            const position = offsetTime * currentPxPerSec;
                            const marker = document.createElement('div');
                            marker.style.position = 'absolute';
                            marker.style.left = `${position}px`;
                            marker.style.top = '0';
                            marker.style.height = '100%';
                            marker.style.borderLeft = '2px solid var(--border-color)';
                            marker.style.pointerEvents = 'none';
                            
                            // Add measure number label
                            const label = document.createElement('span');
                            label.textContent = `${index + 1} | ${formatTime(time)}`;
                            label.style.position = 'absolute';
                            label.style.left = '4px';
                            label.style.top = '4px';
                            label.style.fontSize = '11px';
                            label.style.color = 'var(--text-primary)';
                            label.style.backgroundColor = 'var(--bg-secondary)';
                            label.style.padding = '2px 4px';
                            label.style.borderRadius = '3px';
                            label.style.fontWeight = '600';
                            marker.appendChild(label);
                            
                            content.appendChild(marker);
                        }
                    });

                    // Add lighter markers at regular beats if zoom is high enough
                    if (currentPxPerSec > 200 && beatGrid.beats) {
                        beatGrid.beats.forEach(time => {
                            if (time <= duration) {
                                const position = time * currentPxPerSec;
                                const marker = document.createElement('div');
                                marker.style.position = 'absolute';
                                marker.style.left = `${position}px`;
                                marker.style.top = '0';
                                marker.style.height = '100%';
                                marker.style.borderLeft = '1px solid var(--border-color)';
                                marker.style.opacity = '0.5';
                                marker.style.pointerEvents = 'none';
                                
                                content.appendChild(marker);
                            }
                        });
                    }
                } else {
                    // Fallback to time-based markers if no beat grid
                    let interval;
                    if (currentPxPerSec < 100) {
                        interval = 10; // 10 seconds
                    } else if (currentPxPerSec < 200) {
                        interval = 5; // 5 seconds
                    } else if (currentPxPerSec < 500) {
                        interval = 2; // 2 seconds
                    } else {
                        interval = 1; // 1 second
                    }

                    for (let time = 0; time <= duration; time += interval) {
                        const position = time * currentPxPerSec;
                        const marker = document.createElement('div');
                        marker.style.position = 'absolute';
                        marker.style.left = `${position}px`;
                        marker.style.top = '0';
                        marker.style.height = '100%';
                        marker.style.borderLeft = '1px solid var(--border-color)';
                        marker.style.pointerEvents = 'none';
                        
                        const label = document.createElement('span');
                        label.textContent = formatTime(time);
                        label.style.position = 'absolute';
                        label.style.left = '4px';
                        label.style.top = '4px';
                        label.style.fontSize = '11px';
                        label.style.color = 'var(--text-muted)';
                        label.style.backgroundColor = 'var(--bg-secondary)';
                        label.style.padding = '1px 3px';
                        label.style.borderRadius = '2px';
                        marker.appendChild(label);
                        
                        content.appendChild(marker);
                    }
                }

                ruler.innerHTML = '';
                ruler.appendChild(content);
            }

            // Format time in MM:SS format
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            // Render beat grid overlay
            function renderBeatGrid() {
                if (!beatGrid) {
                    elements.beatGridOverlay.innerHTML = '';
                    return;
                }

                const duration = wavesurfer.getDuration();
                if (!duration) return;

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                const addLine = (time, className) => {
                    // Apply audio offset to shift all beat lines
                    const offsetTime = time + audioOffset;
                    const position = offsetTime * currentPxPerSec;
                    const line = document.createElement('div');
                    line.className = `beat-line ${className}`;
                    line.style.left = `${position}px`;
                    content.appendChild(line);
                };

                beatGrid.downbeats.forEach(time => addLine(time, 'downbeat'));
                beatGrid.beats.forEach(time => addLine(time, ''));

                if (beatGrid.subdivisions) {
                    const subdivisions = beatGrid.subdivisions.sixteenth_notes || [];
                    subdivisions.forEach(time => {
                        if (time <= duration) {
                            addLine(time, 'subdivision');
                        }
                    });
                }

                elements.beatGridOverlay.innerHTML = '';
                elements.beatGridOverlay.appendChild(content);
            }


            // Render annotations
            function renderAnnotations() {
                wsRegions.clearRegions();

                const duration = wavesurfer.getDuration();
                if (!duration) {
                    elements.annotationTrack.innerHTML = '';
                    return;
                }

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                annotations.forEach((annotation, index) => {
                    const regionId = annotation.id || `ann-${index}`;
                    
                    const region = wsRegions.addRegion({
                        id: regionId,
                        start: annotation.time,
                        end: annotation.time + (annotation.duration || 0.1),
                        color: annotation.type === 'don' ? 'rgba(255, 99, 71, 0.3)' : 'rgba(65, 105, 225, 0.3)',
                        drag: true,
                        resize: true
                    });

                    const marker = document.createElement('div');
                    marker.className = `annotation-marker ${annotation.type}`;
                    marker.dataset.id = regionId;
                    marker.textContent = annotation.type === 'don' ? '咚' : '咔';
                    
                    const position = annotation.time * currentPxPerSec;
                    const width = (annotation.duration || 0.1) * currentPxPerSec;
                    
                    marker.style.left = `${position}px`;
                    marker.style.width = `${width}px`;
                    
                    marker.addEventListener('click', () => selectAnnotation(annotation, marker, region));
                    
                    content.appendChild(marker);
                });
                
                elements.annotationTrack.innerHTML = '';
                elements.annotationTrack.appendChild(content);
            }

            // Render score (曲谱)
            function renderScore() {
                const duration = wavesurfer.getDuration();
                if (!duration) {
                    elements.scoreTrack.innerHTML = '';
                    return;
                }

                console.log(`[Score] 渲染曲谱: ${score.length} 个音符`);

                const totalWidth = duration * currentPxPerSec;
                const content = document.createElement('div');
                content.style.width = `${totalWidth}px`;
                content.style.height = '100%';
                content.style.position = 'relative';

                score.forEach((scoreItem, index) => {
                    const marker = document.createElement('div');
                    marker.className = `score-marker ${scoreItem.type}`;
                    marker.dataset.id = scoreItem.id || `score-${index}`;
                    marker.textContent = scoreItem.type === 'don' ? '咚' : '咔';
                    
                    // Direct positioning without any offset
                    const position = scoreItem.time * currentPxPerSec;
                    
                    console.log(`[Score] 音符${index}: 时间=${scoreItem.time.toFixed(3)}s, 位置=${position.toFixed(1)}px`);
                    
                    // Center the circle on the time position (subtract half the width)
                    marker.style.left = `${position - 15}px`; // 15px = half of 30px width
                    
                    marker.addEventListener('click', () => selectScore(scoreItem, marker));
                    
                    content.appendChild(marker);
                });
                
                elements.scoreTrack.innerHTML = '';
                elements.scoreTrack.appendChild(content);
            }

            // Select score item
            function selectScore(scoreItem, marker) {
                // Clear previous selection
                document.querySelectorAll('.score-marker.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                // Select new score item
                marker.classList.add('selected');
                
                // Seek to score position
                wavesurfer.seekTo(scoreItem.time / wavesurfer.getDuration());
            }

            // Generate initial score from annotations
            function generateScoreFromAnnotations() {
                score = annotations.map(annotation => ({
                    id: `score-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    time: annotation.time,
                    type: annotation.type
                }));
                
                renderScore();
                elements.exportMenuBtn.disabled = false;
                
                toastManager.success(`从标记生成了 ${score.length} 个曲谱音符`);
            }

            // Select annotation
            function selectAnnotation(annotation, marker, region) {
                // Clear previous selection
                document.querySelectorAll('.annotation-marker.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                document.querySelectorAll('.annotation-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                // Select new annotation
                selectedAnnotation = annotation;
                marker.classList.add('selected');
                
                // Highlight in list
                const listItem = document.querySelector(`[data-id="${annotation.id}"]`);
                if (listItem) {
                    listItem.classList.add('selected');
                }

                // Seek to annotation
                wavesurfer.seekTo(annotation.time / wavesurfer.getDuration());
            }

            // Update annotations list
            function updateAnnotationsList() {
                const list = elements.annotationsList;
                
                if (annotations.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">暂无标注</div>';
                    elements.exportMenuBtn.disabled = true;
                    return;
                }

                // Sort annotations by time
                const sortedAnnotations = [...annotations].sort((a, b) => a.time - b.time);
                
                list.innerHTML = '';
                sortedAnnotations.forEach(annotation => {
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    item.dataset.id = annotation.id;
                    
                    item.innerHTML = `
                        <div class="annotation-info">
                            <div class="annotation-type ${annotation.type}">${annotation.type === 'don' ? '咚' : '咔'}</div>
                            <div class="annotation-time">${annotation.time.toFixed(3)}s (${(annotation.duration || 0.1).toFixed(3)}s)</div>
                        </div>
                        <button class="btn btn-error btn-small" onclick="deleteAnnotation('${annotation.id}')">删除</button>
                    `;
                    
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            const marker = document.querySelector(`.annotation-marker[data-id="${annotation.id}"]`);
                            const region = wsRegions.getRegions().find(r => r.id === annotation.id);
                            if (marker && region) {
                                selectAnnotation(annotation, marker, region);
                            }
                        }
                    });
                    
                    list.appendChild(item);
                });

                elements.exportMenuBtn.disabled = false;
            }

            // Delete annotation
            window.deleteAnnotation = function(annotationId) {
                annotations = annotations.filter(ann => ann.id !== annotationId);
                
                // Remove region
                const region = wsRegions.getRegions().find(r => r.id === annotationId);
                if (region) {
                    region.remove();
                }
                
                // Remove marker
                const marker = document.querySelector(`.annotation-marker[data-id="${annotationId}"]`);
                if (marker) {
                    marker.remove();
                }
                
                updateAnnotationsList();
                
                if (selectedAnnotation && selectedAnnotation.id === annotationId) {
                    selectedAnnotation = null;
                }
            };

            // Add annotation at current time
            function addAnnotation(type) {
                if (!wavesurfer.getDuration()) return;

                const currentTime = wavesurfer.getCurrentTime();
                const newAnnotation = {
                    id: `ann-${Date.now()}`,
                    time: currentTime,
                    duration: 0.1,
                    type: type
                };

                annotations.push(newAnnotation);
                renderAnnotations();
                renderScore();
                updateAnnotationsList();
            }

            // Save annotations
            async function saveAnnotations() {
                if (!currentProject) return;

                showLoading('保存标注...');

                try {
                    const response = await fetch(`/api/annotations/${currentProject}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ annotations: annotations })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `保存成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `保存失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Export audio samples
            async function exportAudioSamples() {
                if (!currentProject) return;

                showLoading('导出音频样本...');

                try {
                    const response = await fetch('/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            projectName: currentProject,
                            audioFile: 'drums.mp3',
                            annotations: annotations
                        })
                    });

                    const data = await response.json();
                    
                    if (response.ok) {
                        showStatus(null, `导出成功: ${data.message}`, 'success');
                    } else {
                        throw new Error(data.message);
                    }
                } catch (error) {
                    showStatus(null, `导出失败: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }

            // Enable controls after project loads
            function enableControls() {
                elements.playBtn.disabled = false;
                elements.stopBtn.disabled = false;
                elements.loopBtn.disabled = false;
                elements.zoomInBtn.disabled = false;
                elements.zoomOutBtn.disabled = false;
                elements.detectBpmBtn.disabled = false;
                
                // Enable generate score button if we have annotations
                if (annotations.length > 0) {
                    elements.generateScoreBtn.disabled = false;
                    elements.exportMenuBtn.disabled = false;
                }
                
                // Enable export menu if we have score data
                if (score.length > 0) {
                    elements.exportMenuBtn.disabled = false;
                }
                
            }

            // Initialize snap precision dropdown
            function initSnapPrecision() {
                // Add event listener for dropdown changes
                elements.snapPrecisionSelect.addEventListener('change', () => {
                    quantizeMode = elements.snapPrecisionSelect.value;
                    
                    console.log(`[Snap] 吸附精度设置为: ${quantizeMode}`);
                    toastManager.info(`吸附精度: ${elements.snapPrecisionSelect.options[elements.snapPrecisionSelect.selectedIndex].text}`);
                });
            }

            // Event listeners
            elements.loadProjectBtn.addEventListener('click', () => {
                const project = elements.projectSelector.value;
                if (project) {
                    loadProject(project);
                }
            });

            elements.detectBpmBtn.addEventListener('click', detectBPM);
            elements.generateBeatsBtn.addEventListener('click', generateBeatGrid);
            elements.generateScoreBtn.addEventListener('click', generateScoreFromAnnotations);
            
            // Export popup menu functionality
            function toggleExportMenu() {
                const isVisible = elements.exportPopupMenu.style.display !== 'none';
                elements.exportPopupMenu.style.display = isVisible ? 'none' : 'block';
            }
            
            function hideExportMenu() {
                elements.exportPopupMenu.style.display = 'none';
            }
            
            // Export menu button
            elements.exportMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleExportMenu();
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', () => {
                hideExportMenu();
            });
            
            // Export menu item handlers
            elements.saveAnnotationsMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                saveAnnotations();
            });
            
            elements.exportAudioSamplesMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                exportAudioSamples();
            });
            
            elements.saveScoreMenuBtn.addEventListener('click', () => {
                hideExportMenu();
                saveScore();
            });
            
            elements.saveAllMenuBtn.addEventListener('click', async () => {
                hideExportMenu();
                showLoading('保存全部...');
                try {
                    await saveAnnotations();
                    await saveScore(); 
                    await exportAudioSamples();
                    toastManager.success('全部保存完成！');
                } catch (error) {
                    toastManager.error(`保存失败: ${error.message}`);
                } finally {
                    hideLoading();
                }
            });

            // Audio source select functionality
            elements.audioSourceSelect.addEventListener('change', () => {
                const selectedSource = elements.audioSourceSelect.value;
                switchAudioSource(selectedSource);
            });

            // Transport controls
            elements.playBtn.addEventListener('click', () => {
                // Apply offset when starting playback
                if (!wavesurfer.isPlaying()) {
                    const currentTime = wavesurfer.getCurrentTime();
                    // If starting from beginning, apply offset
                    if (currentTime === 0 && audioOffset !== 0) {
                        const offsetTime = Math.max(0, audioOffset);
                        wavesurfer.seekTo(offsetTime / wavesurfer.getDuration());
                        console.log(`[Offset] 播放时应用offset: ${audioOffset.toFixed(3)}s`);
                    }
                }
                wavesurfer.playPause();
            });
            elements.stopBtn.addEventListener('click', () => wavesurfer.stop());
            elements.loopBtn.addEventListener('click', () => {
                isLooping = !isLooping;
                elements.loopBtn.style.background = isLooping ? 'var(--accent-primary)' : 'var(--bg-tertiary)';
            });

            // Zoom controls - WaveSurfer v7 API
            let minPxPerSec = 50;   // 最小像素每秒
            let maxPxPerSec = 2000; // 最大像素每秒
            let currentPxPerSec = 100; // 当前像素每秒
            
            elements.zoomInBtn.addEventListener('click', () => {
                currentPxPerSec = Math.min(currentPxPerSec * 1.5, maxPxPerSec);
                wavesurfer.zoom(currentPxPerSec);
                // Re-render all overlays with new zoom level and offset
                renderBeatGrid();
                renderTimelineRuler();
                renderScore();
            });
            
            elements.zoomOutBtn.addEventListener('click', () => {
                currentPxPerSec = Math.max(currentPxPerSec / 1.5, minPxPerSec);
                wavesurfer.zoom(currentPxPerSec);
                // Re-render all overlays with new zoom level and offset
                renderBeatGrid();
                renderTimelineRuler();
                renderScore();
            });

            // Tool selection
            elements.toolSelect.addEventListener('click', () => {
                currentTool = 'select';
                updateToolSelection();
            });
            elements.toolDon.addEventListener('click', () => {
                currentTool = 'don';
                updateToolSelection();
            });
            elements.toolKa.addEventListener('click', () => {
                currentTool = 'ka';
                updateToolSelection();
            });

            function updateToolSelection() {
                document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                    btn.style.background = 'var(--bg-tertiary)';
                });
                
                const selectedTool = document.getElementById(`tool-${currentTool}`);
                if (selectedTool) {
                    selectedTool.style.background = 'var(--accent-primary)';
                }
            }



            // Generate snap grid based on quantization mode
            function generateSnapGrid() {
                if (!beatGrid || !beatGrid.beats) {
                    return [];
                }
                
                const beats = beatGrid.beats;
                const beatInterval = beatGrid.beat_interval;
                let snapPoints = [];
                
                console.log(`[Snap] 生成${quantizeMode}精度网格`);
                
                switch (quantizeMode) {
                    case '1/4':
                        // Quarter notes - use main beats
                        snapPoints = beats;
                        break;
                        
                    case '1/8':
                        // Eighth notes - beats + off-beats
                        beats.forEach(beatTime => {
                            snapPoints.push(beatTime);
                            snapPoints.push(beatTime + beatInterval / 2);
                        });
                        break;
                        
                    case '1/16':
                        // Sixteenth notes - 4 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 4; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 4));
                            }
                        });
                        break;
                        
                    case '1/8T':
                        // Eighth triplets - 3 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 3; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 3));
                            }
                        });
                        break;
                        
                    case '1/16T':
                        // Sixteenth note triplets - 6 divisions per beat (2 triplet groups)
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 6; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 6));
                            }
                        });
                        break;
                        
                    case '1/32':
                        // Thirty-second notes - 8 divisions per beat
                        beats.forEach(beatTime => {
                            for (let i = 0; i < 8; i++) {
                                snapPoints.push(beatTime + (i * beatInterval / 8));
                            }
                        });
                        break;
                        
                    default:
                        snapPoints = beats;
                }
                
                // Sort and remove duplicates
                snapPoints = [...new Set(snapPoints)].sort((a, b) => a - b);
                
                console.log(`[Snap] 生成了${snapPoints.length}个吸附点`);
                return snapPoints;
            }

            // Simple Snap to Grid functionality
            function snapToGrid() {
                if (!beatGrid || !beatGrid.beats || score.length === 0) {
                    toastManager.warning('需要先生成节拍网格和曲谱');
                    return;
                }

                showLoading(`吸附音符到${quantizeMode}网格...`);

                try {
                    // Generate snap grid based on selected quantization
                    const snapPoints = generateSnapGrid();
                    
                    if (snapPoints.length === 0) {
                        throw new Error('无法生成吸附网格');
                    }
                    
                    let snappedCount = 0;
                    let totalAdjustment = 0;

                    score.forEach((scoreItem, index) => {
                        const originalTime = scoreItem.time;
                        
                        // Find closest snap point
                        let closestSnapPoint = snapPoints[0];
                        let minDistance = Math.abs(originalTime - closestSnapPoint);

                        for (const snapPoint of snapPoints) {
                            const distance = Math.abs(originalTime - snapPoint);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestSnapPoint = snapPoint;
                            }
                        }

                        // Snap to closest point
                        const adjustment = Math.abs(originalTime - closestSnapPoint);
                        scoreItem.time = closestSnapPoint;
                        
                        snappedCount++;
                        totalAdjustment += adjustment;

                        console.log(`[Snap] 音符${index}: ${originalTime.toFixed(3)}s -> ${closestSnapPoint.toFixed(3)}s (调整: ${(adjustment*1000).toFixed(0)}ms)`);
                    });

                    // Re-render score
                    renderScore();

                    const avgAdjustment = totalAdjustment / snappedCount;
                    toastManager.success(`${quantizeMode}网格吸附完成！${snappedCount}个音符，平均调整${(avgAdjustment*1000).toFixed(0)}ms`);
                    console.log(`[Snap] 完成：${snappedCount}个音符吸附到${quantizeMode}网格，平均调整${(avgAdjustment*1000).toFixed(0)}ms`);

                } catch (error) {
                    console.error('[Snap] Error:', error);
                    toastManager.error(`吸附失败: ${error.message}`);
                } finally {
                    hideLoading();
                }
            }


            // Timeline click to add annotations
            elements.annotationTrack.addEventListener('click', (e) => {
                if (currentTool !== 'select' && wavesurfer.getDuration()) {
                    const rect = elements.annotationTrack.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const timePosition = (x / rect.width) * wavesurfer.getDuration();
                    
                    wavesurfer.seekTo(timePosition / wavesurfer.getDuration());
                    addAnnotation(currentTool);
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        wavesurfer.playPause();
                        break;
                    case 'd':
                        e.preventDefault();
                        addAnnotation('don');
                        break;
                    case 'k':
                        e.preventDefault();
                        addAnnotation('ka');
                        break;
                    case 'backspace':
                    case 'delete':
                        e.preventDefault();
                        if (selectedAnnotation) {
                            deleteAnnotation(selectedAnnotation.id);
                        }
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            saveAnnotations();
                        }
                        break;
                }
            });

            // Sidebar toggle for mobile
            elements.sidebarToggle.addEventListener('click', () => {
                elements.sidebar.classList.toggle('open');
            });

            // Track labels toggle
            elements.toggleTrackLabelsBtn.addEventListener('click', () => {
                elements.trackLabels.classList.toggle('collapsed');
                // Use a short timeout to allow the CSS transition to finish before redrawing WaveSurfer
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 300); // This should match the CSS transition duration
            });

            // Sync timeline elements scroll position
            function syncTimelineScroll() {
                const scrollLeft = wavesurfer.getScroll();

                const rulerContent = elements.timelineRuler.firstChild;
                if (rulerContent) {
                    rulerContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const gridContent = elements.beatGridOverlay.firstChild;
                if (gridContent) {
                    gridContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const annotationContent = elements.annotationTrack.firstChild;
                if (annotationContent) {
                    annotationContent.style.transform = `translateX(-${scrollLeft}px)`;
                }

                const scoreContent = elements.scoreTrack.firstChild;
                if (scoreContent) {
                    scoreContent.style.transform = `translateX(-${scrollLeft}px)`;
                }
            }

            // WaveSurfer events
            wavesurfer.on('ready', () => {
                hideLoading();
                
                // 只有在非音频源切换时才进行自动缩放
                if (!isSwitchingAudio) {
                    const duration = wavesurfer.getDuration();
                    const containerWidth = wavesurfer.getWrapper().clientWidth;
                    if (duration > 0) {
                        const targetViewDuration = Math.min(duration, 15);
                        currentPxPerSec = Math.max(containerWidth / targetViewDuration, minPxPerSec);
                        wavesurfer.zoom(currentPxPerSec);
                    }
                }
                
                // Initial render and sync
                renderBeatGrid();
                renderTimelineRuler();
                renderAnnotations();
                renderScore();
                syncTimelineScroll();
            });

            wavesurfer.on('zoom', () => {
                // In WaveSurfer v7, minPxPerSec option is updated to the current zoom level.
                currentPxPerSec = wavesurfer.options.minPxPerSec;
                renderBeatGrid();
                renderTimelineRuler();
                renderAnnotations();
                renderScore();
                syncTimelineScroll();
            });

            wavesurfer.on('scroll', () => {
                syncTimelineScroll();
            });

            wavesurfer.on('finish', () => {
                if (isLooping) {
                    wavesurfer.seekTo(0);
                    wavesurfer.play();
                }
            });

            // Region events
            wsRegions.on('region-updated', (region) => {
                const annotation = annotations.find(ann => ann.id === region.id);
                if (annotation) {
                    annotation.time = region.start;
                    annotation.duration = region.end - region.start;
                    updateAnnotationsList();
                    // Re-render markers to reflect the change, then sync scroll
                    renderAnnotations();
                renderScore(); 
                    syncTimelineScroll();
                }
            });

            // Timeline ruler vertical drag zoom
            let isDragZooming = false;
            let dragStartY = 0;
            let dragStartZoom = 0;

            elements.timelineRuler.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    isDragZooming = true;
                    dragStartY = e.clientY;
                    dragStartZoom = currentPxPerSec;
                    
                    // Prevent text selection during drag
                    e.preventDefault();
                    document.body.style.userSelect = 'none';
                    elements.timelineRuler.style.cursor = 'ns-resize';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragZooming) {
                    const deltaY = dragStartY - e.clientY; // Negative for up, positive for down
                    const sensitivity = 0.01; // Adjust zoom sensitivity
                    const zoomFactor = 1 + (deltaY * sensitivity);
                    
                    const newZoom = Math.max(
                        Math.min(dragStartZoom * zoomFactor, maxPxPerSec),
                        minPxPerSec
                    );
                    
                    if (Math.abs(newZoom - currentPxPerSec) > 1) {
                        currentPxPerSec = newZoom;
                        wavesurfer.zoom(currentPxPerSec);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragZooming) {
                    isDragZooming = false;
                    document.body.style.userSelect = '';
                    elements.timelineRuler.style.cursor = '';
                }
            });

            // Mouse wheel zoom (like in professional DAWs)
            document.getElementById('timeline-container').addEventListener('wheel', (e) => {
                if (e.ctrlKey || e.metaKey) { // Ctrl/Cmd + wheel for zoom
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;
                    currentPxPerSec = Math.max(
                        Math.min(currentPxPerSec * zoomFactor, maxPxPerSec),
                        minPxPerSec
                    );
                    wavesurfer.zoom(currentPxPerSec);
                }
            });

            // Window resize handler
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    renderBeatGrid();
                    renderTimelineRuler();
                    renderAnnotations();
                renderScore();
                    syncTimelineScroll();
                }, 100);
            });

            // Initialize
            initSnapPrecision();
            loadProjects();
            updateToolSelection();
            updateAudioSourceDisplay();
        });
    </script>
</body>
</html>